<!DOCTYPE html>
<!-- Version: 7.0 - Always Stacked + Enhanced Auto-Sync - Timestamp: May 1, 2024 2:00 PM -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- Add unique query parameter to force cache invalidation -->
    <meta name="cache-bust-timestamp" content="1714587433">
    <script>
        // Set a dynamic timestamp on page load
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelector('meta[name="cache-bust-timestamp"]').content = Date.now();
        });
    </script>
    <title>Asana Sync Manager - JoJo's Shave Ice</title>
    <link rel="stylesheet" href="../assets/css/styles.css">
    <!-- Add Chart.js and Moment.js for graph visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
    <style>
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #FF4040;
            text-decoration: none;
            font-weight: bold;
        }
        .back-link:hover {
            text-decoration: underline;
        }
        .asana-container {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h2 {
            color: #444;
            margin-top: 0;
        }
        .info-box {
            background-color: #f8f9fa;
            border-left: 4px solid #87CEEB;
            padding: 15px;
            margin-bottom: 20px;
        }
        .connection-status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            margin-left: 10px;
        }
        .status-connected {
            background-color: #28a745;
            color: white;
        }
        .status-disconnected {
            background-color: #dc3545;
            color: white;
        }
        .btn {
            display: inline-block;
            background-color: #FF4040;
            color: white;
            text-decoration: none;
            padding: 8px 15px;
            border-radius: 4px;
            font-weight: bold;
            transition: background-color 0.3s ease;
            border: none;
            cursor: pointer;
        }
        .btn:hover {
            background-color: #d93333;
        }
        .btn-secondary {
            background-color: #6c757d;
        }
        .btn-secondary:hover {
            background-color: #5a6268;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="text"],
        input[type="password"],
        select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        /* Tab Navigation */
        .tab-nav {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }
        .tab-btn {
            padding: 10px 20px;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            font-weight: bold;
            color: #666;
        }
        .tab-btn.active {
            border-bottom: 2px solid #FF4040;
            color: #FF4040;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        
        /* Two-column layout */
        .row {
            display: flex;
            margin: 0 -10px;
        }
        .col {
            padding: 0 10px;
            flex: 1;
        }
        
        /* Project list */
        .project-list {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
        }
        .project-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
        }
        .project-item:last-child {
            border-bottom: none;
        }
        .project-checkbox {
            margin-right: 8px;
        }
        .project-stats {
            font-size: 0.8rem;
            color: #666;
            margin-top: 5px;
        }
        
        /* History log */
        .history-log {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        .log-entry {
            padding: 8px;
            border-bottom: 1px solid #eee;
            font-size: 0.9rem;
        }
        .log-entry:last-child {
            border-bottom: none;
        }
        .log-time {
            color: #888;
            font-size: 0.8rem;
        }
        .log-message {
            margin-top: 3px;
        }
        .log-success {
            color: #28a745;
        }
        .log-error {
            color: #dc3545;
        }
        .log-warning {
            color: #ffc107;
        }
        .log-info {
            color: #17a2b8;
        }
        
        /* Task viewer */
        .task-filters {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        .task-list {
            margin-top: 20px;
        }
        .task-item {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 10px;
            background-color: #f9f9f9;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .task-item:hover {
            background-color: #f0f0f0;
        }
        .task-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .task-details {
            color: #666;
            font-size: 0.9rem;
        }
        
        /* Task modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 1000;
            overflow: auto;
        }
        .modal-content {
            background-color: white;
            margin: 40px auto;
            padding: 20px;
            width: 80%;
            max-width: 800px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .modal-title {
            font-size: 1.4rem;
            font-weight: bold;
        }
        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
        }
        .modal-body {
            max-height: 70vh;
            overflow-y: auto;
        }
        .task-property {
            margin-bottom: 15px;
        }
        .property-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .load-more {
            text-align: center;
            margin-top: 15px;
        }
        .info-value {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        
        /* Add styles for retry queue components */
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-error { background-color: #dc3545; }
        .status-queued { background-color: #ffc107; }
        .status-retrying { background-color: #17a2b8; }
        .status-success { background-color: #28a745; }
        
        .project-error { color: #dc3545; margin-left: 15px; }
        
        .log-container {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 14px;
        }
        .log-entry {
            margin-bottom: 5px;
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }
        .log-timestamp {
            color: #6c757d;
            margin-right: 10px;
        }
        .log-error { color: #dc3545; }
        .log-success { color: #28a745; }
        .log-info { color: #17a2b8; }
        
        .project-item-retry {
            padding: 12px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .project-item-retry:last-child { border-bottom: none; }
        .project-item-retry:nth-child(odd) { background-color: #f9f9f9; }
        
        .project-name { font-weight: bold; flex: 1; }
        .project-error { margin-left: 15px; flex: 2; }
        .project-actions { flex: 0 0 100px; text-align: right; }
        
        .btn-success { 
            background-color: #28a745;
            color: white;
        }
        .btn-success:hover { 
            background-color: #218838;
        }
    </style>
</head>
<body>
    <header>
        <h1>JoJo's Shave Ice Management Hub</h1>
    </header>
    
    <div class="container">
        <a href="/" class="back-link">← Back to Dashboard</a>
        
        <div class="asana-container">
            <h2>Asana Sync Manager <span class="connection-status status-disconnected">Disconnected</span></h2>
            
            <div id="connection-notice" class="info-box">
                <p>This tool allows you to synchronize tasks between Asana and JoJo's Shave Ice internal systems. Connect your Asana account to get started.</p>
                </div>
            
            <!-- Always show tab navigation -->
            <div class="tab-nav">
                <button class="tab-btn active" data-tab="workspace-sync">Workspace Sync</button>
                <button class="tab-btn" data-tab="task-viewer">Task Viewer</button>
                <button class="tab-btn" data-tab="retry-queue">Retry Queue</button>
                <button class="tab-btn" data-tab="settings">Settings</button>
            </div>
            
            <!-- Workspace Sync Tab -->
            <div id="workspace-sync" class="tab-content active">
                <div id="not-connected-workspace" class="info-box" style="background-color: #fff3cd; border-left-color: #ffc107;">
                    <p>You need to configure your Asana connection first. Go to the Settings tab to enter your Asana Personal Access Token.</p>
        </div>
        
                <div id="connected-workspace" style="display: none;">
                    <div class="form-group">
                        <label for="workspace-select">Select Workspace</label>
                        <select id="workspace-select">
                            <option value="">-- Select a workspace --</option>
                            <!-- Workspaces will be loaded from Firestore -->
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <button id="force-sync-btn" class="btn">Force Sync Now</button>
                        <button id="view-sync-stats-btn" class="btn btn-secondary" style="margin-left: 10px;">View Sync Stats</button>
                        <span id="last-sync-time" style="margin-left: 15px; font-size: 0.9rem; color: #666;">Last sync: Loading...</span>
                        <span id="next-auto-sync" style="margin-left: 15px; font-size: 0.9rem; color: #666;">Next auto-sync: Calculating...</span>
                    </div>
                    
                    <!-- Add search and project management tools -->
                    <div class="project-tools" style="margin-bottom: 15px; padding: 12px; background-color: #f8f9fa; border-radius: 4px;">
                        <div class="row">
                            <div class="col">
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label for="project-search" style="display: inline-block; margin-right: 10px;">Search Projects:</label>
                                    <input type="text" id="project-search" placeholder="Type to filter projects..." style="display: inline-block; width: 250px;">
                                </div>
                            </div>
                            <div class="col" style="text-align: right;">
                                <button id="delete-projects-btn" class="btn btn-secondary" disabled>Delete Selected Projects</button>
                            </div>
                    </div>
                </div>
                
                    <div class="row">
                        <div class="col">
                            <h3>Projects</h3>
                            <div class="form-group">
                                <label class="project-select-all">
                                    <input type="checkbox" id="select-all-projects"> Select all projects
                                </label>
                    </div>
                            <div class="project-list" id="project-list">
                                <!-- Projects will be loaded from asana_projects collection -->
                                <div class="loading-indicator">Loading projects...</div>
                        </div>
                    </div>
                        <div class="col">
                            <h3>Sync History</h3>
                            <div class="history-log" id="history-log">
                                <!-- Sync logs will be loaded from asana_sync_logs collection -->
                                <div class="loading-indicator">Loading sync history...</div>
                </div>
                            <div class="load-more">
                                <button id="load-more-logs" class="btn btn-secondary">Load More</button>
            </div>
                    </div>
                        </div>
                    </div>
                </div>
            
            <!-- Task Viewer Tab -->
            <div id="task-viewer" class="tab-content">
                <div id="not-connected-tasks" class="info-box" style="background-color: #fff3cd; border-left-color: #ffc107;">
                    <p>You need to configure your Asana connection first. Go to the Settings tab to enter your Asana Personal Access Token.</p>
            </div>
            
                <div id="connected-tasks" style="display: none;">
                    <div class="task-filters">
                        <div class="row">
                            <div class="col">
                                <div class="form-group">
                                    <label for="filter-project">Project</label>
                                    <select id="filter-project">
                                        <option value="">All Projects</option>
                                        <!-- Projects will be loaded from Firestore -->
                                    </select>
                    </div>
                        </div>
                            <div class="col">
                                <div class="form-group">
                                    <label for="filter-status">Status</label>
                                    <select id="filter-status">
                                        <option value="">All Statuses</option>
                                        <option value="false">Not Started</option>
                                        <option value="true">Completed</option>
                                </select>
                            </div>
                            </div>
                            <div class="col">
                                <div class="form-group">
                                    <label for="filter-assignee">Assignee</label>
                                    <select id="filter-assignee">
                                        <option value="">All Assignees</option>
                                        <!-- Assignees will be loaded from Firestore -->
                                    </select>
                        </div>
                    </div>
                </div>
                        <div class="form-group">
                            <button id="apply-filters" class="btn">Apply Filters</button>
                            <button id="reset-filters" class="btn btn-secondary" style="margin-left: 10px;">Reset</button>
                    </div>
                </div>
                
                    <div class="task-list" id="task-list">
                        <!-- Tasks will be loaded from Firestore -->
                        <div class="loading-indicator">Loading tasks...</div>
                    </div>
                    <div class="load-more">
                        <button id="load-more-tasks" class="btn btn-secondary">Load More Tasks</button>
                        </div>
                    </div>
            </div>
            
            <!-- Retry Queue Tab -->
            <div id="retry-queue" class="tab-content">
                <div id="not-connected-retry-queue" class="info-box" style="background-color: #fff3cd; border-left-color: #ffc107;">
                    <p>You need to configure your Asana connection first. Go to the Settings tab to enter your Asana Personal Access Token.</p>
                </div>
                
                <div id="connected-retry-queue" style="display: none;">
                    <div id="queue-status" class="card">
                        <h3>Retry Queue Status</h3>
                        <p>Queue status: <span id="queue-state">Inactive</span></p>
                        <p>Next retry: <span id="next-retry">None scheduled</span></p>
                        <p>Projects in queue: <span id="queue-count">0</span></p>
                        
                        <div>
                            <button id="start-queue" class="btn btn-success">Start Retry Queue</button>
                            <button id="stop-queue" class="btn btn-secondary" disabled>Stop Queue</button>
                            <button id="retry-now" class="btn" disabled>Retry Now</button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h3>Failed Projects Queue</h3>
                        <p>These projects encountered errors during sync and are queued for retry.</p>
                        
                        <div id="project-list-retry" class="project-list">
                            <div class="project-item" style="background-color: #f0f0f0; font-weight: bold;">
                                <div class="project-name">Project Name</div>
                                <div class="project-error">Error</div>
                                <div class="project-actions">Actions</div>
                            </div>
                            <!-- Projects will be loaded here -->
                            <div id="no-projects" style="padding: 20px; text-align: center; color: #6c757d;">
                                No failed projects in queue
                            </div>
                        </div>
                        
                        <div style="margin-top: 15px;">
                            <button id="refresh-list" class="btn btn-secondary">Refresh List</button>
                            <button id="retry-all" class="btn" disabled>Retry All Now</button>
                            <button id="clear-queue" class="btn btn-secondary" disabled>Clear Queue</button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h3>Retry Log</h3>
                        <div id="retry-log" class="log-container" style="background-color: #f8f9fa; padding: 15px; border-radius: 4px; margin-top: 20px; max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 14px;">
                            <!-- Log entries will be added here -->
                            <div class="log-entry" style="margin-bottom: 5px; padding: 5px 0; border-bottom: 1px solid #eee;">
                                <span class="log-timestamp" style="color: #6c757d; margin-right: 10px;">[System]</span>
                                <span class="log-info" style="color: #17a2b8;">Retry system initialized</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Settings Tab -->
            <div id="settings" class="tab-content">
                <div id="current-connection" class="asana-container" style="display: none;">
                    <h3>Current Connection</h3>
                    <div class="form-group">
                        <label>Personal Access Token:</label>
                        <div id="current-token" class="info-value">••••••••••••••••</div>
                    </div>
                    <div class="form-group">
                        <label>Sync Frequency:</label>
                        <div id="current-frequency" class="info-value">Every hour</div>
                        </div>
                    <div class="form-group">
                        <label>Last Sync:</label>
                        <div id="current-last-sync" class="info-value">Never</div>
                    </div>
                    <div class="form-group">
                        <button id="edit-settings" class="btn">Edit Settings</button>
                        <button id="clear-settings" class="btn btn-secondary" style="margin-left: 10px;">Clear Settings</button>
                </div>
            </div>
            
                <div id="settings-form-container">
                    <div class="info-box">
                        <p>Configure your Asana integration settings here. Your Personal Access Token will be securely stored in Firestore.</p>
                    </div>
        
                    <form id="settings-form">
                        <div class="form-group">
                            <label for="asana-pat">Asana Personal Access Token (PAT)</label>
                            <input type="password" id="asana-pat" placeholder="Enter your Asana PAT">
                            <small style="display: block; margin-top: 5px; color: #666;">You can generate a PAT in your Asana account settings</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="sync-frequency">Sync Frequency</label>
                            <select id="sync-frequency">
                                <option value="15">Every 15 minutes</option>
                                <option value="30">Every 30 minutes</option>
                                <option value="60" selected>Every hour</option>
                                <option value="360">Every 6 hours</option>
                                <option value="720">Every 12 hours</option>
                                <option value="1440">Once a day</option>
                            </select>
                    </div>
                        
                        <div class="form-group">
                            <button type="submit" class="btn">Save Settings</button>
                            <button type="button" id="test-connection" class="btn btn-secondary" style="margin-left: 10px;">Test Connection</button>
                            <button type="button" id="cancel-edit" class="btn btn-secondary" style="margin-left: 10px; display: none;">Cancel</button>
                </div>
                    </form>
                    
                    <!-- Debug Section (for admin use) -->
                    <div style="margin-top: 30px; border-top: 1px dashed #ccc; padding-top: 20px;">
                        <h4>Admin Debug Tools</h4>
                        <p>Use these tools to troubleshoot connection issues.</p>
                        
                        <div class="form-group">
                            <button id="debug-show-data" class="btn btn-secondary">Show Database Data</button>
                            <button id="debug-create-settings" class="btn btn-secondary" style="margin-left: 10px;">Create Sample Settings</button>
                            <button id="debug-create-projects" class="btn btn-secondary" style="margin-left: 10px;">Create Sample Projects</button>
                            <button id="debug-clear-logs" class="btn btn-secondary" style="margin-left: 10px;">Clear Console</button>
    </div>

                        <div id="debug-output" style="margin-top: 15px; background-color: #f5f5f5; padding: 10px; border-radius: 4px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px;"></div>
                    </div>
                </div>
            </div>
        </div>
        
    <!-- Task Detail Modal -->
    <div id="task-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Task Details</h3>
                <button class="close-btn">&times;</button>
            </div>
            <div class="modal-body" id="task-modal-body">
                <!-- Task details will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <!-- Sync Statistics Modal -->
    <div id="sync-stats-modal" class="modal">
        <div class="modal-content" style="width: 90%; max-width: 1000px;">
            <div class="modal-header">
                <h3 class="modal-title">Sync Statistics</h3>
                <button class="close-btn">&times;</button>
            </div>
            <div class="modal-body" id="sync-stats-modal-body">
                <div class="stats-controls" style="margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #eee;">
                    <div class="row">
                        <div class="col">
                            <div class="form-group">
                                <label for="stats-date-range">Time Range:</label>
                                <select id="stats-date-range" class="form-control">
                                    <option value="7">Last 7 days</option>
                                    <option value="14">Last 14 days</option>
                                    <option value="30">Last 30 days</option>
                                </select>
                            </div>
                        </div>
                        <div class="col">
                            <div class="form-group">
                                <label for="display-mode">Display Mode:</label>
                                <select id="display-mode" class="form-control">
                                    <option value="count">Count</option>
                                    <option value="percentage">Percentage</option>
                                </select>
                            </div>
                        </div>
                        <div class="col">
                            <div class="form-group">
                                <label for="stats-project-filter">Filter by Project:</label>
                                <div class="project-filter-container" style="position: relative;">
                                    <div class="selected-projects-display" style="padding: 8px; border: 1px solid #ced4da; border-radius: 4px; background-color: #fff; cursor: pointer; height: 38px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;">
                                        <span id="selected-projects-text">All Projects</span>
                                        <i class="dropdown-icon" style="float: right;">▼</i>
                                    </div>
                                    <div id="project-filter-dropdown" style="display: none; position: absolute; top: 100%; left: 0; width: 100%; max-height: 250px; overflow-y: auto; background-color: #fff; border: 1px solid #ced4da; border-top: none; border-radius: 0 0 4px 4px; z-index: 1000; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
                                        <div style="padding: 8px; border-bottom: 1px solid #eee;">
                                            <label style="margin-bottom: 0; width: 100%;">
                                                <input type="checkbox" id="select-all-projects-filter" style="margin-right: 8px;">
                                                <strong>Select All</strong>
                                            </label>
                                        </div>
                                        <div id="project-filter-list" style="padding: 8px 0;">
                                            <!-- Projects will be populated dynamically as checkboxes -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="row" style="margin-top: 10px;">
                        <div class="col">
                            <button id="apply-stats-filters" class="btn btn-primary btn-sm">Apply Filters</button>
                            <button id="reset-stats-filters" class="btn btn-secondary btn-sm" style="margin-left: 5px;">Reset</button>
                            <button id="drill-up-btn" class="btn btn-info btn-sm" style="margin-left: 5px; display: none;">Back to Summary</button>
                            <span id="auto-sync-indicator" style="margin-left: 15px; padding: 3px 8px; border-radius: 10px; background-color: #e8f7ff; color: #0056b3; font-size: 0.8rem;">Auto-sync: <span id="auto-sync-status">Checking...</span></span>
                        </div>
                    </div>
                </div>
                
                <!-- Graph container -->
                <canvas id="sync-stats-graph" style="width: 100%; height: 400px;"></canvas>
                
                <!-- Statistics summary -->
                <div id="sync-stats-summary" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee;">
                    <h4>Summary</h4>
                    <div class="row">
                        <div class="col">
                            <div class="stat-box" style="background-color: #f8f9fa; padding: 10px; border-radius: 4px;">
                                <div class="stat-title" style="font-weight: bold; margin-bottom: 5px;">Total Syncs</div>
                                <div id="stat-total-syncs" class="stat-value" style="font-size: 1.5rem; color: #333;">--</div>
                            </div>
                        </div>
                        <div class="col">
                            <div class="stat-box" style="background-color: #f8f9fa; padding: 10px; border-radius: 4px;">
                                <div class="stat-title" style="font-weight: bold; margin-bottom: 5px;">Average Success Rate</div>
                                <div id="stat-avg-success-rate" class="stat-value" style="font-size: 1.5rem; color: #28a745;">--</div>
                            </div>
                        </div>
                        <div class="col">
                            <div class="stat-box" style="background-color: #f8f9fa; padding: 10px; border-radius: 4px;">
                                <div class="stat-title" style="font-weight: bold; margin-bottom: 5px;">Most Common Error</div>
                                <div id="stat-common-error" class="stat-value" style="font-size: 1rem; color: #dc3545;">--</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer>
        JoJo's Shave Ice Management Hub &copy; 2024 | Version 1.0.0
    </footer>
    
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script>
        // Force cache clear on page load
        window.onload = function() {
            console.log('Page loaded with cache-busting timestamp: ' + new Date().toISOString());
            
            // Add a visual indicator that this is the latest version
            const versionIndicator = document.createElement('div');
            versionIndicator.style.position = 'fixed';
            versionIndicator.style.bottom = '10px';
            versionIndicator.style.right = '10px';
            versionIndicator.style.backgroundColor = 'rgba(0,0,0,0.7)';
            versionIndicator.style.color = 'white';
            versionIndicator.style.padding = '5px 10px';
            versionIndicator.style.borderRadius = '4px';
            versionIndicator.style.fontSize = '12px';
            versionIndicator.style.zIndex = '9999';
            versionIndicator.textContent = 'v2.0 - May 1 Error Fix';
            document.body.appendChild(versionIndicator);
            
            // Skip version check - just display instructions in console
            console.log('For best results, please use Ctrl+F5 (Windows/Linux) or Cmd+Shift+R (Mac) to force reload without cache');
        };
        
        // Initialize Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyCgEDfRBjbqqnwWc0TeR97V3RvfrvjJu1U",
            authDomain: "jojo-s-app-back-end.firebaseapp.com",
            projectId: "jojo-s-app-back-end",
            storageBucket: "jojo-s-app-back-end.appspot.com",
            messagingSenderId: "344579778389",
            appId: "1:344579778389:web:6a17be1a1d13b82955f1dc",
            measurementId: "G-VBP44WBTCP"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        
        document.addEventListener('DOMContentLoaded', function() {
            // Debug function to explore Firestore collections
            function exploreFirestoreCollections() {
                console.log("Exploring Firestore collections...");

                // Map all collections we need to check
                const collections = [
                    'asana_projects',
                    'asana_tasks',
                    'asana_sync_logs',
                    'asana_change_logs',
                    'asana_workspaces',
                    'asana_config'
                ];

                collections.forEach(collectionName => {
                    db.collection(collectionName).limit(5).get()
                        .then(snapshot => {
                            console.log(`Collection '${collectionName}' exists: ${!snapshot.empty}`);
                            if (!snapshot.empty) {
                                console.log(`Sample document from '${collectionName}':`);
                                const sampleDoc = snapshot.docs[0].data();
                                console.log(sampleDoc);
                            }
                        })
                        .catch(error => {
                            console.log(`Error checking collection '${collectionName}':`, error);
                        });
                });
            }

            // Run the exploration function
            exploreFirestoreCollections();
            
            // Tab navigation setup
            const tabButtons = document.querySelectorAll('.tab-btn');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.getAttribute('data-tab');
                    
                    // Update active tab button
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    
                    // Show active tab content
                    tabContents.forEach(content => content.classList.remove('active'));
                    document.getElementById(tabId).classList.add('active');
                });
            });
            
            // Function to update the connection status in the UI
            function updateConnectionStatus(isConnected) {
                const connectionStatus = document.querySelector('.connection-status');
                const notConnectedWorkspace = document.getElementById('not-connected-workspace');
                const connectedWorkspace = document.getElementById('connected-workspace');
                const notConnectedTasks = document.getElementById('not-connected-tasks');
                const connectedTasks = document.getElementById('connected-tasks');
                const notConnectedRetryQueue = document.getElementById('not-connected-retry-queue');
                const connectedRetryQueue = document.getElementById('connected-retry-queue');
                const currentConnection = document.getElementById('current-connection');
                const settingsFormContainer = document.getElementById('settings-form-container');
                
                if (isConnected) {
                    // Update status indicator
                    connectionStatus.textContent = 'Connected';
                    connectionStatus.classList.remove('status-disconnected');
                    connectionStatus.classList.add('status-connected');
                    
                    // Update connection notice
                    document.getElementById('connection-notice').innerHTML = `
                        <p>Your Asana account is connected. You can manage synced projects in the Workspace Sync tab.</p>
                    `;
                    
                    // Show connected workspace view
                    if (notConnectedWorkspace) notConnectedWorkspace.style.display = 'none';
                    if (connectedWorkspace) connectedWorkspace.style.display = 'block';
                    
                    // Show connected tasks view
                    if (notConnectedTasks) notConnectedTasks.style.display = 'none';
                    if (connectedTasks) connectedTasks.style.display = 'block';
                    
                    // Show connected retry queue view
                    if (notConnectedRetryQueue) notConnectedRetryQueue.style.display = 'none';
                    if (connectedRetryQueue) connectedRetryQueue.style.display = 'block';
                    
                    // Show current connection settings and hide the form
                    currentConnection.style.display = 'block';
                    settingsFormContainer.style.display = 'none';
                    
                    // Load workspaces, projects, and logs
                    loadWorkspaces();
                    loadSyncLogs();
                    loadTaskViewerProjects();
                    loadTaskViewerAssignees();
                    loadTasks();
                    
                    // Initialize the retry queue system
                    initRetryQueue();
                    
                    // Don't load projects until a workspace is selected
                    const projectList = document.getElementById('project-list');
                    projectList.innerHTML = '<div class="info-box" style="text-align: center; padding: 20px; color: #666;">Please select a workspace to view its projects</div>';
                } else {
                    // Update status indicator
                    connectionStatus.textContent = 'Disconnected';
                    connectionStatus.classList.remove('status-connected');
                    connectionStatus.classList.add('status-disconnected');
                    
                    // Update connection notice
                    document.getElementById('connection-notice').innerHTML = `
                        <p>This tool allows you to synchronize tasks between Asana and JoJo's Shave Ice internal systems. Connect your Asana account to get started.</p>
                    `;
                    
                    // Show disconnected workspace view
                    if (notConnectedWorkspace) notConnectedWorkspace.style.display = 'block';
                    if (connectedWorkspace) connectedWorkspace.style.display = 'none';
                    
                    // Show disconnected tasks view
                    if (notConnectedTasks) notConnectedTasks.style.display = 'block';
                    if (connectedTasks) connectedTasks.style.display = 'none';
                    
                    // Show disconnected retry queue view
                    if (notConnectedRetryQueue) notConnectedRetryQueue.style.display = 'block';
                    if (connectedRetryQueue) connectedRetryQueue.style.display = 'none';
                    
                    // Hide current connection settings and show the form
                    currentConnection.style.display = 'none';
                    settingsFormContainer.style.display = 'block';
                }
            }
            
            // Select all projects checkbox
            const selectAllCheckbox = document.getElementById('select-all-projects');
            
            selectAllCheckbox.addEventListener('change', function() {
                const projectCheckboxes = document.querySelectorAll('.project-checkbox');
                projectCheckboxes.forEach(checkbox => {
                    checkbox.checked = selectAllCheckbox.checked;
                });
                
                // Update delete button state
                updateDeleteButtonState();
            });
            
            // Function to update the state of the delete button
            function updateDeleteButtonState() {
                const deleteButton = document.getElementById('delete-projects-btn');
                const selectedCheckboxes = document.querySelectorAll('.project-checkbox:checked');
                deleteButton.disabled = selectedCheckboxes.length === 0;
            }
            
            // Project search functionality
            const projectSearchInput = document.getElementById('project-search');
            projectSearchInput.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase().trim();
                const projectItems = document.querySelectorAll('.project-item');
                
                projectItems.forEach(item => {
                    const projectName = item.querySelector('label').textContent.toLowerCase();
                    if (searchTerm === '' || projectName.includes(searchTerm)) {
                        item.style.display = 'block';
                    } else {
                        item.style.display = 'none';
                    }
                });
            });
            
            // Delete projects button
            const deleteProjectsBtn = document.getElementById('delete-projects-btn');
            deleteProjectsBtn.addEventListener('click', function() {
                const selectedProjects = Array.from(document.querySelectorAll('.project-checkbox:checked'))
                    .map(checkbox => {
                        return {
                            id: checkbox.value,
                            name: checkbox.closest('label').textContent.trim()
                        };
                    });
                
                if (selectedProjects.length === 0) {
                    alert('Please select at least one project to delete');
                    return;
                }
                
                // Show confirmation dialog with list of projects
                const projectList = selectedProjects.map(p => `- ${p.name}`).join('\n');
                const confirmMsg = `Are you sure you want to delete these ${selectedProjects.length} projects?\n\n${projectList}\n\nThis action cannot be undone and will remove projects from your Asana account.`;
                
                if (confirm(confirmMsg)) {
                    // Show loading state
                    deleteProjectsBtn.disabled = true;
                    deleteProjectsBtn.textContent = 'Deleting...';
                    
                    // Track success/failure
                    let successCount = 0;
                    let errorCount = 0;
                    const errors = [];
                    
                    // Process each project deletion
                    const projectPromises = selectedProjects.map(project => {
                        // Remove project from database
                        return db.collection('asana_projects').doc(project.id).delete()
                            .then(() => {
                                console.log(`Project ${project.name} (${project.id}) deleted from database`);
                                successCount++;
                                
                                // Optional: Also delete related tasks
                                return db.collection('asana_tasks')
                                    .where('projectId', '==', project.id)
                                    .get()
                                    .then(snapshot => {
                                        const batch = db.batch();
                                        snapshot.forEach(doc => batch.delete(doc.ref));
                                        if (snapshot.size > 0) {
                                            return batch.commit();
                                        }
                                    });
                            })
                            .catch(error => {
                                console.error(`Error deleting project ${project.name}:`, error);
                                errorCount++;
                                errors.push(`${project.name}: ${error.message}`);
                            });
                    });
                    
                    // Wait for all projects to be processed
                    Promise.all(projectPromises)
                        .then(() => {
                            // Log the deletion
                            return db.collection('asana_sync_logs').add({
                                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                                projects: selectedProjects.map(p => p.id),
                                projectNames: selectedProjects.reduce((obj, p) => {
                                    obj[p.id] = p.name;
                                    return obj;
                                }, {}),
                                project_count: selectedProjects.length,
                                status: 'completed',
                                message: `Deleted ${successCount} projects (${errorCount} failed)`,
                                success_count: successCount,
                                error_count: errorCount,
                                errors: errors,
                                details: {
                                    action: 'delete',
                                    initiated_by: 'manual',
                                    initiated_at: firebase.firestore.FieldValue.serverTimestamp()
                                }
                            });
                        })
                        .then(() => {
                            // Reset button state
                            deleteProjectsBtn.disabled = true;
                            deleteProjectsBtn.textContent = 'Delete Selected Projects';
                            
                            // Show result message
                            if (errorCount > 0) {
                                alert(`Deleted ${successCount} projects with ${errorCount} errors. See console for details.`);
                } else {
                                alert(`Successfully deleted ${successCount} projects`);
                            }
                            
                            // Reload projects list
                            loadProjects();
                        })
                        .catch(error => {
                            console.error('Error during project deletion:', error);
                            deleteProjectsBtn.disabled = false;
                            deleteProjectsBtn.textContent = 'Delete Selected Projects';
                            alert(`Error during project deletion: ${error.message}`);
                        });
                }
            });
            
            // Add change event listeners to project checkboxes after they're loaded
            function addCheckboxEventListeners() {
                const projectCheckboxes = document.querySelectorAll('.project-checkbox');
                projectCheckboxes.forEach(checkbox => {
                    checkbox.addEventListener('change', updateDeleteButtonState);
                });
            }
            
            // Force sync button
            const forceSyncBtn = document.getElementById('force-sync-btn');
            forceSyncBtn.addEventListener('click', function() {
                const selectedProjects = Array.from(document.querySelectorAll('.project-checkbox:checked'))
                    .map(checkbox => checkbox.value);
                
                if (selectedProjects.length === 0) {
                    alert('Please select at least one project to sync');
                    return;
                }
                
                alert(`Starting sync for ${selectedProjects.length} projects...`);
                
                // Collect project names for better logging
                const projectNames = {};
                document.querySelectorAll('.project-checkbox:checked').forEach(checkbox => {
                    const projectName = checkbox.closest('label').textContent.trim();
                    projectNames[checkbox.value] = projectName;
                });
                
                // Create project stats object with initial status
                const projectStats = {};
                selectedProjects.forEach(projectId => {
                    projectStats[projectId] = {
                        status: 'started',
                        name: projectNames[projectId] || projectId,
                        start_time: firebase.firestore.FieldValue.serverTimestamp()
                    };
                });
                
                // Update last sync time in the UI
                const now = new Date();
                const formattedDate = now.toLocaleString();
                document.getElementById('last-sync-time').textContent = `Last sync: ${formattedDate}`;
                
                // Add a new log entry to the UI
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                logEntry.innerHTML = `
                    <div class="log-time">${formattedDate}</div>
                    <div class="log-message log-info">
                        <strong>Started:</strong> Started manual sync for ${selectedProjects.length} projects
                        <button class="toggle-details" style="background: none; border: none; padding: 0; font-size: 0.8rem; text-decoration: underline; cursor: pointer; color: #666;">Show details</button>
                    </div>
                    <div class="log-details" style="display: none; margin-top: 5px; font-size: 0.85rem; background-color: #f5f5f5; padding: 8px; border-radius: 4px;">
                        <h4 style="margin: 0 0 5px 0; font-size: 0.9rem;">Projects:</h4>
                        <ul style="margin: 0; padding-left: 20px;">
                            ${selectedProjects.map(projectId => `<li>${projectNames[projectId] || projectId}</li>`).join('')}
                        </ul>
                    </div>
                `;
                
                const historyLog = document.getElementById('history-log');
                historyLog.insertBefore(logEntry, historyLog.firstChild);
                
                // Add event listener to toggle details
                const toggleButton = logEntry.querySelector('.toggle-details');
                const detailsSection = logEntry.querySelector('.log-details');
                
                toggleButton.addEventListener('click', function() {
                    if (detailsSection.style.display === 'none') {
                        detailsSection.style.display = 'block';
                        toggleButton.textContent = 'Hide details';
                    } else {
                        detailsSection.style.display = 'none';
                        toggleButton.textContent = 'Show details';
                    }
                });
                
                // Update the lastSync time in Firestore
                db.collection('asana_config').doc('settings').update({
                    last_sync: firebase.firestore.FieldValue.serverTimestamp(),
                    sync_count: firebase.firestore.FieldValue.increment(1)
                })
                .then(() => {
                    console.log('Sync time updated in asana_config');
                })
                .catch((error) => {
                    console.error('Error updating sync time:', error);
                });
            
                // Add a detailed log entry to Firestore
                db.collection('asana_sync_logs').add({
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    projects: selectedProjects,
                    projectNames: projectNames,
                    project_count: selectedProjects.length,
                    status: 'started',
                    message: `Started manual sync for ${selectedProjects.length} projects`,
                    projectStats: projectStats,
                    details: {
                        initiated_by: 'manual',
                        initiated_at: firebase.firestore.FieldValue.serverTimestamp()
                    }
                })
                .then((docRef) => {
                    console.log('Sync log added to asana_sync_logs with ID:', docRef.id);
                    
                    // Simulate updating project statuses with success/error for demonstration
                    setTimeout(() => {
                        // Create updated project stats with random success/errors
                        const updatedProjectStats = {};
                        let successCount = 0;
                        let taskCount = 0;
                        
                        selectedProjects.forEach(projectId => {
                            // 80% chance of success, 20% chance of error
                            const isSuccess = Math.random() < 0.8;
                            const tasks = Math.floor(Math.random() * 20) + 1; // 1-20 tasks
                            
                            if (isSuccess) {
                                successCount++;
                                taskCount += tasks;
                                updatedProjectStats[projectId] = {
                                    status: 'success',
                                    name: projectNames[projectId] || projectId,
                                    tasks_synced: tasks,
                                    completion_time: firebase.firestore.FieldValue.serverTimestamp()
                                };
                            } else {
                                const errors = [
                                    'API rate limit exceeded',
                                    'Task not found',
                                    'Permission denied',
                                    'Network error',
                                    'Invalid resource reference'
                                ];
                                const randomError = errors[Math.floor(Math.random() * errors.length)];
                                
                                updatedProjectStats[projectId] = {
                                    status: 'error',
                                    name: projectNames[projectId] || projectId,
                                    error: randomError,
                                    completion_time: firebase.firestore.FieldValue.serverTimestamp()
                                };
                            }
                        });
                        
                        // Update the sync log with completion details
                        db.collection('asana_sync_logs').doc(docRef.id).update({
                            status: 'completed',
                            message: `Completed sync of ${selectedProjects.length} projects with ${successCount} successful`,
                            projectStats: updatedProjectStats,
                            success_count: successCount,
                            task_count: taskCount,
                            completion_time: firebase.firestore.FieldValue.serverTimestamp()
                        })
                        .then(() => {
                            console.log('Updated sync log with completion details');
                            // Reload sync logs to show the updated status
                            loadSyncLogs();
                        })
                        .catch(error => {
                            console.error('Error updating sync log:', error);
                        });
                    }, 3000); // Simulate 3 second sync process
                })
                .catch((error) => {
                    console.error('Error adding sync log:', error);
                });
            });
            
            // Function to load workspaces from Firestore
            function loadWorkspaces() {
                const workspaceSelect = document.getElementById('workspace-select');
                
                console.log('Loading workspaces from asana_workspaces collection...');
                    
                // Get workspaces directly from the asana_workspaces collection
                db.collection('asana_workspaces').get()
                    .then(snapshot => {
                        console.log(`Found ${snapshot.size} workspaces in asana_workspaces collection`);
                        
                        if (!snapshot.empty) {
                            workspaceSelect.innerHTML = '<option value="">-- Select a workspace --</option>';
                            snapshot.forEach(doc => {
                                const workspace = doc.data();
                                console.log('Workspace data:', workspace);
                                
                                // Use gid as the primary ID for workspaces
                                const gid = workspace.gid || doc.id;
                                const name = workspace.name || 'Unnamed Workspace';
                                
                                const option = document.createElement('option');
                                option.value = gid;
                                option.textContent = name;
                                workspaceSelect.appendChild(option);
                            });
                            console.log('Loaded workspaces successfully');
                        } else {
                            console.log('No workspaces found in asana_workspaces collection');
                            
                            // If no workspaces in the collection, check if we have workspace info in asana_config
                            db.collection('asana_config').doc('settings').get()
                                .then(doc => {
                                    if (doc.exists) {
                                        const data = doc.data();
                                        console.log('Checking asana_config for workspace info:', data);
                                        
                                        // Check various possible field names for workspace info
                                        const workspaceId = data.defaultWorkspaceGid || data.defaultWorkspaceId || 
                                                        data.default_workspace_gid || data.default_workspace_id;
                                        const workspaceName = data.defaultWorkspaceName || data.default_workspace_name || 'Default Workspace';
                                        
                                        if (workspaceId) {
                                            console.log(`Found workspace in asana_config: ${workspaceId} (${workspaceName})`);
                                            
                                            workspaceSelect.innerHTML = '<option value="">-- Select a workspace --</option>';
                                            const option = document.createElement('option');
                                            option.value = workspaceId;
                                            option.textContent = workspaceName;
                                            workspaceSelect.appendChild(option);
                                        } else {
                                            workspaceSelect.innerHTML = '<option value="">No workspaces available</option>';
                                        }
                                    } else {
                                        workspaceSelect.innerHTML = '<option value="">No workspaces available</option>';
                                    }
                                })
                                .catch(error => {
                                    console.error('Error checking asana_config for workspace info:', error);
                                    workspaceSelect.innerHTML = '<option value="">No workspaces available</option>';
                                });
                        }
                    })
                    .catch(error => {
                        console.error('Error loading workspaces:', error);
                        workspaceSelect.innerHTML = '<option value="">Error loading workspaces</option>';
                    });
            }
            
            // Function to load projects from Firestore
            function loadProjects() {
                const projectList = document.getElementById('project-list');
                projectList.innerHTML = '<div class="loading-indicator">Loading projects...</div>';
                
                console.log('Loading projects from asana_projects collection...');
                
                db.collection('asana_projects').get()
                    .then(snapshot => {
                        console.log(`Found ${snapshot.size} projects in asana_projects collection`);
                        
                        if (!snapshot.empty) {
                            projectList.innerHTML = '';
                            
                            snapshot.forEach(doc => {
                                const project = doc.data();
                                console.log('Project data:', project);
                                
                                // Normalize project data to handle different naming conventions
                                const normalizedProject = {
                                    id: doc.id,
                                    name: project.name,
                                    archived: project.archived || project.isArchived || false,
                                    workspace: project.workspace || project.workspaceData || {},
                                    updated_at: project.updated_at || project.updatedAt,
                                    created_at: project.created_at || project.createdAt
                                };
                                
                                // Skip archived projects
                                if (normalizedProject.archived) {
                                    return;
                                }
                                
                                const projectItem = document.createElement('div');
                                projectItem.className = 'project-item';
                                
                                // Format the last update date
                                let lastUpdate = 'Never';
                                if (normalizedProject.updated_at) {
                                    const updateDate = normalizedProject.updated_at.toDate ? 
                                        normalizedProject.updated_at.toDate() : 
                                        new Date(normalizedProject.updated_at);
                                    lastUpdate = updateDate.toLocaleDateString();
                                }
                                
                                // Add project to the list without waiting for task count
                                projectItem.innerHTML = `
                                    <label>
                                        <input type="checkbox" class="project-checkbox" value="${normalizedProject.id}">
                                        ${normalizedProject.name || 'Unnamed Project'}
                                    </label>
                                    <div class="project-stats">
                                        Last update: ${lastUpdate}
                        </div>
                    `;
                                projectList.appendChild(projectItem);
                                
                                // Get task count in the background and update later
                                db.collection('asana_tasks')
                                    .where('projectId', '==', doc.id)
                                    .get()
                                    .then(taskSnapshot => {
                                        const totalTasks = taskSnapshot.size;
                                        const completedTasks = taskSnapshot.docs.filter(d => {
                                            const taskData = d.data();
                                            return taskData.completed || taskData.isCompleted;
                                        }).length;
                                        
                                        // Update the project stats with task count
                                        const statsDiv = projectItem.querySelector('.project-stats');
                                        statsDiv.innerHTML = `
                                            Tasks: ${completedTasks}/${totalTasks} completed | Last update: ${lastUpdate}
                                        `;
                                    })
                                    .catch(error => {
                                        console.error('Error counting tasks for project ' + doc.id + ':', error);
                                    });
                            });
                            
                            console.log('Loaded projects successfully');
                            
                            // Add event listeners to project checkboxes
                            updateProjectList();
                } else {
                            projectList.innerHTML = '<div class="empty-state">No projects found. Check your Asana connection or add projects.</div>';
                        }
                    })
                    .catch(error => {
                        console.error('Error loading projects:', error);
                        projectList.innerHTML = '<div class="error-state">Error loading projects: ' + error.message + '</div>';
                    });
            }
            
            // Function to load sync logs from Firestore
            function loadSyncLogs() {
                const historyLog = document.getElementById('history-log');
                historyLog.innerHTML = '<div class="loading-indicator">Loading sync history...</div>';
                
                db.collection('asana_sync_logs')
                    .orderBy('timestamp', 'desc')
                    .limit(10)
                    .get()
                    .then(snapshot => {
                        if (!snapshot.empty) {
                            historyLog.innerHTML = '';
                            
                            snapshot.forEach(doc => {
                                const syncLog = doc.data();
                                const logEntry = document.createElement('div');
                                logEntry.className = 'log-entry';
                                
                                // Format the timestamp
                                let timeString = 'Unknown';
                                if (syncLog.timestamp) {
                                    const logDate = syncLog.timestamp.toDate ? syncLog.timestamp.toDate() : new Date(syncLog.timestamp);
                                    timeString = logDate.toLocaleString();
                                }
                                
                                // Determine status class
                                let statusClass = 'log-success';
                                let overallStatus = 'Success';
                                if (syncLog.errors && syncLog.errors.length > 0) {
                                    statusClass = 'log-error';
                                    overallStatus = 'Error';
                                } else if (syncLog.warnings && syncLog.warnings.length > 0) {
                                    statusClass = 'log-warning';
                                    overallStatus = 'Warning';
                                } else if (syncLog.status === 'error') {
                                    statusClass = 'log-error';
                                    overallStatus = 'Error';
                                } else if (syncLog.status === 'warning') {
                                    statusClass = 'log-warning';
                                    overallStatus = 'Warning';
                                } else if (syncLog.status === 'started') {
                                    statusClass = 'log-info';
                                    overallStatus = 'Started';
                                }
                                
                                // Calculate success rate if available
                                let successRate = '';
                                if (syncLog.projectStats) {
                                    const totalProjects = Object.keys(syncLog.projectStats).length;
                                    const successfulProjects = Object.values(syncLog.projectStats).filter(stat => stat.status === 'success').length;
                                    successRate = ` (${successfulProjects}/${totalProjects} projects successful, ${Math.round((successfulProjects/totalProjects)*100)}% success rate)`;
                                } else if (syncLog.success_count && syncLog.project_count) {
                                    successRate = ` (${syncLog.success_count}/${syncLog.project_count} projects successful, ${Math.round((syncLog.success_count/syncLog.project_count)*100)}% success rate)`;
                                }
                                
                                // Create message based on available data
                                let message = syncLog.message || 'Sync completed';
                                if (!syncLog.message) {
                                    if (syncLog.project_count || syncLog.projects) {
                                        const count = syncLog.project_count || (syncLog.projects ? syncLog.projects.length : 0);
                                        message = `Synced ${count} projects`;
                                    }
                                    if (syncLog.task_count) {
                                        message += `, ${syncLog.task_count} tasks`;
                                    }
                                }
                                
                                // Build the log entry header
                                let logContent = `
                                    <div class="log-time">${timeString}</div>
                                    <div class="log-message ${statusClass}">
                                        <strong>${overallStatus}:</strong> ${message}${successRate}
                                        <button class="toggle-details" style="background: none; border: none; padding: 0; font-size: 0.8rem; text-decoration: underline; cursor: pointer; color: #666;">Show details</button>
                        </div>
                                    <div class="log-details" style="display: none; margin-top: 5px; font-size: 0.85rem; background-color: #f5f5f5; padding: 8px; border-radius: 4px;">
                                `;
                                
                                // Add detailed project information if available
                                if (syncLog.projectStats) {
                                    logContent += '<h4 style="margin: 0 0 5px 0; font-size: 0.9rem;">Project Details:</h4><ul style="margin: 0; padding-left: 20px;">';
                                    
                                    Object.entries(syncLog.projectStats).forEach(([projectId, stats]) => {
                                        const projectStatus = stats.status || 'unknown';
                                        const projectStatusClass = projectStatus === 'success' ? 'log-success' : 
                                                                  projectStatus === 'error' ? 'log-error' : 'log-warning';
                                        
                                        logContent += `<li style="margin-bottom: 3px;"><span class="${projectStatusClass}" style="font-weight: bold;">${projectStatus.toUpperCase()}</span>: ${stats.name || projectId}`;
                                        
                                        if (stats.tasks_synced !== undefined) {
                                            logContent += ` (${stats.tasks_synced} tasks synced)`;
                                        }
                                        
                                        if (stats.error) {
                                            logContent += ` - Error: ${stats.error}`;
                                        }
                                        
                                        logContent += '</li>';
                                    });
                                    
                                    logContent += '</ul>';
                                } else if (syncLog.projects) {
                                    // If we only have project IDs without status
                                    logContent += '<h4 style="margin: 0 0 5px 0; font-size: 0.9rem;">Projects:</h4><ul style="margin: 0; padding-left: 20px;">';
                                    
                                    syncLog.projects.forEach(projectId => {
                                        // Try to get project name from a reference map
                                        const projectName = syncLog.projectNames && syncLog.projectNames[projectId] ? 
                                                         syncLog.projectNames[projectId] : projectId;
                                        
                                        logContent += `<li>${projectName}</li>`;
                                    });
                                    
                                    logContent += '</ul>';
                                }
                                
                                // Add errors if available
                                if (syncLog.errors && syncLog.errors.length > 0) {
                                    logContent += '<h4 style="margin: 5px 0; font-size: 0.9rem;">Errors:</h4><ul style="margin: 0; padding-left: 20px;">';
                                    
                                    syncLog.errors.forEach(error => {
                                        logContent += `<li class="log-error">${error}</li>`;
                                    });
                                    
                                    logContent += '</ul>';
                                }
                                
                                // Add warnings if available
                                if (syncLog.warnings && syncLog.warnings.length > 0) {
                                    logContent += '<h4 style="margin: 5px 0; font-size: 0.9rem;">Warnings:</h4><ul style="margin: 0; padding-left: 20px;">';
                                    
                                    syncLog.warnings.forEach(warning => {
                                        logContent += `<li class="log-warning">${warning}</li>`;
                                    });
                                    
                                    logContent += '</ul>';
                                }
                                
                                // Close the log details div
                                logContent += '</div>';
                                
                                logEntry.innerHTML = logContent;
                                historyLog.appendChild(logEntry);
                                
                                // Add event listener to toggle details
                                const toggleButton = logEntry.querySelector('.toggle-details');
                                const detailsSection = logEntry.querySelector('.log-details');
                                
                                toggleButton.addEventListener('click', function() {
                                    if (detailsSection.style.display === 'none') {
                                        detailsSection.style.display = 'block';
                                        toggleButton.textContent = 'Hide details';
                                    } else {
                                        detailsSection.style.display = 'none';
                                        toggleButton.textContent = 'Show details';
                                    }
                                });
                            });
                            
                            console.log('Loaded sync logs');
                            
                            // Update last sync time from asana_config
                            db.collection('asana_config').doc('settings').get()
                                .then(doc => {
                                    if (doc.exists && doc.data().last_sync) {
                                        const lastSync = doc.data().last_sync;
                                        const lastSyncDate = lastSync.toDate ? lastSync.toDate() : new Date(lastSync);
                                        document.getElementById('last-sync-time').textContent = `Last sync: ${lastSyncDate.toLocaleString()}`;
                                    }
                                })
                                .catch(error => {
                                    console.error('Error loading last sync time:', error);
                                });
                        } else {
                            historyLog.innerHTML = '<div class="empty-state">No sync history found</div>';
                        }
                    })
                    .catch(error => {
                        console.error('Error loading sync logs:', error);
                        historyLog.innerHTML = '<div class="error-state">Error loading sync history</div>';
                    });
            }
            
            // Check if connection is established from Firestore
            function checkConnectionStatus() {
                console.log("Checking connection status...");
                
                // First, check if the asana_config collection exists
                db.collection('asana_config').get()
                    .then(snapshot => {
                        console.log(`asana_config collection exists: ${!snapshot.empty}`);
                        console.log(`Found ${snapshot.size} documents in asana_config`);
                        
                        if (!snapshot.empty) {
                            snapshot.forEach(doc => {
                                console.log(`Document ID: ${doc.id}, data:`, doc.data());
                            });
                        }
                        
                        // Now check for the settings document specifically
                        return db.collection('asana_config').doc('settings').get();
                    })
                    .then((doc) => {
                        console.log(`Settings document exists: ${doc.exists}`);
                        if (doc.exists && (doc.data().personal_access_token || doc.data().personalAccessToken)) {
                            const data = doc.data();
                            
                            // Create a normalized data object that works with both naming conventions
                            const normalizedData = {
                                personal_access_token: data.personal_access_token || data.personalAccessToken,
                                sync_frequency: data.sync_frequency || data.syncFrequency || (data.syncFrequency === '5min' ? 5 : 60),
                                last_sync: data.last_sync || data.lastSync || data.lastFullSyncTimestamp,
                                updated_at: data.updated_at || data.updatedAt,
                                active: data.active || data.syncEnabled || true
                            };
                            
                            // Log the normalized data for debugging
                            console.log('Normalized settings data:', normalizedData);
                            
                            // Update the current connection display
                            updateConnectionDisplay(normalizedData);
                            
                            // Load saved settings into form fields (for editing)
                            document.getElementById('asana-pat').value = normalizedData.personal_access_token;
                            
                            // Set the frequency dropdown to the saved value
                            if (normalizedData.sync_frequency) {
                                const syncFrequencySelect = document.getElementById('sync-frequency');
                                const options = syncFrequencySelect.options;
                                for (let i = 0; i < options.length; i++) {
                                    if (parseInt(options[i].value) === normalizedData.sync_frequency) {
                                        syncFrequencySelect.selectedIndex = i;
                                        break;
                                    }
                                }
                            }
                            
                            console.log('Loaded existing settings from asana_config');
                            updateConnectionStatus(true);
                            
                            // Initialize auto-sync
                            afterConnectionEstablished();
                        } else if (doc.exists) {
                            // Check if token exists under different field names
                            const data = doc.data();
                            console.log('Checking for alternative token field names in:', data);
                            
                            if (data.pat || data.token || data.asanaToken || data.asana_token) {
                                // Found token with different field name, update to standard format
                                const token = data.pat || data.token || data.asanaToken || data.asana_token;
                                console.log(`Found token with alternative field name: ${token.substring(0, 4)}...`);
                                
                                // Update to standard format
                                const newData = {
                                    personal_access_token: token,
                                    sync_frequency: data.sync_frequency || data.syncFrequency || 60,
                                    updated_at: firebase.firestore.FieldValue.serverTimestamp(),
                                    active: true
                                };
                                
                                db.collection('asana_config').doc('settings').set(newData, { merge: true })
                                    .then(() => {
                                        console.log('Updated token field name to standard format');
                                        // Reload with new settings
                                        checkConnectionStatus();
                                    })
                                    .catch(error => {
                                        console.error('Error updating token field name:', error);
                                        tryLocalStorageBackup();
                                    });
                } else {
                                console.log('No valid settings found with any token field names');
                                
                                // Check if there's an "asana_config" document at the root level for legacy data
                                db.collection('asana_config').doc('asana_config').get()
                                    .then(legacyDoc => {
                                        if (legacyDoc.exists && legacyDoc.data().settings && legacyDoc.data().settings.pat) {
                                            console.log('Found legacy settings structure:', legacyDoc.data());
                                            
                                            // Migrate legacy data to new format
                                            const legacyData = legacyDoc.data();
                                            const newData = {
                                                personal_access_token: legacyData.settings.pat,
                                                sync_frequency: legacyData.settings.sync_frequency || 60,
                                                updated_at: firebase.firestore.FieldValue.serverTimestamp(),
                                                active: true
                                            };
                                            
                                            // Update to new format
                                            db.collection('asana_config').doc('settings').set(newData)
                                                .then(() => {
                                                    console.log('Migrated legacy settings to new format');
                                                    // Reload to use the new settings
                                                    checkConnectionStatus();
                                                })
                                                .catch(error => {
                                                    console.error('Error migrating settings:', error);
                                                    tryLocalStorageBackup();
                                                });
                                        } else {
                                            tryLocalStorageBackup();
                                        }
                                    })
                                    .catch(error => {
                                        console.error('Error checking legacy asana_config:', error);
                                        tryLocalStorageBackup();
                                    });
                            }
                        } else {
                            // No settings document exists, try localStorage backup
                            tryLocalStorageBackup();
                        }
                    })
                    .catch((error) => {
                        console.error('Error checking connection status:', error);
                        tryLocalStorageBackup();
                    });
                
                // Try to recover from localStorage if Firestore fails
                function tryLocalStorageBackup() {
                    try {
                        const savedSettings = localStorage.getItem('asana_settings');
                        if (savedSettings) {
                            const localSettings = JSON.parse(savedSettings);
                            console.log('Found settings in localStorage:', localSettings);
                            
                            if (localSettings.personal_access_token) {
                                console.log('Restoring connection from localStorage backup');
                                
                                // Create normalized data from localStorage
                                const normalizedData = {
                                    personal_access_token: localSettings.personal_access_token,
                                    sync_frequency: localSettings.sync_frequency || 60,
                                    active: true
                                };
                                
                                // Update UI with backup data
                                updateConnectionDisplay(normalizedData);
                                document.getElementById('asana-pat').value = normalizedData.personal_access_token;
                                
                                // Set frequency dropdown
                                if (normalizedData.sync_frequency) {
                                    const syncFrequencySelect = document.getElementById('sync-frequency');
                                    const options = syncFrequencySelect.options;
                                    for (let i = 0; i < options.length; i++) {
                                        if (parseInt(options[i].value) === normalizedData.sync_frequency) {
                                            syncFrequencySelect.selectedIndex = i;
                                            break;
                                        }
                                    }
                                }
                                
                                // Also restore to Firestore for future use
                                db.collection('asana_config').doc('settings').set({
                                    personal_access_token: localSettings.personal_access_token,
                                    sync_frequency: localSettings.sync_frequency || 60,
                                    updated_at: firebase.firestore.FieldValue.serverTimestamp(),
                                    active: true,
                                    restored_from_local: true
                                }, { merge: true })
                                .then(() => {
                                    console.log('Restored settings from localStorage to Firestore');
                                })
                                .catch(err => {
                                    console.error('Error restoring settings to Firestore:', err);
                                });
                                
                                updateConnectionStatus(true);
                                afterConnectionEstablished();
                                return;
                            }
                        }
                        
                        // If we get here, there was no backup or it didn't have a token
                        updateConnectionStatus(false);
                    } catch (e) {
                        console.error('Error trying localStorage backup:', e);
                        updateConnectionStatus(false);
                    }
                }
            }

            // Function to update the current connection display
            function updateConnectionDisplay(data) {
                // Display partial token (first 4 chars + last 4 chars, rest are hidden)
                const token = data.personal_access_token;
                let tokenDisplay = '';
                if (token && token.length > 8) {
                    tokenDisplay = token.substring(0, 4) + '••••••••••••••••' + token.substring(token.length - 4);
                } else if (token) {
                    tokenDisplay = token.substring(0, 2) + '••••••';
                }
                document.getElementById('current-token').textContent = tokenDisplay;
                
                // Display sync frequency in human-readable format
                let frequencyDisplay = 'Every hour';
                if (data.sync_frequency) {
                    let freq = data.sync_frequency;
                    
                    // Handle string values like '5min'
                    if (typeof freq === 'string') {
                        if (freq === '5min') freq = 5;
                        else if (freq === '15min') freq = 15;
                        else if (freq === '30min') freq = 30;
                        else if (freq === '1hour') freq = 60;
                        else if (freq === '6hours') freq = 360;
                        else if (freq === '12hours') freq = 720;
                        else if (freq === '1day') freq = 1440;
                        else freq = parseInt(freq) || 60;
                    }
                    
                    // Convert to number to ensure correct comparison
                    freq = parseInt(freq);
                    
                    if (freq === 5) frequencyDisplay = 'Every 5 minutes';
                    else if (freq === 15) frequencyDisplay = 'Every 15 minutes';
                    else if (freq === 30) frequencyDisplay = 'Every 30 minutes';
                    else if (freq === 60) frequencyDisplay = 'Every hour';
                    else if (freq === 360) frequencyDisplay = 'Every 6 hours';
                    else if (freq === 720) frequencyDisplay = 'Every 12 hours';
                    else if (freq === 1440) frequencyDisplay = 'Once a day';
                    else frequencyDisplay = `Every ${freq} minutes`;
                }
                document.getElementById('current-frequency').textContent = frequencyDisplay;
                
                // Display last sync time
                let lastSyncDisplay = 'Never';
                if (data.last_sync) {
                    const lastSync = data.last_sync.toDate ? data.last_sync.toDate() : new Date(data.last_sync);
                    lastSyncDisplay = lastSync.toLocaleString();
                }
                document.getElementById('current-last-sync').textContent = lastSyncDisplay;
            }
            
            // Called when DOM is loaded - add all event listeners and initialization
            checkConnectionStatus();
            
            // Edit settings button
            document.getElementById('edit-settings').addEventListener('click', function() {
                document.getElementById('current-connection').style.display = 'none';
                document.getElementById('settings-form-container').style.display = 'block';
                document.getElementById('cancel-edit').style.display = 'inline-block';
            });
            
            // Clear settings button
            document.getElementById('clear-settings').addEventListener('click', function() {
                if (confirm('Are you sure you want to clear all connection settings? This will disconnect your Asana integration.')) {
                    document.getElementById('asana-pat').value = '';
                    document.getElementById('sync-frequency').value = '60';
                    document.getElementById('current-connection').style.display = 'none';
                    document.getElementById('settings-form-container').style.display = 'block';
                    
                    // Clear settings in Firestore
                    db.collection('asana_config').doc('settings').update({
                        personal_access_token: firebase.firestore.FieldValue.delete(),
                        active: false,
                        updated_at: firebase.firestore.FieldValue.serverTimestamp()
                    })
                    .then(() => {
                        console.log('Connection settings cleared');
                        
                        // Also clear localStorage backup
                        try {
                            localStorage.removeItem('asana_settings');
                            console.log('LocalStorage backup also cleared');
                        } catch (e) {
                            console.error('Error clearing localStorage:', e);
                        }
                        
                        alert('Connection settings cleared successfully');
                        updateConnectionStatus(false);
                    })
                    .catch((error) => {
                        console.error('Error clearing settings:', error);
                        alert(`Error clearing settings: ${error.message}`);
                    });
                }
            });
            
            // Cancel edit button
            document.getElementById('cancel-edit').addEventListener('click', function() {
                document.getElementById('current-connection').style.display = 'block';
                document.getElementById('settings-form-container').style.display = 'none';
                document.getElementById('cancel-edit').style.display = 'none';
                
                // Reset form to current values
                checkConnectionStatus();
            });
            
            // Add event listener for workspace selection
            document.getElementById('workspace-select').addEventListener('change', function() {
                const workspaceId = this.value;
                const workspaceName = this.options[this.selectedIndex].text;
                
                console.log(`Selected workspace: ${workspaceName} (${workspaceId})`);
                
                const projectList = document.getElementById('project-list');
                
                if (workspaceId) {
                    // If a workspace is selected, filter projects by this workspace
                    loadProjectsByWorkspace(workspaceId);
                } else {
                    // If no workspace is selected, show message prompting to select a workspace
                    projectList.innerHTML = '<div class="info-box" style="text-align: center; padding: 20px; color: #666;">Please select a workspace to view its projects</div>';
                    
                    // Reset delete button and search
                    document.getElementById('delete-projects-btn').disabled = true;
                    document.getElementById('project-search').value = '';
                }
            });
            
            // Function to load projects filtered by workspace
            function loadProjectsByWorkspace(workspaceId) {
                const projectList = document.getElementById('project-list');
                projectList.innerHTML = '<div class="loading-indicator">Loading projects for workspace...</div>';
                
                console.log(`Loading projects for workspace GID ${workspaceId}...`);
                
                // Direct query using the correct field name workspaceGid
                db.collection('asana_projects')
                    .where('workspaceGid', '==', workspaceId)
                    .get()
                    .then(snapshot => {
                        console.log(`Direct query found ${snapshot.size} projects for workspace ${workspaceId} using workspaceGid field`);
                        
                        if (!snapshot.empty) {
                            projectList.innerHTML = '';
                            
                            snapshot.forEach(doc => {
                                const project = doc.data();
                                console.log('Project data:', project);
                                
                                // Skip archived projects if needed
                                if (project.archived === true) {
                    return;
                }
                
                                const projectItem = document.createElement('div');
                                projectItem.className = 'project-item';
                                
                                // Format the last update date
                                let lastUpdate = 'Never';
                                if (project.updated_at) {
                                    const updateDate = project.updated_at.toDate ? 
                                        project.updated_at.toDate() : 
                                        new Date(project.updated_at);
                                    lastUpdate = updateDate.toLocaleDateString();
                                }
                                
                                // Add project to the list without waiting for task count
                                projectItem.innerHTML = `
                                    <label>
                                        <input type="checkbox" class="project-checkbox" value="${doc.id}">
                                        ${project.name || 'Unnamed Project'}
                                    </label>
                                    <div class="project-stats">
                                        Last update: ${lastUpdate}
                    </div>
                `;
                                projectList.appendChild(projectItem);
                                
                                // Get task count in the background and update later
                                db.collection('asana_tasks')
                                    .where('projectId', '==', doc.id)
                                    .get()
                                    .then(taskSnapshot => {
                                        const totalTasks = taskSnapshot.size;
                                        const completedTasks = taskSnapshot.docs.filter(d => {
                                            const taskData = d.data();
                                            return taskData.completed === true;
                                        }).length;
                                        
                                        // Update the project stats with task count
                                        const statsDiv = projectItem.querySelector('.project-stats');
                                        statsDiv.innerHTML = `
                                            Tasks: ${completedTasks}/${totalTasks} completed | Last update: ${lastUpdate}
                                        `;
                                    })
                                    .catch(error => {
                                        console.error('Error counting tasks for project ' + doc.id + ':', error);
                                    });
                            });
                            
                            // Call updateProjectList after projects are loaded
                            updateProjectList();
                        } else {
                            console.log("No projects found with workspaceGid, showing example of first few projects:");
                            
                            // Show examples of the actual data structure
                            db.collection('asana_projects').limit(3).get()
                                .then(sampleSnapshot => {
                                    if (!sampleSnapshot.empty) {
                                        console.log("Sample project data structure:");
                                        sampleSnapshot.forEach(doc => {
                                            console.log("Project:", doc.data());
                                        });
                                    }
                                    
                                    projectList.innerHTML = '<div class="empty-state">No projects found for this workspace.</div>';
                                })
                                .catch(error => {
                                    projectList.innerHTML = '<div class="empty-state">No projects found for this workspace.</div>';
                                });
                        }
                    })
                    .catch(error => {
                        console.error('Error loading projects by workspace:', error);
                        projectList.innerHTML = '<div class="error-state">Error loading projects: ' + error.message + '</div>';
                    });
            }
            
            // Load more log entries
            document.getElementById('load-more-logs').addEventListener('click', function() {
                const historyLog = document.getElementById('history-log');
                const logEntries = historyLog.querySelectorAll('.log-entry');
                const lastEntry = logEntries[logEntries.length - 1];
                
                if (lastEntry) {
                    // Get the timestamp of the last entry
                    const timeString = lastEntry.querySelector('.log-time').textContent;
                    const lastTime = new Date(timeString);
                    
                    // Load more logs older than this timestamp
                    db.collection('asana_sync_logs')
                    .orderBy('timestamp', 'desc')
                        .startAfter(firebase.firestore.Timestamp.fromDate(lastTime))
                    .limit(10)
                        .get()
                        .then(snapshot => {
                            if (!snapshot.empty) {
                                snapshot.forEach(doc => {
                                    const syncLog = doc.data();
                                    const logEntry = document.createElement('div');
                                    logEntry.className = 'log-entry';
                                    
                                    // Format the timestamp
                                    let timeString = 'Unknown';
                                    if (syncLog.timestamp) {
                                        const logDate = syncLog.timestamp.toDate ? syncLog.timestamp.toDate() : new Date(syncLog.timestamp);
                                        timeString = logDate.toLocaleString();
                                    }
                                    
                                    // Determine status class
                                    let statusClass = 'log-success';
                                    let overallStatus = 'Success';
                                    if (syncLog.errors && syncLog.errors.length > 0) {
                                        statusClass = 'log-error';
                                        overallStatus = 'Error';
                                    } else if (syncLog.warnings && syncLog.warnings.length > 0) {
                                        statusClass = 'log-warning';
                                        overallStatus = 'Warning';
                                    } else if (syncLog.status === 'error') {
                                        statusClass = 'log-error';
                                        overallStatus = 'Error';
                                    } else if (syncLog.status === 'warning') {
                                        statusClass = 'log-warning';
                                        overallStatus = 'Warning';
                                    } else if (syncLog.status === 'started') {
                                        statusClass = 'log-info';
                                        overallStatus = 'Started';
                                    }
                                    
                                    // Calculate success rate if available
                                    let successRate = '';
                                    if (syncLog.projectStats) {
                                        const totalProjects = Object.keys(syncLog.projectStats).length;
                                        const successfulProjects = Object.values(syncLog.projectStats).filter(stat => stat.status === 'success').length;
                                        successRate = ` (${successfulProjects}/${totalProjects} projects successful, ${Math.round((successfulProjects/totalProjects)*100)}% success rate)`;
                                    } else if (syncLog.success_count && syncLog.project_count) {
                                        successRate = ` (${syncLog.success_count}/${syncLog.project_count} projects successful, ${Math.round((syncLog.success_count/syncLog.project_count)*100)}% success rate)`;
                                    }
                                    
                                    // Create message based on available data
                                    let message = syncLog.message || 'Sync completed';
                                    if (!syncLog.message) {
                                        if (syncLog.project_count || syncLog.projects) {
                                            const count = syncLog.project_count || (syncLog.projects ? syncLog.projects.length : 0);
                                            message = `Synced ${count} projects`;
                                        }
                                        if (syncLog.task_count) {
                                            message += `, ${syncLog.task_count} tasks`;
                                        }
                                    }
                                    
                                    // Build the log entry header
                                    let logContent = `
                                        <div class="log-time">${timeString}</div>
                                        <div class="log-message ${statusClass}">
                                            <strong>${overallStatus}:</strong> ${message}${successRate}
                                            <button class="toggle-details" style="background: none; border: none; padding: 0; font-size: 0.8rem; text-decoration: underline; cursor: pointer; color: #666;">Show details</button>
                        </div>
                                        <div class="log-details" style="display: none; margin-top: 5px; font-size: 0.85rem; background-color: #f5f5f5; padding: 8px; border-radius: 4px;">
                                    `;
                                    
                                    // Add detailed project information if available
                                    if (syncLog.projectStats) {
                                        logContent += '<h4 style="margin: 0 0 5px 0; font-size: 0.9rem;">Project Details:</h4><ul style="margin: 0; padding-left: 20px;">';
                                        
                                        Object.entries(syncLog.projectStats).forEach(([projectId, stats]) => {
                                            const projectStatus = stats.status || 'unknown';
                                            const projectStatusClass = projectStatus === 'success' ? 'log-success' : 
                                                                      projectStatus === 'error' ? 'log-error' : 'log-warning';
                                            
                                            logContent += `<li style="margin-bottom: 3px;"><span class="${projectStatusClass}" style="font-weight: bold;">${projectStatus.toUpperCase()}</span>: ${stats.name || projectId}`;
                                            
                                            if (stats.tasks_synced !== undefined) {
                                                logContent += ` (${stats.tasks_synced} tasks synced)`;
                                            }
                                            
                                            if (stats.error) {
                                                logContent += ` - Error: ${stats.error}`;
                                            }
                                            
                                            logContent += '</li>';
                                        });
                                        
                                        logContent += '</ul>';
                                    } else if (syncLog.projects) {
                                        // If we only have project IDs without status
                                        logContent += '<h4 style="margin: 0 0 5px 0; font-size: 0.9rem;">Projects:</h4><ul style="margin: 0; padding-left: 20px;">';
                                        
                                        syncLog.projects.forEach(projectId => {
                                            // Try to get project name from a reference map
                                            const projectName = syncLog.projectNames && syncLog.projectNames[projectId] ? 
                                                             syncLog.projectNames[projectId] : projectId;
                                            
                                            logContent += `<li>${projectName}</li>`;
                                        });
                                        
                                        logContent += '</ul>';
                                    }
                                    
                                    // Add errors if available
                                    if (syncLog.errors && syncLog.errors.length > 0) {
                                        logContent += '<h4 style="margin: 5px 0; font-size: 0.9rem;">Errors:</h4><ul style="margin: 0; padding-left: 20px;">';
                                        
                                        syncLog.errors.forEach(error => {
                                            logContent += `<li class="log-error">${error}</li>`;
                                        });
                                        
                                        logContent += '</ul>';
                                    }
                                    
                                    // Add warnings if available
                                    if (syncLog.warnings && syncLog.warnings.length > 0) {
                                        logContent += '<h4 style="margin: 5px 0; font-size: 0.9rem;">Warnings:</h4><ul style="margin: 0; padding-left: 20px;">';
                                        
                                        syncLog.warnings.forEach(warning => {
                                            logContent += `<li class="log-warning">${warning}</li>`;
                                        });
                                        
                                        logContent += '</ul>';
                                    }
                                    
                                    // Close the log details div
                                    logContent += '</div>';
                                    
                                    logEntry.innerHTML = logContent;
                                    historyLog.appendChild(logEntry);
                                    
                                    // Add event listener to toggle details
                                    const toggleButton = logEntry.querySelector('.toggle-details');
                                    const detailsSection = logEntry.querySelector('.log-details');
                                    
                                    toggleButton.addEventListener('click', function() {
                                        if (detailsSection.style.display === 'none') {
                                            detailsSection.style.display = 'block';
                                            toggleButton.textContent = 'Hide details';
                                        } else {
                                            detailsSection.style.display = 'none';
                                            toggleButton.textContent = 'Show details';
                                        }
                                    });
                                });
                                
                                console.log('Loaded more sync logs');
                } else {
                                alert('No more sync logs to load');
                            }
                        })
                        .catch(error => {
                            console.error('Error loading more sync logs:', error);
                            alert('Error loading more logs');
                        });
                } else {
                    loadSyncLogs(); // If there are no entries, just reload
                }
            });
            
            // Function to load projects for the task viewer filter
            function loadTaskViewerProjects() {
                const projectFilter = document.getElementById('filter-project');
                
                // Clear existing options except the first one
                while (projectFilter.options.length > 1) {
                    projectFilter.remove(1);
                }
                
                db.collection('asana_projects')
                    .where('archived', '==', false)
                    .orderBy('name')
                    .get()
                    .then(snapshot => {
                        if (!snapshot.empty) {
                            snapshot.forEach(doc => {
                                const project = doc.data();
                                const option = document.createElement('option');
                                option.value = doc.id;
                                option.textContent = project.name || 'Unnamed Project';
                                projectFilter.appendChild(option);
                            });
                            
                            console.log('Loaded task viewer projects');
                        } else {
                            console.log('No projects found for task viewer filter');
                        }
                    })
                    .catch(error => {
                        console.error('Error loading task viewer projects:', error);
                    });
            }
            
            // Function to load assignees for the task viewer filter
            function loadTaskViewerAssignees() {
                const assigneeFilter = document.getElementById('filter-assignee');
                
                // Clear existing options except the first one
                while (assigneeFilter.options.length > 1) {
                    assigneeFilter.remove(1);
                }
                
                // Get unique assignees from tasks
                const assignees = new Set();
                
                db.collection('asana_tasks')
                    .limit(500) // Limit to prevent loading too many tasks
                    .get()
                    .then(snapshot => {
                        if (!snapshot.empty) {
                            snapshot.forEach(doc => {
                                const task = doc.data();
                                if (task.assignee && task.assignee_name) {
                                    assignees.add(JSON.stringify({
                                        id: task.assignee.id || task.assignee.gid || task.assignee,
                                        name: task.assignee_name
                                    }));
                                }
                            });
                            
                            // Convert assignees to array and sort by name
                            const assigneeArray = Array.from(assignees)
                                .map(json => JSON.parse(json))
                                .sort((a, b) => a.name.localeCompare(b.name));
                            
                            // Add assignee options
                            assigneeArray.forEach(assignee => {
                                const option = document.createElement('option');
                                option.value = assignee.id;
                                option.textContent = assignee.name;
                                assigneeFilter.appendChild(option);
                            });
                            
                            console.log('Loaded task viewer assignees');
                        } else {
                            console.log('No tasks found for assignee filter');
                        }
                    })
                    .catch(error => {
                        console.error('Error loading task viewer assignees:', error);
                    });
            }
            
            // Function to load tasks with applied filters
            function loadTasks(startAfter = null) {
                const taskList = document.getElementById('task-list');
                
                // Show loading indicator if this is the first page
                if (!startAfter) {
                    taskList.innerHTML = '<div class="loading-indicator">Loading tasks...</div>';
                }
                
                // Get filter values
                const projectId = document.getElementById('filter-project').value;
                const statusValue = document.getElementById('filter-status').value;
                const assigneeId = document.getElementById('filter-assignee').value;
                
                // Start building the query
                let query = db.collection('asana_tasks');
                
                // Apply filters if they are set
                if (projectId) {
                    query = query.where('projectId', '==', projectId);
                }
                
                if (statusValue === 'true' || statusValue === 'false') {
                    query = query.where('completed', '==', statusValue === 'true');
                }
                
                if (assigneeId) {
                    query = query.where('assignee.id', '==', assigneeId);
                }
                
                // Order by name to ensure consistent order
                query = query.orderBy('name');
                
                // Apply pagination if startAfter is provided
                if (startAfter) {
                    query = query.startAfter(startAfter);
                }
                
                // Limit the number of tasks
                query = query.limit(20);
                
                // Execute the query
                query.get()
                    .then(snapshot => {
                        // Remove loading indicator if this is the first page
                        if (!startAfter) {
                            taskList.innerHTML = '';
                        }
                        
                        if (!snapshot.empty) {
                            // Store the last document for pagination
                            window.lastVisibleTask = snapshot.docs[snapshot.docs.length - 1];
                            
                            snapshot.forEach(doc => {
                                const task = doc.data();
                                const taskItem = document.createElement('div');
                                taskItem.className = 'task-item';
                                taskItem.setAttribute('data-task-id', doc.id);
                                
                                // Format due date if available
                                let dueDate = 'No due date';
                                if (task.due_on) {
                                    dueDate = new Date(task.due_on).toLocaleDateString();
                                }
                                
                                taskItem.innerHTML = `
                                    <div class="task-title">${task.name || 'Untitled Task'}</div>
                                    <div class="task-details">
                                        <p>Project: ${task.project_name || 'Unknown'} | Assigned to: ${task.assignee_name || 'Unassigned'} | Due: ${dueDate}</p>
                                        <p>Status: ${task.completed ? 'Completed' : 'Not Started'}</p>
                    </div>
                `;
                
                                taskList.appendChild(taskItem);
                                
                                // Add click event to view task details
                                taskItem.addEventListener('click', function() {
                                    const taskId = this.getAttribute('data-task-id');
                                    openTaskModal(taskId);
                                });
                            });
                            
                            console.log('Loaded tasks');
                        } else if (!startAfter) {
                            // Only show "no tasks" message if this is the first page
                            taskList.innerHTML = '<div class="empty-state">No tasks found matching the selected filters</div>';
                } else {
                            alert('No more tasks to load');
                        }
                    })
                    .catch(error => {
                        console.error('Error loading tasks:', error);
                        
                        if (!startAfter) {
                            // Only show error message if this is the first page
                            taskList.innerHTML = '<div class="error-state">Error loading tasks</div>';
                        } else {
                            alert('Error loading more tasks');
                        }
                    });
            }
            
            // Add event listener for apply filters button
            document.getElementById('apply-filters').addEventListener('click', function() {
                // Reset pagination
                window.lastVisibleTask = null;
                
                // Load tasks with new filters
                loadTasks();
            });
            
            // Add event listener for reset filters button
            document.getElementById('reset-filters').addEventListener('click', function() {
                document.getElementById('filter-project').value = '';
                document.getElementById('filter-status').value = '';
                document.getElementById('filter-assignee').value = '';
                
                // Reset pagination
                window.lastVisibleTask = null;
                
                // Load tasks with new filters
                loadTasks();
            });
            
            // Update load more tasks button
            document.getElementById('load-more-tasks').addEventListener('click', function() {
                if (window.lastVisibleTask) {
                    loadTasks(window.lastVisibleTask);
                } else {
                    loadTasks();
                }
            });
            
            // Settings form submission
            document.getElementById('settings-form').addEventListener('submit', function(e) {
            e.preventDefault();
            
                const pat = document.getElementById('asana-pat').value;
                const syncFrequency = document.getElementById('sync-frequency').value;
                
                if (!pat) {
                    alert('Please enter your Asana Personal Access Token');
                    return;
                }
                
                // First, check if a settings document already exists to determine the naming convention
                db.collection('asana_config').doc('settings').get()
                    .then(doc => {
                        const data = doc.exists ? doc.data() : {};
                        const usesCamelCase = doc.exists && (data.personalAccessToken !== undefined || data.syncFrequency !== undefined);
                        
                        // Create settings object using the appropriate naming convention
                        let settingsData = {};
                        
                        if (usesCamelCase) {
                            console.log('Using camelCase naming convention');
                            settingsData = {
                                personalAccessToken: pat,
                                syncFrequency: parseInt(syncFrequency),
                                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                                syncEnabled: true
                            };
                        } else {
                            console.log('Using snake_case naming convention');
                            settingsData = {
                                personal_access_token: pat,
                                sync_frequency: parseInt(syncFrequency),
                                updated_at: firebase.firestore.FieldValue.serverTimestamp(),
                                active: true
                            };
                        }
                        
                        // Also save to localStorage as backup
                        try {
                            localStorage.setItem('asana_settings', JSON.stringify({
                                personal_access_token: pat,
                                sync_frequency: parseInt(syncFrequency),
                                timestamp: new Date().toISOString()
                            }));
                            console.log('Settings saved to localStorage as backup');
                        } catch (e) {
                            console.error('Error saving to localStorage:', e);
                        }
                        
                        // Save settings to Firestore using the correct collection and document structure
                        return db.collection('asana_config').doc('settings').set(settingsData, { merge: true });
                    })
                    .then(() => {
                        console.log('Settings saved successfully to asana_config!');
                        alert('Settings saved successfully!');
                        
                        // Hide the cancel button after successful save
                        document.getElementById('cancel-edit').style.display = 'none';
                        
                        // Reload connection status to refresh the UI with new settings
                        setTimeout(() => {
                            checkConnectionStatus();
                        }, 500);
                    })
                    .catch((error) => {
                        console.error('Error saving settings:', error);
                        alert(`Error saving settings: ${error.message}. Please try again.`);
                    });
            });
            
            // Test connection button
            document.getElementById('test-connection').addEventListener('click', function() {
                const pat = document.getElementById('asana-pat').value;
                
                if (!pat) {
                    alert('Please enter your Asana Personal Access Token');
                return;
            }
            
                alert('Testing connection to Asana...');
                console.log("Testing connection with PAT: " + pat.substring(0, 4) + "...");
                
                // For demo purposes, simulate a successful connection
                setTimeout(() => {
                    // Test connection success
                    db.collection('asana_sync_logs').add({
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        type: 'connection_test',
                        status: 'success',
                        message: 'Connection test successful'
                    })
                    .then(() => {
                        console.log('Connection test logged successfully');
                        alert('Connection successful!');
                        updateConnectionStatus(true);
                    })
                    .catch((error) => {
                        console.error('Error logging connection test:', error);
                        alert(`Error during connection test: ${error.message}. Please try again.`);
                    });
                }, 1000);
            });
            
            // Open task detail modal when clicking on a task
            const taskItems = document.querySelectorAll('.task-item');
            const taskModal = document.getElementById('task-modal');
            const closeBtn = document.querySelector('.close-btn');
            
            taskItems.forEach(task => {
                task.addEventListener('click', function() {
                    const taskId = this.getAttribute('data-task-id');
                    openTaskModal(taskId);
                });
            });
            
            closeBtn.addEventListener('click', function() {
                taskModal.style.display = 'none';
            });
            
            window.addEventListener('click', function(e) {
                if (e.target === taskModal) {
                    taskModal.style.display = 'none';
                }
            });
            
            // Open task detail modal
            function openTaskModal(taskId) {
                const taskModal = document.getElementById('task-modal');
                const taskModalBody = document.getElementById('task-modal-body');
                
                // Try to load task from Firestore first
                db.collection('asana_tasks').doc(taskId).get()
                    .then(doc => {
                        if (doc.exists) {
                            const taskData = doc.data();
                            console.log('Task data:', taskData);
                            
                            // If we have a projectId, try to get the project name
                            if (taskData.projectId || taskData.projectGid) {
                                const projectId = taskData.projectGid || taskData.projectId;
                                
                                // Try to get project details
                                db.collection('asana_projects').doc(projectId).get()
                                    .then(projectDoc => {
                                        if (projectDoc.exists) {
                                            const projectData = projectDoc.data();
                                            taskData.project_name = projectData.name || 'Unknown Project';
                                        } else {
                                            console.log(`Project not found for ID: ${projectId}`);
                                            taskData.project_name = `Project ID: ${projectId}`;
                                        }
                                        displayTaskDetails(taskData);
                                    })
                                    .catch(error => {
                                        console.error('Error loading project:', error);
                                        taskData.project_name = `Project ID: ${projectId}`;
                                        displayTaskDetails(taskData);
                                    });
                            } else {
                                taskData.project_name = 'Unknown Project';
                                displayTaskDetails(taskData);
                            }
                        } else {
                            // Fallback to static data if not found
                            const taskData = {
                                name: 'Task details not found',
                                notes: 'No additional information available for this task.',
                                assignee_name: 'Unknown',
                                due_on: 'Unknown',
                                completed: false,
                                project_name: 'Unknown Project',
                                created_at: 'Unknown',
                                priority: 'Unknown',
                                sections: [],
                                tags: []
                            };
                            displayTaskDetails(taskData);
                        }
                    })
                    .catch(error => {
                        console.error('Error loading task:', error);
                        // Fallback to basic display
                        const taskData = {
                            name: 'Error loading task',
                            notes: 'There was an error loading the task details.',
                            assignee_name: 'Unknown',
                            due_on: 'Unknown',
                            completed: false,
                            project_name: 'Unknown Project',
                            created_at: 'Unknown',
                            priority: 'Unknown',
                            sections: [],
                            tags: []
                        };
                        displayTaskDetails(taskData);
                    });
                    
                function displayTaskDetails(taskData) {
                    // Generate HTML for task details based on available data
                    let taskDetailsHTML = `
                        <div class="task-property">
                            <div class="property-name">Title</div>
                            <div>${taskData.name || taskData.title || 'Untitled'}</div>
                                </div>
                        <div class="task-property">
                            <div class="property-name">Description</div>
                            <div>${taskData.notes || taskData.description || 'No description'}</div>
                            </div>
                        <div class="task-property">
                            <div class="property-name">Project</div>
                            <div>${taskData.project_name || 'Unknown Project'}</div>
                        </div>
                        <div class="task-property">
                            <div class="property-name">Assignee</div>
                            <div>${taskData.assignee_name || taskData.assignee || 'Unassigned'}</div>
                                </div>
                        <div class="task-property">
                            <div class="property-name">Due Date</div>
                            <div>${taskData.due_on || taskData.dueDate || 'No due date'}</div>
                            </div>
                        <div class="task-property">
                            <div class="property-name">Status</div>
                            <div>${taskData.completed ? 'Completed' : 'Not Started'}</div>
                        </div>
                    `;
                    
                    if (taskData.priority) {
                        taskDetailsHTML += `
                            <div class="task-property">
                                <div class="property-name">Priority</div>
                                <div>${taskData.priority}</div>
                                </div>
                        `;
                    }
                    
                    if (taskData.created_at || taskData.createdAt) {
                        taskDetailsHTML += `
                            <div class="task-property">
                                <div class="property-name">Created</div>
                                <div>${taskData.created_at || taskData.createdAt}</div>
                            </div>
                        `;
                    }
                    
                    if (taskData.sections && taskData.sections.length > 0) {
                        taskDetailsHTML += `
                            <div class="task-property">
                                <div class="property-name">Sections</div>
                                <div>${taskData.sections.join(', ')}</div>
                    </div>
                `;
                    }
                    
                    if (taskData.tags && taskData.tags.length > 0) {
                        taskDetailsHTML += `
                            <div class="task-property">
                                <div class="property-name">Tags</div>
                                <div>${taskData.tags.join(', ')}</div>
                    </div>
                `;
                    }
                    
                    // Set modal title and content
                    document.querySelector('.modal-title').textContent = taskData.name || taskData.title || 'Task Details';
                    taskModalBody.innerHTML = taskDetailsHTML;
                    
                    // Show the modal
                    taskModal.style.display = 'block';
                }
            }
            
            // Debug functionality
            document.getElementById('debug-show-data').addEventListener('click', function() {
                const debugOutput = document.getElementById('debug-output');
                debugOutput.innerHTML = 'Loading database data...';
                
                // Check all relevant collections
                const collections = ['asana_config', 'asana_workspaces', 'asana_projects'];
                let output = '';
                
                Promise.all(collections.map(collection => 
                    db.collection(collection).get()
                        .then(snapshot => {
                            output += `<strong>${collection}</strong> (${snapshot.size} docs):<br>`;
                            
                            if (snapshot.empty) {
                                output += '- No documents found<br>';
                } else {
                                snapshot.forEach(doc => {
                                    const data = doc.data();
                                    output += `- ${doc.id}: ${JSON.stringify(data).substring(0, 150)}...<br>`;
                                });
                            }
                            
                            output += '<br>';
                        })
                        .catch(error => {
                            output += `Error getting ${collection}: ${error}<br>`;
                        })
                ))
                .then(() => {
                    debugOutput.innerHTML = output;
                    console.log('Debug data loaded');
                })
                .catch(error => {
                    debugOutput.innerHTML += `<br>Error: ${error}`;
                    console.error('Debug error:', error);
                });
            });
            
            document.getElementById('debug-create-settings').addEventListener('click', function() {
                const debugOutput = document.getElementById('debug-output');
                debugOutput.innerHTML = 'Creating sample settings...';
                
                // Create sample settings document
                const sampleSettings = {
                    personal_access_token: '1/1234567890abcdefghijklmn',
                    sync_frequency: 60,
                    updated_at: firebase.firestore.FieldValue.serverTimestamp(),
                    active: true,
                    last_sync: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                db.collection('asana_config').doc('settings').set(sampleSettings)
                    .then(() => {
                        debugOutput.innerHTML += '<br>Sample settings created successfully!';
                        console.log('Sample settings created');
                        
                        // Reload connection status to see the changes
                        setTimeout(() => {
                            checkConnectionStatus();
                        }, 500);
                    })
                    .catch(error => {
                        debugOutput.innerHTML += `<br>Error creating sample settings: ${error}`;
                        console.error('Error creating sample settings:', error);
                    });
            });
            
            document.getElementById('debug-create-projects').addEventListener('click', function() {
                const debugOutput = document.getElementById('debug-output');
                debugOutput.innerHTML = 'Creating sample projects...';
                
                // First, check if we need a workspace
                db.collection('asana_workspaces').get()
                    .then(snapshot => {
                        let workspaceGid = '1197204311639010'; // Default workspace GID
                        let workspaceName = 'JoJo\'s Shave Ice';
                        
                        if (!snapshot.empty) {
                            // Use the first workspace if available
                            const workspaceDoc = snapshot.docs[0];
                            const workspace = workspaceDoc.data();
                            workspaceGid = workspace.gid || workspaceDoc.id;
                            workspaceName = workspace.name || 'Workspace';
                            debugOutput.innerHTML += `<br>Using existing workspace: ${workspaceName} (GID: ${workspaceGid})`;
                        } else {
                            // Create a sample workspace
                            debugOutput.innerHTML += `<br>Creating sample workspace: ${workspaceName} (GID: ${workspaceGid})`;
                            db.collection('asana_workspaces').doc(workspaceGid).set({
                                name: workspaceName,
                                gid: workspaceGid,
                                created_at: firebase.firestore.FieldValue.serverTimestamp()
                            });
                        }
                        
                        // Create some sample projects
                        const sampleProjects = [
                            {
                                name: 'Inventory Management',
                                gid: '1201234567890123',
                                workspaceGid: workspaceGid,
                                workspaceName: workspaceName,
                                archived: false,
                                created_at: firebase.firestore.FieldValue.serverTimestamp(),
                                updated_at: firebase.firestore.FieldValue.serverTimestamp()
                            },
                            {
                                name: 'Weekly Tasks',
                                gid: '1201234567890124',
                                workspaceGid: workspaceGid,
                                workspaceName: workspaceName,
                                archived: false,
                                created_at: firebase.firestore.FieldValue.serverTimestamp(),
                                updated_at: firebase.firestore.FieldValue.serverTimestamp()
                            },
                            {
                                name: 'Marketing Campaigns',
                                gid: '1201234567890125',
                                workspaceGid: workspaceGid,
                                workspaceName: workspaceName,
                                archived: false,
                                created_at: firebase.firestore.FieldValue.serverTimestamp(),
                                updated_at: firebase.firestore.FieldValue.serverTimestamp()
                            }
                        ];
                        
                        // Create each project
                        const projectPromises = sampleProjects.map(project => 
                            db.collection('asana_projects').doc(project.gid).set(project)
                        );
                        
                        return Promise.all(projectPromises);
                    })
                    .then(() => {
                        debugOutput.innerHTML += '<br>Sample projects created successfully!';
                        console.log('Sample projects created');
                        
                        // Reload projects to see the changes
                        setTimeout(() => {
                            loadWorkspaces();
                            loadProjects();
                        }, 500);
                    })
                    .catch(error => {
                        debugOutput.innerHTML += `<br>Error creating sample projects: ${error}`;
                        console.error('Error creating sample projects:', error);
                    });
            });
            
            document.getElementById('debug-clear-logs').addEventListener('click', function() {
                console.clear();
                document.getElementById('debug-output').innerHTML = 'Console cleared';
            });
            
            // Call addCheckboxEventListeners when the project list is first loaded
            function updateProjectList() {
                // Reset delete button
                document.getElementById('delete-projects-btn').disabled = true;
                
                // Clear search input
                document.getElementById('project-search').value = '';
                
                // Add event listeners to checkboxes
                addCheckboxEventListeners();
            }
            
            // Sync Statistics Modal functionality
            const syncStatsModal = document.getElementById('sync-stats-modal');
            const closeStatsBtns = syncStatsModal.querySelectorAll('.close-btn');
            let syncStatsChart = null;
            let selectedProjects = []; // Store selected project IDs
            let drillDownState = null; // Track drill-down state
            
            // Open the sync statistics modal
            document.getElementById('view-sync-stats-btn').addEventListener('click', function() {
                // Make sure we have a canvas element to draw on
                const modalBody = document.getElementById('sync-stats-modal-body');
                const graphContainer = document.getElementById('sync-stats-graph');
                
                // If the graph container isn't a canvas (might have been replaced with a div), recreate it
                if (graphContainer && graphContainer.tagName !== 'CANVAS') {
                    // Remove the existing element
                    modalBody.removeChild(graphContainer);
                    
                    // Create a new canvas
                    const canvas = document.createElement('canvas');
                    canvas.id = 'sync-stats-graph';
                    canvas.style.width = '100%';
                    canvas.style.height = '400px';
                    
                    // Insert the canvas in the right location (before the summary div)
                    const summaryDiv = document.getElementById('sync-stats-summary');
                    modalBody.insertBefore(canvas, summaryDiv);
                }
                
                // Reset drill-down state
                drillDownState = null;
                document.getElementById('drill-up-btn').style.display = 'none';
                
                // Show the modal
                syncStatsModal.style.display = 'block';
                
                // Load the statistics
                loadSyncStatistics();
            });
            
            // Close the modal when clicking the close button or outside the modal
            closeStatsBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    syncStatsModal.style.display = 'none';
                });
            });
            
            window.addEventListener('click', function(e) {
                if (e.target === syncStatsModal) {
                    syncStatsModal.style.display = 'none';
                }
            });
            
            // Project multi-select filter functionality
            const projectFilterContainer = document.querySelector('.selected-projects-display');
            const projectFilterDropdown = document.getElementById('project-filter-dropdown');
            
            // Toggle dropdown when clicking on the display box
            projectFilterContainer.addEventListener('click', function() {
                projectFilterDropdown.style.display = projectFilterDropdown.style.display === 'none' ? 'block' : 'none';
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!projectFilterContainer.contains(e.target) && !projectFilterDropdown.contains(e.target)) {
                    projectFilterDropdown.style.display = 'none';
                }
            });
            
            // Handle select all checkbox
            document.getElementById('select-all-projects-filter').addEventListener('change', function() {
                const projectCheckboxes = document.querySelectorAll('.project-filter-checkbox');
                projectCheckboxes.forEach(checkbox => {
                    checkbox.checked = this.checked;
                });
                
                // Update selected projects text
                updateSelectedProjectsText();
            });
            
            // Apply filter button
            document.getElementById('apply-stats-filters').addEventListener('click', function() {
                // Gather selected projects
                selectedProjects = Array.from(document.querySelectorAll('.project-filter-checkbox:checked'))
                    .map(checkbox => checkbox.value);
                
                // Close the dropdown
                projectFilterDropdown.style.display = 'none';
                
                // Update selected projects text
                updateSelectedProjectsText();
                
                // Reset drill-down state
                drillDownState = null;
                document.getElementById('drill-up-btn').style.display = 'none';
                
                // Reload statistics with new filters
                loadSyncStatistics();
            });
            
            // Reset filter button
            document.getElementById('reset-stats-filters').addEventListener('click', function() {
                // Uncheck all project checkboxes
                document.querySelectorAll('.project-filter-checkbox').forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                // Reset selected projects
                selectedProjects = [];
                
                // Update text
                updateSelectedProjectsText();
                
                // Reset drill-down state
                drillDownState = null;
                document.getElementById('drill-up-btn').style.display = 'none';
                
                // Close the dropdown
                projectFilterDropdown.style.display = 'none';
                
                // Reload statistics
                loadSyncStatistics();
            });
            
            // Drill up button
            document.getElementById('drill-up-btn').addEventListener('click', function() {
                drillDownState = null;
                this.style.display = 'none';
                loadSyncStatistics();
            });
            
            // Update selected projects text display
            function updateSelectedProjectsText() {
                const selectedCount = selectedProjects.length;
                const textElement = document.getElementById('selected-projects-text');
                
                if (selectedCount === 0) {
                    textElement.textContent = 'All Projects';
                } else {
                    textElement.textContent = `${selectedCount} project${selectedCount > 1 ? 's' : ''} selected`;
                }
            }
            
            // Populate project filter with all projects from database
            function populateProjectFilter() {
                console.log('Populating project filter from asana_projects collection');
                
                // Query all projects
                db.collection('asana_projects')
                    .orderBy('name')
                    .get()
                    .then(snapshot => {
                        if (snapshot.empty) {
                            console.log('No projects found in asana_projects collection');
                            return;
                        }
                        
                        const projectFilterList = document.getElementById('project-filter-list');
                        projectFilterList.innerHTML = ''; // Clear existing options
                        
                        // Add options from direct query
                        const projects = [];
                        snapshot.forEach(doc => {
                            const project = doc.data();
                            const projectName = project.name || `Project ${doc.id}`;
                            
                            projects.push({
                                id: doc.id,
                                name: projectName
                            });
                        });
                        
                        // Sort by name
                        projects.sort((a, b) => a.name.localeCompare(b.name));
                        
                        // Add to filter list
                        projects.forEach(project => {
                            const checkboxContainer = document.createElement('div');
                            checkboxContainer.style.padding = '4px 8px';
                            checkboxContainer.style.marginBottom = '2px';
                            checkboxContainer.style.cursor = 'pointer';
                            checkboxContainer.style.transition = 'background-color 0.2s';
                            
                            const label = document.createElement('label');
                            label.style.margin = '0';
                            label.style.width = '100%';
                            label.style.cursor = 'pointer';
                            
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.className = 'project-filter-checkbox';
                            checkbox.value = project.id;
                            checkbox.style.marginRight = '8px';
                            checkbox.checked = selectedProjects.includes(project.id);
                            
                            // Add event listener to update the text display on individual checkbox change
                            checkbox.addEventListener('change', function() {
                                updateSelectedProjectsText();
                            });
                            
                            label.appendChild(checkbox);
                            label.appendChild(document.createTextNode(project.name));
                            
                            checkboxContainer.appendChild(label);
                            projectFilterList.appendChild(checkboxContainer);
                            
                            // Add hover effect
                            checkboxContainer.addEventListener('mouseover', function() {
                                this.style.backgroundColor = '#f0f0f0';
                            });
                            
                            checkboxContainer.addEventListener('mouseout', function() {
                                this.style.backgroundColor = 'transparent';
                            });
                        });
                        
                        console.log(`Added ${projects.length} projects to filter list`);
                    })
                    .catch(error => {
                        console.error('Error querying projects:', error);
                    });
            }
            
            // Load and display sync statistics
            function loadSyncStatistics() {
                try {
                    const days = parseInt(document.getElementById('stats-date-range').value) || 7;
                    const displayMode = document.getElementById('display-mode')?.value || 'count';
                    
                    console.log('Loading sync statistics with params:', { days, displayMode, selectedProjects });
                    
                    // Calculate date range
                    const endDate = new Date();
                    const startDate = new Date();
                    startDate.setDate(startDate.getDate() - days);
                    
                    console.log(`Date range: ${startDate.toISOString()} to ${endDate.toISOString()}`);
                    console.log(`Using project filters: ${selectedProjects.length > 0 ? selectedProjects.join(', ') : 'All Projects'}`);
                    
                    // Create stats controls if they don't exist
                    ensureStatsControlsExist();
                    
                    // If we're in a drill-down view, handle that specially
                    if (drillDownState) {
                        console.log('In drill-down state:', drillDownState);
                        
                        if (drillDownState.type === 'day') {
                            if (!drillDownState.date) {
                                console.error('Missing date in drillDownState', drillDownState);
                                displayErrorMessage(new Error('Invalid drill-down state: missing date'));
                                return;
                            }
                            loadDayDetails(drillDownState.date, selectedProjects);
                            return;
                        } else if (drillDownState.type === 'project') {
                            if (!drillDownState.projectId) {
                                console.error('Missing projectId in drillDownState', drillDownState);
                                displayErrorMessage(new Error('Invalid drill-down state: missing projectId'));
                                return;
                            }
                            loadProjectDetails(drillDownState.projectId, days);
                            return;
                        } else if (drillDownState.type === 'error') {
                            if (!drillDownState.errorType) {
                                console.error('Missing errorType in drillDownState', drillDownState);
                                displayErrorMessage(new Error('Invalid drill-down state: missing errorType'));
                                return;
                            }
                            loadErrorDetails(drillDownState.errorType, days, selectedProjects);
                            return;
                        }
                    }
                    
                    // Always make sure project filter is populated with all projects
                    populateProjectFilter();
                    
                    // Check auto-sync status and update UI
                    checkAutoSyncStatus();
                    
                    // Query the sync logs within the date range
                    let query = db.collection('asana_sync_logs')
                        .where('timestamp', '>=', firebase.firestore.Timestamp.fromDate(startDate))
                        .where('timestamp', '<=', firebase.firestore.Timestamp.fromDate(endDate))
                        .orderBy('timestamp', 'asc');
                    
                    query.get()
                        .then(snapshot => {
                            if (snapshot.empty) {
                                console.log('No sync logs found for the selected period');
                                displayNoDataMessage();
                                return;
                            }
                            
                            // Process the sync logs
                            const logs = [];
                            snapshot.forEach(doc => {
                                const log = doc.data();
                                if (log.timestamp) {
                                    logs.push({
                                        id: doc.id,
                                        ...log,
                                        date: log.timestamp.toDate()
                                    });
                                }
                            });
                            
                            console.log(`Found ${logs.length} sync logs`);
                            
                            // Filter logs by selected projects if needed
                            let filteredLogs = logs;
                            if (selectedProjects.length > 0) {
                                filteredLogs = logs.filter(log => {
                                    // Check if any selected projects are included in this log
                                    for (const projectId of selectedProjects) {
                                        // Check in projects array (GID should be the ID)
                                        if (log.projects && log.projects.includes(projectId)) {
                                            return true;
                                        }
                                        
                                        // Check in projectStats object (GID is the key)
                                        if (log.projectStats && log.projectStats[projectId]) {
                                            return true;
                                        }
                                    }
                                    return false;
                                });
                                console.log(`Filtered to ${filteredLogs.length} logs for selected projects`);
                            }
                            
                            if (filteredLogs.length === 0) {
                                displayNoDataMessage();
                                return;
                            }
                            
                            // Group logs by day
                            const logsByDay = {};
                            const labels = [];
                            const currentDate = new Date(startDate);
                            
                            // Initialize all days in the range
                            while (currentDate <= endDate) {
                                const dateKey = currentDate.toISOString().split('T')[0];
                                labels.push(moment(dateKey).format('MMM D'));
                                logsByDay[dateKey] = {
                                    date: new Date(currentDate),
                                    logs: [],
                                    successCount: 0,
                                    totalCount: 0,
                                    errorCount: 0,
                                    errorTypes: {}, // Track different error types
                                    projectSuccessCount: 0,
                                    projectTotalCount: 0,
                                    initiatedBy: {
                                        manual: 0,
                                        auto: 0,
                                        unknown: 0
                                    },
                                    dateKey: dateKey
                                };
                                currentDate.setDate(currentDate.getDate() + 1);
                            }
                            
                            console.log(`Initialized ${Object.keys(logsByDay).length} day slots for data`);
                            
                            // Populate with actual logs
                            filteredLogs.forEach(log => {
                                try {
                                    const dateKey = log.date.toISOString().split('T')[0];
                                    if (logsByDay[dateKey]) {
                                        logsByDay[dateKey].logs.push(log);
                                        
                                        // Track who initiated the sync (manual, auto, or unknown)
                                        let initiator = 'unknown';
                                        if (log.details && log.details.initiated_by) {
                                            initiator = log.details.initiated_by;
                                        }
                                        logsByDay[dateKey].initiatedBy[initiator]++;
                                        
                                        // For multi-select projects, we need to count only the selected projects
                                        if (selectedProjects.length > 0) {
                                            // Count only selected projects' stats
                                            let daySuccessCount = 0;
                                            let dayTotalCount = 0;
                                            let dayErrorCount = 0;
                                            
                                            selectedProjects.forEach(projectId => {
                                                if (log.projectStats && log.projectStats[projectId]) {
                                                    const stat = log.projectStats[projectId];
                                                    dayTotalCount++;
                                                    if (stat.status === 'success') {
                                                        daySuccessCount++;
                                                    } else if (stat.error) {
                                                        dayErrorCount++;
                                                        
                                                        // Track error types for breakdown
                                                        const errorType = getErrorType(stat.error);
                                                        logsByDay[dateKey].errorTypes[errorType] = (logsByDay[dateKey].errorTypes[errorType] || 0) + 1;
                                                    }
                                                }
                                            });
                                            
                                            logsByDay[dateKey].successCount += daySuccessCount;
                                            logsByDay[dateKey].totalCount += dayTotalCount;
                                            logsByDay[dateKey].errorCount += dayErrorCount;
                                        } else {
                                            // Count all projects
                                            if (log.success_count !== undefined && log.project_count !== undefined) {
                                                logsByDay[dateKey].successCount += log.success_count;
                                                logsByDay[dateKey].totalCount += log.project_count;
                                            }
                                            
                                            // Count errors and track error types
                                            try {
                                                if (log.errors && Array.isArray(log.errors)) {
                                                    logsByDay[dateKey].errorCount += log.errors.length;
                                                    
                                                    // Track each error type
                                                    log.errors.forEach(error => {
                                                        const errorType = getErrorType(error);
                                                        logsByDay[dateKey].errorTypes[errorType] = (logsByDay[dateKey].errorTypes[errorType] || 0) + 1;
                                                    });
                                                }
                                                
                                                // Also count project-specific errors
                                                if (log.projectStats) {
                                                    Object.values(log.projectStats).forEach(stat => {
                                                        if (stat.error) {
                                                            logsByDay[dateKey].errorCount++;
                                                            
                                                            // Track error type
                                                            const errorType = getErrorType(stat.error);
                                                            logsByDay[dateKey].errorTypes[errorType] = (logsByDay[dateKey].errorTypes[errorType] || 0) + 1;
                                                        }
                                                    });
                                                }
                                            } catch (e) {
                                                console.error('Error counting errors:', e);
                                            }
                                        }
                                    } else {
                                        console.warn(`Date key ${dateKey} not found in logsByDay`);
                                    }
                                } catch (e) {
                                    console.error('Error processing log:', e, log);
                                }
                            });
                            
                            // Convert logsByDay to array for the chart
                            const logsByDayArray = Object.values(logsByDay);
                            console.log(`Prepared ${logsByDayArray.length} data points for chart`);
                            
                            // Prepare data for chart - always show stacked data
                            let chartData;
                            let chartTitle;
                            let isPercentage = displayMode === 'percentage';
                            
                            // Get all error types
                            const allErrorTypes = new Set();
                            logsByDayArray.forEach(day => {
                                Object.keys(day.errorTypes).forEach(type => allErrorTypes.add(type));
                            });
                            
                            // Sort error types alphabetically for consistency
                            const sortedErrorTypes = Array.from(allErrorTypes).sort();
                            window.errorTypes = sortedErrorTypes;
                            console.log('Error types:', sortedErrorTypes);
                            
                            if (sortedErrorTypes.length > 0) {
                                // We have error types, show a full breakdown
                                chartTitle = isPercentage ? 
                                    'Sync Status Distribution (%)' : 
                                    'Sync Status Breakdown';
                                
                                // Create data arrays - first for success, then each error type
                                const successData = logsByDayArray.map(day => {
                                    const successCount = day.successCount;
                                    return isPercentage && day.totalCount > 0 ? 
                                        Math.round((successCount / day.totalCount) * 100) : 
                                        successCount;
                                });
                                
                                // Create array for error types
                                const errorDataSets = sortedErrorTypes.map(errorType => {
                                    return logsByDayArray.map(day => {
                                        const errorCount = day.errorTypes[errorType] || 0;
                                        return isPercentage && day.totalCount > 0 ? 
                                            Math.round((errorCount / day.totalCount) * 100) : 
                                            errorCount;
                                    });
                                });
                                
                                // Combine for full stacked chart [success, error1, error2, ...]
                                chartData = [successData, ...errorDataSets];
                                
                                // Add dataset labels
                                window.datasetLabels = ['Success', ...sortedErrorTypes];
                            } else {
                                // No error types found, show simple success/failure
                                chartTitle = isPercentage ? 
                                    'Success Rate (%)' : 
                                    'Success vs Failure';
                                
                                // Create success and failure data
                                const successData = logsByDayArray.map(day => {
                                    const successCount = day.successCount;
                                    return isPercentage && day.totalCount > 0 ? 
                                        Math.round((successCount / day.totalCount) * 100) : 
                                        successCount;
                                });
                                
                                const failureData = logsByDayArray.map(day => {
                                    const failureCount = day.totalCount - day.successCount;
                                    return isPercentage && day.totalCount > 0 ? 
                                        Math.round((failureCount / day.totalCount) * 100) : 
                                        failureCount;
                                });
                                
                                chartData = [successData, failureData];
                                
                                // Add dataset labels
                                window.datasetLabels = ['Success', 'Failure'];
                            }
                            
                            console.log('Chart data prepared:', {
                                title: chartTitle,
                                isPercentage: isPercentage,
                                datasets: window.datasetLabels
                            });
                            
                            // Create or update chart
                            createStackedChart(labels, chartData, chartTitle, isPercentage, logsByDayArray);
                            
                            // Update summary statistics including auto-sync counts
                            updateSummaryStats(logs, filteredLogs);
                        })
                        .catch(error => {
                            console.error('Error loading sync statistics:', error);
                            displayErrorMessage(error);
                        });
                } catch (error) {
                    console.error('Error in loadSyncStatistics:', error);
                    displayErrorMessage(error);
                }
            }
            
            // Ensure stats controls exists and are properly configured
            function ensureStatsControlsExist() {
                let statsControls = document.querySelector('.stats-controls');
                
                if (!statsControls) {
                    console.log('Creating stats controls container');
                    const modalBody = document.getElementById('sync-stats-modal-body');
                    
                    // Create container
                    statsControls = document.createElement('div');
                    statsControls.className = 'stats-controls';
                    statsControls.innerHTML = statsControlsHTML;
                    
                    // Insert at the beginning of modal body
                    if (modalBody) {
                        const firstChild = modalBody.firstChild;
                        modalBody.insertBefore(statsControls, firstChild);
                        
                        // Add event listeners
                        const applyButton = document.getElementById('apply-stats-filters');
                        if (applyButton) {
                            applyButton.addEventListener('click', loadSyncStatistics);
                        }
                        
                        const resetButton = document.getElementById('reset-stats-filters');
                        if (resetButton) {
                            resetButton.addEventListener('click', function() {
                                document.querySelectorAll('.project-filter-checkbox').forEach(checkbox => {
                                    checkbox.checked = false;
                                });
                                selectedProjects = [];
                                updateSelectedProjectsText();
                                loadSyncStatistics();
                            });
                        }
                        
                        const drillUpButton = document.getElementById('drill-up-btn');
                        if (drillUpButton) {
                            drillUpButton.addEventListener('click', function() {
                                drillDownState = null;
                                this.style.display = 'none';
                                loadSyncStatistics();
                            });
                        }
                        
                        const dateRangeSelect = document.getElementById('stats-date-range');
                        if (dateRangeSelect) {
                            dateRangeSelect.addEventListener('change', loadSyncStatistics);
                        }
                        
                        const displayModeSelect = document.getElementById('display-mode');
                        if (displayModeSelect) {
                            displayModeSelect.addEventListener('change', loadSyncStatistics);
                        }
                    }
                }
                
                // Check for auto-sync UI elements
                const autoSyncIndicator = document.getElementById('auto-sync-indicator');
                if (!autoSyncIndicator) {
                    console.warn('Auto-sync indicator not found, controls may not be properly initialized');
                }
            }
            
            // Check auto-sync status and update the UI
            function checkAutoSyncStatus() {
                const statusElement = document.getElementById('auto-sync-status');
                const indicatorElement = document.getElementById('auto-sync-indicator');
                
                if (!statusElement || !indicatorElement) {
                    console.warn('Auto-sync status elements not found');
                    return;
                }
                
                db.collection('asana_config').doc('settings').get()
                    .then(doc => {
                        if (doc.exists) {
                            const data = doc.data();
                            let isActive = data.active || data.syncEnabled;
                            
                            let syncFrequencyMinutes = 60; // Default to hourly
                            
                            // Get frequency from various possible field names
                            if (data.sync_frequency) {
                                syncFrequencyMinutes = parseInt(data.sync_frequency);
                            } else if (data.syncFrequency) {
                                syncFrequencyMinutes = parseInt(data.syncFrequency);
                            }
                            
                            if (isActive) {
                                let lastSyncText = 'Never';
                                let nextSyncText = 'Unknown';
                                
                                if (data.last_sync) {
                                    const lastSync = data.last_sync.toDate ? data.last_sync.toDate() : new Date(data.last_sync);
                                    lastSyncText = lastSync.toLocaleString();
                                    
                                    // Calculate next sync
                                    const nextSync = new Date(lastSync);
                                    nextSync.setMinutes(nextSync.getMinutes() + syncFrequencyMinutes);
                                    nextSyncText = nextSync.toLocaleString();
                                }
                                
                                statusElement.textContent = 'Active';
                                indicatorElement.style.backgroundColor = '#e2f2e2';
                                indicatorElement.style.color = '#28a745';
                                indicatorElement.title = `Last sync: ${lastSyncText}\nNext sync: ${nextSyncText}\nFrequency: ${syncFrequencyMinutes} minutes`;
                            } else {
                                statusElement.textContent = 'Disabled';
                                indicatorElement.style.backgroundColor = '#f8d7da';
                                indicatorElement.style.color = '#dc3545';
                            }
                        } else {
                            statusElement.textContent = 'Not Configured';
                            indicatorElement.style.backgroundColor = '#fff3cd';
                            indicatorElement.style.color = '#856404';
                        }
                    })
                    .catch(error => {
                        console.error('Error checking auto-sync status:', error);
                        statusElement.textContent = 'Error';
                        indicatorElement.style.backgroundColor = '#f8d7da';
                        indicatorElement.style.color = '#dc3545';
                    });
                
                // Also query recent auto-sync logs to verify
                const oneWeekAgo = new Date();
                oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
                
                db.collection('asana_sync_logs')
                    .where('timestamp', '>=', firebase.firestore.Timestamp.fromDate(oneWeekAgo))
                    .orderBy('timestamp', 'desc')
                    .limit(10)
                    .get()
                    .then(snapshot => {
                        if (!snapshot.empty) {
                            let autoSyncCount = 0;
                            let manualSyncCount = 0;
                            
                            snapshot.forEach(doc => {
                                const log = doc.data();
                                if (log.details && log.details.initiated_by === 'auto') {
                                    autoSyncCount++;
                                } else if (log.details && log.details.initiated_by === 'manual') {
                                    manualSyncCount++;
                                }
                            });
                            
                            // Update UI with counts
                            if (autoSyncCount > 0) {
                                statusElement.textContent = `Active (${autoSyncCount} recent)`;
                            }
                            
                            console.log(`Recent syncs: ${autoSyncCount} auto, ${manualSyncCount} manual`);
                        }
                    })
                    .catch(error => {
                        console.error('Error checking recent auto-sync logs:', error);
                    });
            }
            
            // Create stacked chart with custom configuration
            function createStackedChart(labels, data, title, isPercentage, dataSets) {
                try {
                    console.log('Creating stacked chart with:', {
                        labelCount: labels ? labels.length : 0,
                        datasetCount: data ? data.length : 0,
                        isPercentage: isPercentage
                    });
                    
                    // Define colors for datasets
                    const successColor = 'rgba(40, 167, 69, 0.7)';
                    const failureColor = 'rgba(220, 53, 69, 0.7)';
                    const errorColors = [
                        'rgba(220, 53, 69, 0.7)',    // Red
                        'rgba(255, 127, 80, 0.7)',   // Coral
                        'rgba(255, 165, 0, 0.7)',    // Orange
                        'rgba(255, 99, 71, 0.7)',    // Tomato
                        'rgba(178, 34, 34, 0.7)',    // Firebrick
                        'rgba(139, 0, 0, 0.7)',      // DarkRed
                        'rgba(165, 42, 42, 0.7)',    // Brown
                        'rgba(128, 0, 0, 0.7)'       // Maroon
                    ];
                    
                    // Safety checks for required parameters
                    if (!labels || !data) {
                        console.error('Missing required parameters for createStackedChart');
                        return;
                    }
                    
                    // Store date keys in a dedicated array linked to chart positions
                    window.chartDateKeys = [];
                    labels.forEach((label, index) => {
                        if (dataSets && index < dataSets.length && dataSets[index] && dataSets[index].dateKey) {
                            window.chartDateKeys[index] = dataSets[index].dateKey;
                } else {
                            window.chartDateKeys[index] = null;
                        }
                    });
                    
                    const graphElement = document.getElementById('sync-stats-graph');
                    if (!graphElement) {
                        console.error('Graph element not found');
                        return;
                    }
                    
                    const ctx = graphElement.getContext('2d');
                    if (!ctx) {
                        console.error('Could not get 2D context from canvas');
                        return;
                    }
                    
                    // Destroy previous chart if it exists
                    if (syncStatsChart) {
                        syncStatsChart.destroy();
                    }
                    
                    // Create datasets with appropriate colors
                    const datasets = data.map((dataArray, index) => {
                        let color;
                        if (index === 0) {
                            // First dataset is always success
                            color = successColor;
                        } else if (data.length === 2 && index === 1) {
                            // Simple success/failure case
                            color = failureColor;
                        } else {
                            // Error type breakdown
                            color = errorColors[(index - 1) % errorColors.length];
                        }
                        
                        return {
                            label: window.datasetLabels && window.datasetLabels[index] ? 
                                window.datasetLabels[index] : (index === 0 ? 'Success' : `Dataset ${index}`),
                            data: dataArray,
                            backgroundColor: color,
                            borderColor: color.replace('0.7', '1'),
                            borderWidth: 1
                        };
                    });
                    
                    // Create new chart
                    syncStatsChart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    stacked: true,
                                    title: {
                                        display: true,
                                        text: isPercentage ? 'Percentage (%)' : 'Count'
                                    },
                                    ticks: {
                                        callback: function(value) {
                                            return isPercentage ? value + '%' : value;
                                        }
                                    },
                                    // For percentage mode, fix the scale to 0-100
                                    ...(isPercentage ? { 
                                        min: 0, 
                                        max: 100,
                                        grid: {
                                            color: (context) => {
                                                return context.tick.value === 100 || 
                                                       context.tick.value === 0 ? 
                                                       'rgba(0,0,0,0.1)' : 'rgba(0,0,0,0.05)';
                                            }
                                        }
                                    } : {})
                                },
                                x: {
                                    stacked: true,
                                    title: {
                                        display: true,
                                        text: 'Date'
                                    }
                                }
                            },
                            plugins: {
                                tooltip: {
                                    callbacks: {
                                        // Enhanced tooltip for stacked data
                                        afterTitle: function(context) {
                                            if (dataSets && context[0].dataIndex < dataSets.length) {
                                                const dayData = dataSets[context[0].dataIndex];
                                                if (dayData) {
                                                    // Show sync types in tooltip
                                                    return `Auto: ${dayData.initiatedBy.auto}, Manual: ${dayData.initiatedBy.manual}`;
                                                }
                                            }
                                            return '';
                                        },
                                        afterLabel: function(context) {
                                            const datasetIndex = context.datasetIndex;
                                            const index = context.dataIndex;
                                            
                                            if (dataSets && index < dataSets.length) {
                                                const dayData = dataSets[index];
                                                
                                                // For success dataset (first one), show totals
                                                if (datasetIndex === 0) {
                                                    if (isPercentage) {
                                                        return `Actual: ${dayData.successCount}/${dayData.totalCount}`;
                                                    } else if (dayData.totalCount > 0) {
                                                        return `Success rate: ${Math.round((dayData.successCount / dayData.totalCount) * 100)}%`;
                                                    }
                                                }
                                            }
                                            return '';
                                        }
                                    }
                                },
                                legend: {
                                    position: 'top',
                                    labels: {
                                        boxWidth: 15,
                                        padding: 10
                                    }
                                }
                            },
                            onClick: handleChartClick // Use a separate function for chart clicks
                        }
                    });
            } catch (error) {
                    console.error('Error creating stacked chart:', error);
                    displayErrorMessage(error);
                }
            }
            
            // Update summary statistics to include auto-sync info
            function updateSummaryStats(allLogs, filteredLogs) {
                // Total syncs
                document.getElementById('stat-total-syncs').textContent = filteredLogs.length;
                
                // Average success rate
                let totalSuccess = 0;
                let totalProjects = 0;
                let autoSyncCount = 0;
                let manualSyncCount = 0;
                
                filteredLogs.forEach(log => {
                    // Track sync initiation type
                    if (log.details && log.details.initiated_by === 'auto') {
                        autoSyncCount++;
                    } else if (log.details && log.details.initiated_by === 'manual') {
                        manualSyncCount++;
                    }
                    
                    // Track success counts
                    if (log.success_count !== undefined && log.project_count !== undefined) {
                        totalSuccess += log.success_count;
                        totalProjects += log.project_count;
                    }
                });
                
                const avgSuccessRate = totalProjects === 0 ? 0 : Math.round((totalSuccess / totalProjects) * 100);
                document.getElementById('stat-avg-success-rate').textContent = `${avgSuccessRate}%`;
                
                // Add auto-sync info to summary if available
                const syncCountElement = document.getElementById('stat-total-syncs');
                if (autoSyncCount > 0 || manualSyncCount > 0) {
                    syncCountElement.innerHTML = `${filteredLogs.length} <span style="font-size: 0.8rem; color: #6c757d;">(${autoSyncCount} auto, ${manualSyncCount} manual)</span>`;
                }
                
                // Most common error
                const errorCounts = {};
                
                filteredLogs.forEach(log => {
                    try {
                        // Handle array of errors
                        if (log.errors && Array.isArray(log.errors)) {
                            log.errors.forEach(error => {
                                // Make sure error is a string
                                const errorStr = String(error);
                                const errorType = errorStr.includes(':') ? 
                                    errorStr.split(':')[0].trim() : errorStr.trim();
                                errorCounts[errorType] = (errorCounts[errorType] || 0) + 1;
                            });
                        }
                        
                        // Also check projectStats for errors
                        if (log.projectStats) {
                            Object.values(log.projectStats).forEach(stat => {
                                if (stat.error) {
                                    // Make sure error is a string
                                    const errorStr = String(stat.error);
                                    const errorType = errorStr.includes(':') ? 
                                        errorStr.split(':')[0].trim() : errorStr.trim();
                                    errorCounts[errorType] = (errorCounts[errorType] || 0) + 1;
                                }
                            });
                        }
                    } catch (e) {
                        console.error('Error processing error counts:', e);
                    }
                });
                
                if (Object.keys(errorCounts).length === 0) {
                    document.getElementById('stat-common-error').textContent = 'None';
                } else {
                    const mostCommonError = Object.entries(errorCounts)
                        .sort((a, b) => b[1] - a[1])[0];
                    document.getElementById('stat-common-error').textContent = `${mostCommonError[0]} (${mostCommonError[1]} occurrences)`;
                }
            }
            
            // Helper function to extract error type from error message
            function getErrorType(errorMsg) {
                if (!errorMsg) return 'Unknown';
                
                const errorStr = String(errorMsg);
                
                // Extract the first part of the error message as the type
                if (errorStr.includes(':')) {
                    return errorStr.split(':')[0].trim();
                }
                
                // Common error patterns
                if (errorStr.includes('API rate limit')) return 'Rate Limit';
                if (errorStr.includes('permission') || errorStr.includes('access')) return 'Permission';
                if (errorStr.includes('not found') || errorStr.includes('404')) return 'Not Found';
                if (errorStr.includes('network') || errorStr.includes('timeout')) return 'Network';
                if (errorStr.includes('invalid') || errorStr.includes('syntax')) return 'Validation';
                
                // If the error is long, just use first few words
                if (errorStr.length > 20) {
                    return errorStr.substring(0, 20).trim() + '...';
                }
                
                return errorStr.trim() || 'Unknown';
            }
            
            // Handle chart click (separate function for better error isolation)
            function handleChartClick(event, activeElements) {
                try {
                    console.log('Chart click detected', activeElements);
                    
                    if (!activeElements || activeElements.length === 0) {
                        console.log('No active elements in chart click');
                        return;
                    }
                    
                    // Access the index safely
                    const index = activeElements[0].index;
                    console.log('Clicked element index:', index);
                    
                    // Use the global chartDateKeys array that was populated in createDrillableChart
                    if (!window.chartDateKeys || !window.chartDateKeys[index]) {
                        console.error(`No date key found for index ${index}`);
                        return;
                    }
                    
                    const dateKey = window.chartDateKeys[index];
                    console.log(`Drill down into date: ${dateKey}`);
                    
                    // Set drill-down state
                    drillDownState = {
                        type: 'day',
                        date: dateKey
                    };
                    
                    // Show drill-up button
                    const drillUpBtn = document.getElementById('drill-up-btn');
                    if (drillUpBtn) {
                        drillUpBtn.style.display = 'inline-block';
                    } else {
                        console.error('Drill-up button not found in DOM');
                    }
                    
                    // Load details for this day
                    loadDayDetails(dateKey, selectedProjects);
                } catch (error) {
                    console.error('Error in chart click handler:', error);
                    console.error('Error details:', {
                        message: error.message,
                        stack: error.stack,
                        activeElements: JSON.stringify(activeElements)
                    });
                    displayErrorMessage(error);
                }
            }
            
            // Display a message when no data is available
            function displayNoDataMessage(message) {
                const graphContainer = document.getElementById('sync-stats-graph');
                if (syncStatsChart) {
                    syncStatsChart.destroy();
                    syncStatsChart = null;
                }
                
                // Since we're using a canvas now, we need to replace it with a div to show the message
                const parentElement = graphContainer.parentElement;
                parentElement.removeChild(graphContainer);
                
                const messageDiv = document.createElement('div');
                messageDiv.id = 'sync-stats-graph';
                messageDiv.style.width = '100%';
                messageDiv.style.height = '400px';
                messageDiv.style.display = 'flex';
                messageDiv.style.alignItems = 'center';
                messageDiv.style.justifyContent = 'center';
                messageDiv.style.color = '#666';
                messageDiv.textContent = message || 'No sync data available for the selected criteria';
                
                parentElement.insertBefore(messageDiv, parentElement.firstChild);
                
                // Reset summary stats
                document.getElementById('stat-total-syncs').textContent = '0';
                document.getElementById('stat-avg-success-rate').textContent = '0%';
                document.getElementById('stat-common-error').textContent = 'None';
            }
            
            // Display an error message
            function displayErrorMessage(error) {
                const graphContainer = document.getElementById('sync-stats-graph');
                if (syncStatsChart) {
                    syncStatsChart.destroy();
                    syncStatsChart = null;
                }
                
                // Since we're using a canvas now, we need to replace it with a div to show the message
                const parentElement = graphContainer.parentElement;
                parentElement.removeChild(graphContainer);
                
                const messageDiv = document.createElement('div');
                messageDiv.id = 'sync-stats-graph';
                messageDiv.style.width = '100%';
                messageDiv.style.height = '400px';
                messageDiv.style.display = 'flex';
                messageDiv.style.alignItems = 'center';
                messageDiv.style.justifyContent = 'center';
                messageDiv.style.color = '#dc3545';
                messageDiv.textContent = `Error loading sync data: ${error.message}`;
                
                parentElement.insertBefore(messageDiv, parentElement.firstChild);
            }
            
            // Start auto-sync scheduler when page loads
            function initializeAutoSync() {
                console.log('Initializing auto-sync...');
                scheduleAutoSync();
            }
            
            // Call this function after connection is established
            function afterConnectionEstablished() {
                // Initialize auto-sync
                initializeAutoSync();
            }
            
            // Add these new functions for drill-down capabilities
            
            // Load details for a specific day
            function loadDayDetails(dateKey, projectIds) {
                try {
                    console.log(`Loading details for day: ${dateKey}`, { projectIds });
                    
                    if (!dateKey) {
                        throw new Error('dateKey parameter is required for loadDayDetails');
                    }
                    
                    // Convert date string to Date objects for Firestore query
                    const startDate = new Date(dateKey);
                    const endDate = new Date(dateKey);
                    endDate.setDate(endDate.getDate() + 1); // End of the day
                    
                    // Show drill-up button
                    const drillUpBtn = document.getElementById('drill-up-btn');
                    if (drillUpBtn) {
                        drillUpBtn.style.display = 'inline-block';
                } else {
                        console.warn('Drill-up button not found in DOM');
                    }
                    
                    // Add view toggle controls if they don't exist
                    if (!document.getElementById('drill-view-toggle')) {
                        // First check if stats-controls exists
                        const statsControls = document.querySelector('.stats-controls');
                        if (!statsControls) {
                            console.warn('Stats controls container (.stats-controls) not found in DOM');
                            
                            // Create the controls container if it doesn't exist
                            const modalBody = document.getElementById('sync-stats-modal-body');
                            if (modalBody) {
                                const newStatsControls = document.createElement('div');
                                newStatsControls.className = 'stats-controls';
                                newStatsControls.style.marginBottom = '15px';
                                newStatsControls.style.paddingBottom = '15px';
                                newStatsControls.style.borderBottom = '1px solid #eee';
                                
                                const controlsRow = document.createElement('div');
                                controlsRow.className = 'row';
                                newStatsControls.appendChild(controlsRow);
                                
                                // Insert before the chart
                                const graphContainer = document.getElementById('sync-stats-graph');
                                if (graphContainer) {
                                    modalBody.insertBefore(newStatsControls, graphContainer);
                                    console.log('Created missing stats-controls container');
                                } else {
                                    console.error('Neither stats-controls nor graph container found');
                                }
                            } else {
                                console.error('Modal body not found, cannot create controls');
                            }
                        }
                        
                        // Try again to find .stats-controls .row:first-child
                        const controlsContainer = document.querySelector('.stats-controls .row:first-child');
                        
                        // Check if the stats-controls container exists
                        if (controlsContainer) {
                            const viewToggleCol = document.createElement('div');
                            viewToggleCol.className = 'col';
                            viewToggleCol.innerHTML = `
                                <div class="form-group">
                                    <label for="drill-view-toggle">View By:</label>
                                    <select id="drill-view-toggle" class="form-control">
                                        <option value="hour">Hour</option>
                                        <option value="project">Project</option>
                                    </select>
                            </div>
                        `;
                            controlsContainer.appendChild(viewToggleCol);
                            
                            // Add event listener for view toggle
                            document.getElementById('drill-view-toggle').addEventListener('change', function() {
                                try {
                                    const viewType = this.value;
                                    console.log(`View toggle changed to: ${viewType}`);
                                    if (viewType === 'hour') {
                                        loadDayDetailsByHour(dateKey, projectIds);
                                    } else {
                                        loadDayDetailsByProject(dateKey, projectIds);
                                    }
                                } catch (error) {
                                    console.error('Error in view toggle handler:', error);
                                    displayErrorMessage(error);
                                }
                            });
                            
                            console.log('Added view toggle controls');
                        } else {
                            console.warn('Stats controls row container still not found after creation attempt');
                        }
                    } else {
                        // Reset to hour view by default
                        try {
                            const toggleElement = document.getElementById('drill-view-toggle');
                            toggleElement.value = 'hour';
                            console.log('Reset view toggle to "hour"');
                        } catch (error) {
                            console.error('Error setting view toggle value:', error);
                        }
                    }
                    
                    // Load details by hour (default view)
                    loadDayDetailsByHour(dateKey, projectIds);
                } catch (error) {
                    console.error('Error in loadDayDetails:', error);
                    displayErrorMessage(error);
                }
            }
            
            // Load day details with hourly breakdown
            function loadDayDetailsByHour(dateKey, projectIds) {
                console.log(`Loading hourly breakdown for day: ${dateKey}`);
                
                // Convert date string to Date objects for Firestore query
                const startDate = new Date(dateKey);
                const endDate = new Date(dateKey);
                endDate.setDate(endDate.getDate() + 1); // End of the day
                
                // Query sync logs for this day
                db.collection('asana_sync_logs')
                    .where('timestamp', '>=', firebase.firestore.Timestamp.fromDate(startDate))
                    .where('timestamp', '<', firebase.firestore.Timestamp.fromDate(endDate))
                    .orderBy('timestamp', 'asc')
                    .get()
                    .then(snapshot => {
                        if (snapshot.empty) {
                            console.log('No sync logs found for the selected day');
                            displayNoDataMessage();
                            return;
                        }
                        
                        // Process the sync logs
                        const logs = [];
                        snapshot.forEach(doc => {
                            const log = doc.data();
                            logs.push({
                                id: doc.id,
                                ...log,
                                time: log.timestamp ? log.timestamp.toDate() : new Date()
                            });
                        });
                        
                        console.log(`Found ${logs.length} sync logs for ${dateKey}`);
                        
                        // Filter logs by selected projects if needed
                        let filteredLogs = logs;
                        if (projectIds && projectIds.length > 0) {
                            filteredLogs = logs.filter(log => {
                                for (const projectId of projectIds) {
                                    if (log.projects && log.projects.includes(projectId)) {
                                        return true;
                                    }
                                    if (log.projectStats && log.projectStats[projectId]) {
                                        return true;
                                    }
                                }
                                return false;
                            });
                        }
                        
                        if (filteredLogs.length === 0) {
                            displayNoDataMessage();
                            return;
                        }
                        
                        // Prepare data for chart: sync details by hour
                        const hourlyData = {};
                        const labels = [];
                        
                        // Initialize all hours in the day
                        for (let hour = 0; hour < 24; hour++) {
                            const hourKey = hour.toString().padStart(2, '0');
                            labels.push(`${hourKey}:00`);
                            hourlyData[hourKey] = {
                                syncCount: 0,
                                successCount: 0,
                                errorCount: 0,
                                totalCount: 0
                            };
                        }
                        
                        // Populate with actual logs
                        filteredLogs.forEach(log => {
                            const hour = log.time.getHours().toString().padStart(2, '0');
                            
                            if (hourlyData[hour]) {
                                hourlyData[hour].syncCount++;
                                
                                if (log.success_count !== undefined && log.project_count !== undefined) {
                                    hourlyData[hour].successCount += log.success_count;
                                    hourlyData[hour].totalCount += log.project_count;
                                }
                                
                                if (log.errors && Array.isArray(log.errors)) {
                                    hourlyData[hour].errorCount += log.errors.length;
                                }
                                
                                if (log.projectStats) {
                                    Object.values(log.projectStats).forEach(stat => {
                                        if (stat.error) {
                                            hourlyData[hour].errorCount++;
                                        }
                                    });
                                }
                            }
                        });
                        
                        // Get the view type
                        const viewType = document.getElementById('display-mode')?.value || 'count';
                        
                        // Prepare data for chart based on view type
                        let chartData;
                        let chartTitle;
                        let chartColor;
                        
                        switch (viewType) {
                            case 'percentage':
                                chartTitle = 'Hourly Success Rate (%)';
                                chartColor = 'rgba(40, 167, 69, 0.7)';
                                chartData = Object.values(hourlyData).map(hour => {
                                    return hour.totalCount === 0 ? 0 : 
                                        Math.round((hour.successCount / hour.totalCount) * 100);
                                });
                                break;
                                
                            case 'count':
                            default:
                                chartTitle = 'Syncs per Hour';
                                chartColor = 'rgba(23, 162, 184, 0.7)';
                                chartData = Object.values(hourlyData).map(hour => {
                                    return hour.syncCount;
                                });
                                break;
                        }
                        
                        // Create or update chart
                        createHourlyChart(labels, chartData, chartTitle, chartColor);
                        
                        // Update summary statistics
                        updateSummaryStats(logs, filteredLogs);
                    })
                    .catch(error => {
                        console.error('Error loading day details by hour:', error);
                        displayErrorMessage(error);
                    });
            }
            
            // Load day details with project breakdown
            function loadDayDetailsByProject(dateKey, projectIds) {
                try {
                    console.log(`Loading project breakdown for day: ${dateKey}`, { projectIds });
                    
                    if (!dateKey) {
                        throw new Error('dateKey parameter is required');
                    }
                    
                    // Convert date string to Date objects for Firestore query
                    const startDate = new Date(dateKey);
                    const endDate = new Date(dateKey);
                    endDate.setDate(endDate.getDate() + 1); // End of the day
                    
                    // Query sync logs for this day
                    db.collection('asana_sync_logs')
                        .where('timestamp', '>=', firebase.firestore.Timestamp.fromDate(startDate))
                        .where('timestamp', '<', firebase.firestore.Timestamp.fromDate(endDate))
                        .orderBy('timestamp', 'asc')
                        .get()
                        .then(snapshot => {
                            if (snapshot.empty) {
                                console.log('No sync logs found for the selected day');
                                displayNoDataMessage();
                                return;
                            }
                            
                            // Process the sync logs
                            const logs = [];
                            snapshot.forEach(doc => {
                                try {
                                    const log = doc.data();
                                    logs.push({
                                        id: doc.id,
                                        ...log,
                                        time: log.timestamp ? log.timestamp.toDate() : new Date()
                                    });
                                } catch (e) {
                                    console.error('Error processing log document:', e);
                                }
                            });
                            
                            console.log(`Found ${logs.length} sync logs for ${dateKey}`);
                            
                            // Filter logs by selected projects if needed
                            let filteredLogs = logs;
                            if (projectIds && projectIds.length > 0) {
                                console.log('Filtering logs by project IDs:', projectIds);
                                filteredLogs = logs.filter(log => {
                                    for (const projectId of projectIds) {
                                        // Different ways Asana might store project IDs
                                        if (log.projects && (log.projects.includes(projectId) || log.projects.includes(String(projectId)))) {
                                            return true;
                                        }
                                        
                                        // Check in projectStats using all possible key formats (id, gid, etc.)
                                        if (log.projectStats) {
                                            if (log.projectStats[projectId] || 
                                                log.projectStats[String(projectId)] ||
                                                (log.projectStats.hasOwnProperty('gid') && (
                                                    log.projectStats.gid === projectId || 
                                                    log.projectStats.gid === String(projectId)
                                                ))) {
                                                return true;
                                            }
                                            
                                            // Check if any project in projectStats has this ID or GID
                                            const hasMatchingProject = Object.entries(log.projectStats).some(([key, value]) => {
                                                if (key === projectId || key === String(projectId)) {
                                                    return true;
                                                }
                                                
                                                if (value && typeof value === 'object') {
                                                    return (value.id === projectId || value.id === String(projectId) ||
                                                            value.gid === projectId || value.gid === String(projectId));
                                                }
                                                
                                                return false;
                                            });
                                            
                                            if (hasMatchingProject) {
                                                return true;
                                            }
                                        }
                                    }
                                    return false;
                                });
                                console.log(`Filtered to ${filteredLogs.length} logs for selected projects`);
                            }
                            
                            if (filteredLogs.length === 0) {
                                console.log('No logs found after filtering');
                                displayNoDataMessage();
                                return;
                            }
                            
                            // Extract all project data with defensive coding
                            const projectsData = {};
                            const projectIdsSet = new Set();
                            
                            // First pass - collect all possible project identifiers from logs
                            console.log('Collecting project identifiers from logs...');
                            filteredLogs.forEach(log => {
                                try {
                                    // Add projects from projects array
                                    if (log.projects && Array.isArray(log.projects)) {
                                        log.projects.forEach(id => {
                                            if (id) projectIdsSet.add(String(id));
                                        });
                                    }
                                    
                                    // Add projects from projectStats object
                                    if (log.projectStats && typeof log.projectStats === 'object') {
                                        Object.keys(log.projectStats).forEach(id => {
                                            projectIdsSet.add(String(id));
                                        });
                                    }
                                } catch (e) {
                                    console.error('Error collecting project IDs:', e);
                                }
                            });
                            
                            console.log(`Found ${projectIdsSet.size} unique project identifiers`);
                            
                            // Second pass - collect stats for each project
                            filteredLogs.forEach(log => {
                                try {
                                    if (log.projectStats && typeof log.projectStats === 'object') {
                                        Object.entries(log.projectStats).forEach(([projectId, stat]) => {
                                            const idKey = String(projectId);
                                            
                                            // Initialize project data if not exists
                                            if (!projectsData[idKey]) {
                                                projectsData[idKey] = {
                                                    name: (stat && stat.name) ? stat.name : `Project ${idKey}`,
                                                    syncCount: 0,
                                                    successCount: 0,
                                                    errorCount: 0,
                                                    totalCount: 0
                                                };
                                            }
                                            
                                            // Increment counters
                                            projectsData[idKey].syncCount++;
                                            projectsData[idKey].totalCount++;
                                            
                                            if (stat && stat.status === 'success') {
                                                projectsData[idKey].successCount++;
                                            }
                                            
                                            if (stat && stat.error) {
                                                projectsData[idKey].errorCount++;
                                            }
                                        });
                                    }
                                } catch (e) {
                                    console.error('Error processing project stats:', e);
                                }
                            });
                            
                            console.log(`Processed stats for ${Object.keys(projectsData).length} projects`);
                            
                            // If no projects were found, tell the user
                            if (Object.keys(projectsData).length === 0) {
                                console.log('No project data found in the logs');
                                displayNoDataMessage('No project data found for the selected day');
                                return;
                            }
                            
                            // Get project names if not available in stats
                            const projectNamePromises = Object.keys(projectsData)
                                .filter(projectId => !projectsData[projectId].name || projectsData[projectId].name === `Project ${projectId}`)
                                .map(projectId => 
                                    db.collection('asana_projects').doc(projectId).get()
                                        .then(doc => {
                                            if (doc.exists && doc.data().name) {
                                                projectsData[projectId].name = doc.data().name;
                                            }
                                            return projectId;
                                        })
                                        .catch(error => {
                                            console.error(`Error fetching project name for ${projectId}:`, error);
                                            return projectId;
                                        })
                                );
                            
                            Promise.all(projectNamePromises)
                                .then(() => {
                                    console.log('Project names retrieved, preparing chart data');
                                    
                                    // Ensure we have at least one project
                                    if (Object.keys(projectsData).length === 0) {
                                        console.log('No projects found after processing');
                                        displayNoDataMessage('No project data found');
                                        return;
                                    }
                                    
                                    // Sort projects by name
                                    const sortedProjectEntries = Object.entries(projectsData)
                                        .sort((a, b) => a[1].name.localeCompare(b[1].name));
                                            
                                    const sortedProjects = sortedProjectEntries.map(entry => entry[1].name);
                                    
                                    console.log(`Sorted ${sortedProjects.length} projects by name`);
                                    
                                    // Get the view type
                                    const viewType = document.getElementById('display-mode')?.value || 'count';
                                    
                                    // Prepare data for chart based on view type
                                    let chartData;
                                    let chartTitle;
                                    let chartColor;
                                    
                                    switch (viewType) {
                                        case 'percentage':
                                            chartTitle = 'Project Success Rate (%)';
                                            chartColor = 'rgba(40, 167, 69, 0.7)';
                                            chartData = sortedProjectEntries
                                                .map(([id, data]) => {
                                                    return data.totalCount === 0 ? 0 : 
                                                        Math.round((data.successCount / data.totalCount) * 100);
                                                });
                                            break;
                                            
                                        case 'count':
                                        default:
                                            chartTitle = 'Syncs per Project';
                                            chartColor = 'rgba(23, 162, 184, 0.7)';
                                            chartData = sortedProjectEntries
                                                .map(([id, data]) => data.syncCount);
                                            break;
                                    }
                                    
                                    console.log('Chart data prepared:', {
                                        title: chartTitle,
                                        dataPoints: chartData.length
                                    });
                                    
                                    // Create or update chart
                                    createProjectChart(sortedProjects, chartData, chartTitle, chartColor, dateKey);
                                    
                                    // Update summary statistics
                                    updateSummaryStats(logs, filteredLogs);
                                });
                        })
                        .catch(error => {
                            console.error('Error loading day details by project:', error);
                            displayErrorMessage(error);
                        });
                } catch (error) {
                    console.error('Error in loadDayDetailsByProject:', error);
                    displayErrorMessage(error);
                }
            }
            
            // Create project chart for day drill-down
            function createProjectChart(labels, data, title, color, dateKey) {
                try {
                    const graphElement = document.getElementById('sync-stats-graph');
                    if (!graphElement) {
                        console.error('Graph element not found');
                        displayErrorMessage(new Error('Graph element not found'));
                        return;
                    }

                    // Make sure we have a canvas element
                    let canvasElement = graphElement;
                    if (graphElement.tagName !== 'CANVAS') {
                        console.log('Graph element is not a canvas, recreating it...');
                        const parentElement = graphElement.parentElement;
                        parentElement.removeChild(graphElement);
                        
                        canvasElement = document.createElement('canvas');
                        canvasElement.id = 'sync-stats-graph';
                        canvasElement.style.width = '100%';
                        canvasElement.style.height = '400px';
                        
                        parentElement.insertBefore(canvasElement, parentElement.firstChild);
                    }
                    
                    const ctx = canvasElement.getContext('2d');
                    if (!ctx) {
                        console.error('Could not get 2D context from canvas');
                        displayErrorMessage(new Error('Could not initialize chart context'));
                        return;
                    }
                    
                    // Destroy previous chart if it exists
                    if (syncStatsChart) {
                        syncStatsChart.destroy();
                    }
                    
                    // Create new chart
                    syncStatsChart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: title,
                                data: data,
                                backgroundColor: color,
                                borderColor: color.replace('0.7', '1'),
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: title
                                    }
                                },
                                x: {
                                    title: {
                                        display: true,
                                        text: `Projects on ${new Date(dateKey).toLocaleDateString()}`
                                    },
                                    ticks: {
                                        callback: function(value, index) {
                                            // Truncate long project names
                                            const label = this.getLabelForValue(index);
                                            if (label.length > 15) {
                                                return label.substr(0, 12) + '...';
                                            }
                                            return label;
                                        }
                                    }
                                }
                            },
                            plugins: {
                                tooltip: {
                                    callbacks: {
                                        title: function(tooltipItem) {
                                            // Show full project name in tooltip
                                            return tooltipItem[0].label;
                                        }
                                    }
                                }
                            }
                        }
                    });
                } catch (error) {
                    console.error('Error creating project chart:', error);
                    displayErrorMessage(error);
                }
            }
            
            // Load details for a specific project over time
            function loadProjectDetails(projectId, days) {
                console.log(`Loading details for project: ${projectId} over ${days} days`);
                
                // Calculate date range
                const endDate = new Date();
                const startDate = new Date();
                startDate.setDate(startDate.getDate() - days);
                
                // Get project name
                db.collection('asana_projects').doc(projectId).get()
                    .then(doc => {
                        let projectName = `Project ${projectId}`;
                        if (doc.exists) {
                            projectName = doc.data().name || projectName;
                        }
                        
                        // Query sync logs for the date range
                        return db.collection('asana_sync_logs')
                            .where('timestamp', '>=', firebase.firestore.Timestamp.fromDate(startDate))
                            .where('timestamp', '<=', firebase.firestore.Timestamp.fromDate(endDate))
                            .orderBy('timestamp', 'asc')
                            .get()
                            .then(snapshot => {
                                if (snapshot.empty) {
                                    console.log('No sync logs found for the selected project');
                                    displayNoDataMessage();
                return;
            }
            
                                // Process the sync logs
                                const logs = [];
                                snapshot.forEach(doc => {
                                    const log = doc.data();
                                    
                                    // Check if the log contains the project
                                    let hasProject = false;
                                    if (log.projects && log.projects.includes(projectId)) {
                                        hasProject = true;
                                    }
                                    if (log.projectStats && log.projectStats[projectId]) {
                                        hasProject = true;
                                    }
                                    
                                    if (hasProject) {
                                        logs.push({
                                            id: doc.id,
                                            ...log,
                                            date: log.timestamp ? log.timestamp.toDate() : new Date()
                                        });
                                    }
                                });
                                
                                console.log(`Found ${logs.length} sync logs for project ${projectName}`);
                                
                                if (logs.length === 0) {
                                    displayNoDataMessage();
                                    return;
                                }
                                
                                // Group logs by day
                                const logsByDay = {};
                                const labels = [];
                                const currentDate = new Date(startDate);
                                
                                // Initialize all days in the range
                                while (currentDate <= endDate) {
                                    const dateKey = currentDate.toISOString().split('T')[0];
                                    labels.push(moment(dateKey).format('MMM D'));
                                    logsByDay[dateKey] = {
                                        date: new Date(currentDate),
                                        logs: [],
                                        successCount: 0,
                                        totalCount: 0,
                                        errorCount: 0,
                                        dateKey: dateKey
                                    };
                                    currentDate.setDate(currentDate.getDate() + 1);
                                }
                                
                                // Populate with actual logs
                                logs.forEach(log => {
                                    const dateKey = log.date.toISOString().split('T')[0];
                                    if (logsByDay[dateKey]) {
                                        logsByDay[dateKey].logs.push(log);
                                        
                                        // Count project-specific stats
                                        if (log.projectStats && log.projectStats[projectId]) {
                                            const stat = log.projectStats[projectId];
                                            logsByDay[dateKey].totalCount++;
                                            
                                            if (stat.status === 'success') {
                                                logsByDay[dateKey].successCount++;
                                            }
                                            
                                            if (stat.error) {
                                                logsByDay[dateKey].errorCount++;
                                            }
                                        }
                                    }
                                });
                                
                                // Get the view type
                                const viewType = document.getElementById('display-mode')?.value || 'count';
                                
                                // Prepare data for chart based on view type
                                let chartData;
                                let chartTitle;
                                let chartColor;
                                
                                switch (viewType) {
                                    case 'percentage':
                                        chartTitle = `Success Rate for ${projectName} (%)`;
                                        chartColor = 'rgba(40, 167, 69, 0.7)';
                                        chartData = Object.values(logsByDay).map(day => {
                                            return day.totalCount === 0 ? 0 : 
                                                Math.round((day.successCount / day.totalCount) * 100);
                                        });
                                        break;
                                        
                                    case 'count':
                                        chartTitle = `Sync Count for ${projectName}`;
                                        chartColor = 'rgba(23, 162, 184, 0.7)';
                                        chartData = Object.values(logsByDay).map(day => {
                                            return day.logs.length;
                                        });
                                        break;
                                        
                                    case 'errors':
                                        chartTitle = `Errors for ${projectName}`;
                                        chartColor = 'rgba(220, 53, 69, 0.7)';
                                        chartData = Object.values(logsByDay).map(day => {
                                            return day.errorCount;
                                        });
                                        break;
                                }
                                
                                // Create or update chart
                                createDrillableChart(labels, chartData, chartTitle, chartColor, Object.values(logsByDay));
                                
                                // Update summary statistics based on project-specific logs
                                updateSummaryStats(logs, logs);
                            });
                    })
                    .catch(error => {
                        console.error('Error loading project details:', error);
                        displayErrorMessage(error);
                    });
            }
            
            // Load details for a specific error type
            function loadErrorDetails(errorType, days, projectIds) {
                console.log(`Loading details for error type: ${errorType} over ${days} days`);
                
                // Calculate date range
                const endDate = new Date();
                const startDate = new Date();
                startDate.setDate(startDate.getDate() - days);
                
                // Query sync logs for the date range
                db.collection('asana_sync_logs')
                    .where('timestamp', '>=', firebase.firestore.Timestamp.fromDate(startDate))
                    .where('timestamp', '<=', firebase.firestore.Timestamp.fromDate(endDate))
                    .orderBy('timestamp', 'asc')
                    .get()
                    .then(snapshot => {
                        if (snapshot.empty) {
                            console.log('No sync logs found for the selected period');
                            displayNoDataMessage();
                            return;
                        }
                        
                        // Process the sync logs
                        const logs = [];
                        snapshot.forEach(doc => {
                            const log = doc.data();
                            logs.push({
                                id: doc.id,
                                ...log,
                                date: log.timestamp ? log.timestamp.toDate() : new Date()
                            });
                        });
                        
                        // Filter logs by selected projects if needed
                        let filteredLogs = logs;
                        if (projectIds && projectIds.length > 0) {
                            filteredLogs = logs.filter(log => {
                                for (const projectId of projectIds) {
                                    if (log.projects && log.projects.includes(projectId)) {
                                        return true;
                                    }
                                    if (log.projectStats && log.projectStats[projectId]) {
                                        return true;
                                    }
                                }
                                return false;
                            });
                        }
                        
                        // Filter logs by error type
                        filteredLogs = filteredLogs.filter(log => {
                            // Check for errors array
                            if (log.errors && Array.isArray(log.errors)) {
                                for (const error of log.errors) {
                                    const errorStr = String(error);
                                    const currentErrorType = errorStr.includes(':') ? 
                                        errorStr.split(':')[0].trim() : errorStr.trim();
                                    
                                    if (currentErrorType === errorType) {
                                        return true;
                                    }
                                }
                            }
                            
                            // Check for project-specific errors
                            if (log.projectStats) {
                                for (const projectStat of Object.values(log.projectStats)) {
                                    if (projectStat.error) {
                                        const errorStr = String(projectStat.error);
                                        const currentErrorType = errorStr.includes(':') ? 
                                            errorStr.split(':')[0].trim() : errorStr.trim();
                                        
                                        if (currentErrorType === errorType) {
                                            return true;
                                        }
                                    }
                                }
                            }
                            
                            return false;
                        });
                        
                        console.log(`Found ${filteredLogs.length} logs with error type "${errorType}"`);
                        
                        if (filteredLogs.length === 0) {
                            displayNoDataMessage();
                            return;
                        }
                        
                        // Group logs by day
                        const logsByDay = {};
                        const labels = [];
                        const currentDate = new Date(startDate);
                        
                        // Initialize all days in the range
                        while (currentDate <= endDate) {
                            const dateKey = currentDate.toISOString().split('T')[0];
                            labels.push(moment(dateKey).format('MMM D'));
                            logsByDay[dateKey] = {
                                date: new Date(currentDate),
                                logs: [],
                                errorCount: 0,
                                dateKey: dateKey
                            };
                            currentDate.setDate(currentDate.getDate() + 1);
                        }
                        
                        // Populate with actual logs
                        filteredLogs.forEach(log => {
                            const dateKey = log.date.toISOString().split('T')[0];
                            if (logsByDay[dateKey]) {
                                logsByDay[dateKey].logs.push(log);
                                
                                // Count errors
                                let dayErrorCount = 0;
                                
                                // Check errors array
                                if (log.errors && Array.isArray(log.errors)) {
                                    for (const error of log.errors) {
                                        const errorStr = String(error);
                                        const currentErrorType = errorStr.includes(':') ? 
                                            errorStr.split(':')[0].trim() : errorStr.trim();
                                        
                                        if (currentErrorType === errorType) {
                                            dayErrorCount++;
                                        }
                                    }
                                }
                                
                                // Check project-specific errors
                                if (log.projectStats) {
                                    for (const projectStat of Object.values(log.projectStats)) {
                                        if (projectStat.error) {
                                            const errorStr = String(projectStat.error);
                                            const currentErrorType = errorStr.includes(':') ? 
                                                errorStr.split(':')[0].trim() : errorStr.trim();
                                            
                                            if (currentErrorType === errorType) {
                                                dayErrorCount++;
                                            }
                                        }
                                    }
                                }
                                
                                logsByDay[dateKey].errorCount += dayErrorCount;
                            }
                        });
                        
                        // Prepare data for chart
                        const chartTitle = `"${errorType}" Errors Over Time`;
                        const chartColor = 'rgba(220, 53, 69, 0.7)';
                        const chartData = Object.values(logsByDay).map(day => day.errorCount);
                        
                        // Create or update chart
                        createDrillableChart(labels, chartData, chartTitle, chartColor, Object.values(logsByDay));
                        
                        // Update summary statistics
                        updateSummaryStats(logs, filteredLogs);
                    })
                    .catch(error => {
                        console.error('Error loading error details:', error);
                        displayErrorMessage(error);
                    });
            }
            
            // Create hourly chart for day drill-down
            function createHourlyChart(labels, data, title, color) {
                try {
                    const graphElement = document.getElementById('sync-stats-graph');
                    if (!graphElement) {
                        console.error('Graph element not found');
                        displayErrorMessage(new Error('Graph element not found'));
                        return;
                    }

                    // Make sure we have a canvas element
                    let canvasElement = graphElement;
                    if (graphElement.tagName !== 'CANVAS') {
                        console.log('Graph element is not a canvas, recreating it...');
                        const parentElement = graphElement.parentElement;
                        parentElement.removeChild(graphElement);
                        
                        canvasElement = document.createElement('canvas');
                        canvasElement.id = 'sync-stats-graph';
                        canvasElement.style.width = '100%';
                        canvasElement.style.height = '400px';
                        
                        parentElement.insertBefore(canvasElement, parentElement.firstChild);
                    }
                    
                    const ctx = canvasElement.getContext('2d');
                    if (!ctx) {
                        console.error('Could not get 2D context from canvas');
                        displayErrorMessage(new Error('Could not initialize chart context'));
                        return;
                    }
                    
                    // Destroy previous chart if it exists
                    if (syncStatsChart) {
                        syncStatsChart.destroy();
                    }
                    
                    // Create new chart
                    syncStatsChart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: title,
                                data: data,
                                backgroundColor: color,
                                borderColor: color.replace('0.7', '1'),
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: title
                                    }
                                },
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Hour of Day'
                                    }
                                }
                            }
                        }
                    });
                } catch (error) {
                    console.error('Error creating hourly chart:', error);
                    displayErrorMessage(error);
                }
            }
            
            // Retry Queue System
            
            // Queue state and configuration
            const RETRY_DELAY = 60000; // 1 minute in milliseconds
            const queueState = {
                active: false,
                timer: null,
                projectsInQueue: [],
                nextRetryTime: null
            };
            
            // Initialize the retry queue system
            function initRetryQueue() {
                // DOM elements
                const queueStateEl = document.getElementById('queue-state');
                const nextRetryEl = document.getElementById('next-retry');
                const queueCountEl = document.getElementById('queue-count');
                const projectListEl = document.getElementById('project-list-retry');
                const noProjectsEl = document.getElementById('no-projects');
                const retryLogEl = document.getElementById('retry-log');
                
                // Buttons
                const startQueueBtn = document.getElementById('start-queue');
                const stopQueueBtn = document.getElementById('stop-queue');
                const retryNowBtn = document.getElementById('retry-now');
                const refreshListBtn = document.getElementById('refresh-list');
                const retryAllBtn = document.getElementById('retry-all');
                const clearQueueBtn = document.getElementById('clear-queue');
                
                if (!startQueueBtn || !stopQueueBtn || !retryNowBtn || !refreshListBtn || 
                    !retryAllBtn || !clearQueueBtn || !queueStateEl || !nextRetryEl || 
                    !queueCountEl || !projectListEl || !noProjectsEl || !retryLogEl) {
                    console.error('Some retry queue elements not found in the DOM');
                    return;
                }
                
                // Create a retry queue collection if it doesn't exist
                db.collection('asana_retry_queue').get()
                  .then(snapshot => {
                      if (snapshot.empty) {
                          addRetryLogEntry('Creating retry queue collection', 'info');
                      } else {
                          addRetryLogEntry(`Found ${snapshot.size} projects in retry queue`, 'info');
                      }
                      refreshQueuedProjects();
                  })
                  .catch(error => {
                      addRetryLogEntry(`Error checking retry queue: ${error.message}`, 'error');
                  });
                
                // Add event listeners for buttons
                startQueueBtn.addEventListener('click', () => {
                    queueState.active = true;
                    addRetryLogEntry('Retry queue activated', 'info');
                    scheduleNextRetry();
                    updateQueueUI();
                });
                
                stopQueueBtn.addEventListener('click', () => {
                    queueState.active = false;
                    clearRetryTimer();
                    addRetryLogEntry('Retry queue paused', 'info');
                    updateQueueUI();
                });
                
                retryNowBtn.addEventListener('click', () => {
                    addRetryLogEntry('Manual retry triggered', 'info');
                    processQueue();
                });
                
                refreshListBtn.addEventListener('click', () => {
                    addRetryLogEntry('Refreshing project list', 'info');
                    refreshQueuedProjects();
                    findFailedProjects();
                });
                
                retryAllBtn.addEventListener('click', () => {
                    if (queueState.projectsInQueue.length === 0) {
                        addRetryLogEntry('No projects to retry', 'info');
                        return;
                    }
                    
                    addRetryLogEntry('Manual retry of all projects triggered', 'info');
                    processQueue();
                });
                
                clearQueueBtn.addEventListener('click', () => {
                    if (queueState.projectsInQueue.length === 0) {
                        return;
                    }
                    
                    if (confirm('Are you sure you want to clear all projects from the retry queue?')) {
                        addRetryLogEntry('Clearing retry queue', 'info');
                        
                        // Get all projects in the queue
                        db.collection('asana_retry_queue')
                            .where('status', 'in', ['queued', 'retrying', 'error'])
                            .get()
                            .then(snapshot => {
                                if (snapshot.empty) {
                                    addRetryLogEntry('No projects to clear', 'info');
                                    return;
                                }
                                
                                const batch = db.batch();
                                
                                snapshot.forEach(doc => {
                                    // Mark as cancelled rather than deleting
                                    batch.update(doc.ref, {
                                        status: 'cancelled',
                                        cancelledAt: firebase.firestore.FieldValue.serverTimestamp()
                                    });
                                });
                                
                                return batch.commit();
                            })
                            .then(() => {
                                addRetryLogEntry('Retry queue cleared', 'success');
                                refreshQueuedProjects();
                            })
                            .catch(error => {
                                addRetryLogEntry(`Error clearing retry queue: ${error.message}`, 'error');
                            });
                    }
                });
                
                // Initialize by checking for failed projects
                findFailedProjects();
            }
            
            // Function to check recent sync logs for failed projects
            function findFailedProjects() {
                addRetryLogEntry('Scanning recent sync logs for failed projects', 'info');
                
                db.collection('asana_sync_logs')
                    .orderBy('timestamp', 'desc')
                    .limit(5) // Get the most recent logs
                    .get()
                    .then(snapshot => {
                        if (snapshot.empty) {
                            addRetryLogEntry('No recent sync logs found', 'info');
                            return;
                        }
                        
                        let newFailedProjects = 0;
                        
                        // Process each log
                        snapshot.forEach(doc => {
                            const log = doc.data();
                            const timestamp = log.timestamp ? log.timestamp.toDate() : new Date();
                            
                            // Skip logs older than 1 day
                            const oneDayAgo = new Date();
                            oneDayAgo.setDate(oneDayAgo.getDate() - 1);
                            if (timestamp < oneDayAgo) {
                                return;
                            }
                            
                            if (log.projectStats) {
                                Object.entries(log.projectStats).forEach(([projectId, stats]) => {
                                    if (stats.error) {
                                        // Check if this project is already in the queue
                                        db.collection('asana_retry_queue').doc(projectId).get()
                                            .then(projectDoc => {
                                                if (!projectDoc.exists) {
                                                    // Add to retry queue
                                                    db.collection('asana_retry_queue').doc(projectId).set({
                                                        projectId: projectId,
                                                        name: stats.name || projectId,
                                                        error: stats.error,
                                                        status: 'queued',
                                                        originalErrorTime: timestamp,
                                                        addedToQueue: firebase.firestore.FieldValue.serverTimestamp(),
                                                        retryCount: 0,
                                                        lastRetryTime: null,
                                                        syncLogId: doc.id
                                                    })
                                                    .then(() => {
                                                        newFailedProjects++;
                                                        addRetryLogEntry(`Added project ${stats.name || projectId} to retry queue`, 'info');
                                                        refreshQueuedProjects();
                                                    })
                                                    .catch(error => {
                                                        addRetryLogEntry(`Error adding project to queue: ${error.message}`, 'error');
                                                    });
                                                }
                                            });
                                    }
                                });
                            }
                        });
                        
                        setTimeout(() => {
                            if (newFailedProjects > 0) {
                                addRetryLogEntry(`Added ${newFailedProjects} new projects to retry queue`, 'info');
                            } else {
                                addRetryLogEntry('No new failed projects found', 'info');
                            }
                        }, 1000);
                    })
                    .catch(error => {
                        addRetryLogEntry(`Error scanning sync logs: ${error.message}`, 'error');
                    });
            }
            
            // Function to refresh the project list display
            function refreshQueuedProjects() {
                const projectListEl = document.getElementById('project-list-retry');
                const noProjectsEl = document.getElementById('no-projects');
                
                if (!projectListEl || !noProjectsEl) {
                    console.error('Project list elements not found');
                    return;
                }
                
                db.collection('asana_retry_queue')
                    .where('status', 'in', ['queued', 'retrying', 'error'])
                    .get()
                    .then(snapshot => {
                        // Clear existing projects except the header
                        const projectItems = projectListEl.querySelectorAll('.project-item-retry');
                        projectItems.forEach(item => item.remove());
                        
                        if (snapshot.empty) {
                            noProjectsEl.style.display = 'block';
                            queueState.projectsInQueue = [];
                            updateQueueUI();
                            return;
                        }
                        
                        noProjectsEl.style.display = 'none';
                        queueState.projectsInQueue = [];
                        
                        snapshot.forEach(doc => {
                            const project = doc.data();
                            queueState.projectsInQueue.push(project);
                            
                            // Create project item
                            const projectItem = document.createElement('div');
                            projectItem.className = 'project-item-retry';
                            projectItem.dataset.projectId = project.projectId;
                            
                            // Determine status indicator
                            let statusClass = '';
                            switch(project.status) {
                                case 'error': statusClass = 'status-error'; break;
                                case 'queued': statusClass = 'status-queued'; break;
                                case 'retrying': statusClass = 'status-retrying'; break;
                                case 'success': statusClass = 'status-success'; break;
                            }
                            
                            projectItem.innerHTML = `
                                <div class="project-name">
                                    <span class="status-indicator ${statusClass}"></span>
                                    ${project.name || project.projectId}
                                </div>
                                <div class="project-error">${project.error || 'Unknown error'}</div>
                                <div class="project-actions">
                                    <button class="btn retry-project" data-project-id="${project.projectId}">Retry</button>
                                </div>
                            `;
                            
                            projectListEl.appendChild(projectItem);
                            
                            // Add event listener to retry button
                            const retryBtn = projectItem.querySelector('.retry-project');
                            retryBtn.addEventListener('click', () => retryProject(project.projectId));
                        });
                        
                        updateQueueUI();
                    })
                    .catch(error => {
                        addRetryLogEntry(`Error refreshing project list: ${error.message}`, 'error');
                    });
            }
            
            // Function to retry a specific project
            function retryProject(projectId) {
                addRetryLogEntry(`Manually retrying project ${projectId}`, 'info');
                
                // Update status to retrying
                db.collection('asana_retry_queue').doc(projectId).update({
                    status: 'retrying',
                    lastRetryTime: firebase.firestore.FieldValue.serverTimestamp(),
                    retryCount: firebase.firestore.FieldValue.increment(1)
                })
                .then(() => {
                    // Create a new sync log for this retry
                    return db.collection('asana_retry_queue').doc(projectId).get();
                })
                .then(doc => {
                    if (!doc.exists) {
                        throw new Error('Project not found in retry queue');
                    }
                    
                    const project = doc.data();
                    
                    // Create a sync log entry specifically for this retry
                    return db.collection('asana_sync_logs').add({
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        projects: [projectId],
                        projectNames: { [projectId]: project.name || projectId },
                        project_count: 1,
                        status: 'started',
                        message: `Started retry sync for project: ${project.name || projectId}`,
                        projectStats: {
                            [projectId]: {
                                status: 'started',
                                name: project.name || projectId,
                                start_time: firebase.firestore.FieldValue.serverTimestamp()
                            }
                        },
                        details: {
                            initiated_by: 'retry_system',
                            initiated_at: firebase.firestore.FieldValue.serverTimestamp(),
                            isRetry: true,
                            previousError: project.error,
                            retryCount: project.retryCount
                        }
                    });
                })
                .then(docRef => {
                    addRetryLogEntry(`Created retry sync log for project ${projectId}`, 'info');
                    
                    // Here we would normally kick off the actual sync process via an API call
                    // For demonstration, we'll simulate a successful sync
                    simulateProjectSync(projectId, docRef.id);
                    
                    // Refresh the UI
                    refreshQueuedProjects();
                })
                .catch(error => {
                    addRetryLogEntry(`Error starting retry for project ${projectId}: ${error.message}`, 'error');
                    
                    // Mark as error in the queue
                    db.collection('asana_retry_queue').doc(projectId).update({
                        status: 'error',
                        lastError: error.message
                    })
                    .catch(err => {
                        addRetryLogEntry(`Failed to update project status: ${err.message}`, 'error');
                    });
                    
                    refreshQueuedProjects();
                });
            }
            
            // Function to process all queued projects
            function processQueue() {
                if (!queueState.active) {
                    addRetryLogEntry('Queue processing is paused', 'info');
                    return;
                }
                
                if (queueState.projectsInQueue.length === 0) {
                    addRetryLogEntry('No projects in queue to process', 'info');
                    scheduleNextRetry();
                    return;
                }
                
                addRetryLogEntry(`Processing ${queueState.projectsInQueue.length} projects in queue`, 'info');
                
                // Get projects with status 'queued'
                db.collection('asana_retry_queue')
                    .where('status', '==', 'queued')
                    .get()
                    .then(snapshot => {
                        if (snapshot.empty) {
                            addRetryLogEntry('No queued projects to retry', 'info');
                            scheduleNextRetry();
                            return;
                        }
                        
                        const projectsToRetry = [];
                        snapshot.forEach(doc => {
                            projectsToRetry.push(doc.id);
                        });
                        
                        // Retry each project with a small delay between them
                        let index = 0;
                        function retryNext() {
                            if (index >= projectsToRetry.length) {
                                addRetryLogEntry('Finished retrying all queued projects', 'info');
                                scheduleNextRetry();
                                return;
                            }
                            
                            const projectId = projectsToRetry[index++];
                            retryProject(projectId);
                            
                            // Add a small delay before retrying the next project
                            setTimeout(retryNext, 2000);
                        }
                        
                        retryNext();
                    })
                    .catch(error => {
                        addRetryLogEntry(`Error processing queue: ${error.message}`, 'error');
                        scheduleNextRetry();
                    });
            }
            
            // Function to simulate a project sync (for demonstration)
            function simulateProjectSync(projectId, syncLogId) {
                addRetryLogEntry(`Simulating sync for project ${projectId}`, 'info');
                
                // Get project data from the queue
                db.collection('asana_retry_queue').doc(projectId).get()
                    .then(doc => {
                        if (!doc.exists) {
                            throw new Error('Project not found in retry queue');
                        }
                        
                        const project = doc.data();
                        
                        // 80% chance of success for retries
                        const isSuccess = Math.random() < 0.8;
                        
                        setTimeout(() => {
                            if (isSuccess) {
                                // Update sync log with success
                                db.collection('asana_sync_logs').doc(syncLogId).update({
                                    status: 'completed',
                                    message: `Retry sync for project ${project.name || projectId} completed successfully`,
                                    projectStats: {
                                        [projectId]: {
                                            status: 'success',
                                            name: project.name || projectId,
                                            completion_time: firebase.firestore.FieldValue.serverTimestamp()
                                        }
                                    },
                                    success_count: 1,
                                    task_count: Math.floor(Math.random() * 10) + 1,
                                    completion_time: firebase.firestore.FieldValue.serverTimestamp()
                                })
                                .then(() => {
                                    // Mark as success in the queue
                                    return db.collection('asana_retry_queue').doc(projectId).update({
                                        status: 'success',
                                        successTime: firebase.firestore.FieldValue.serverTimestamp()
                                    });
                                })
                                .then(() => {
                                    addRetryLogEntry(`Retry sync for project ${project.name || projectId} completed successfully`, 'success');
                                    refreshQueuedProjects();
                                });
                            } else {
                                // Generate a random error
                                const errors = [
                                    'API rate limit exceeded',
                                    'Task not found',
                                    'Network error',
                                    'Invalid resource reference'
                                ];
                                
                                // Don't use the permission denied error in simulation to avoid confusion
                                const randomError = errors[Math.floor(Math.random() * errors.length)];
                                
                                // Update sync log with error
                                db.collection('asana_sync_logs').doc(syncLogId).update({
                                    status: 'error',
                                    message: `Retry sync for project ${project.name || projectId} failed`,
                                    projectStats: {
                                        [projectId]: {
                                            status: 'error',
                                            name: project.name || projectId,
                                            error: randomError,
                                            completion_time: firebase.firestore.FieldValue.serverTimestamp()
                                        }
                                    },
                                    success_count: 0,
                                    errors: [randomError],
                                    completion_time: firebase.firestore.FieldValue.serverTimestamp()
                                })
                                .then(() => {
                                    // Mark as error in the queue
                                    return db.collection('asana_retry_queue').doc(projectId).update({
                                        status: 'error',
                                        lastError: randomError,
                                        lastRetryTime: firebase.firestore.FieldValue.serverTimestamp()
                                    });
                                })
                                .then(() => {
                                    addRetryLogEntry(`Retry sync for project ${project.name || projectId} failed: ${randomError}`, 'error');
                                    refreshQueuedProjects();
                                });
                            }
                        }, 3000); // Simulate 3 second sync process
                    })
                    .catch(error => {
                        addRetryLogEntry(`Error in sync simulation: ${error.message}`, 'error');
                    });
            }
            
            // Function to schedule the next retry
            function scheduleNextRetry() {
                if (!queueState.active) {
                    clearRetryTimer();
                    return;
                }
                
                // Clear any existing timer
                clearRetryTimer();
                
                // Set next retry time to now + RETRY_DELAY
                queueState.nextRetryTime = new Date(Date.now() + RETRY_DELAY);
                
                // Schedule the retry
                queueState.timer = setTimeout(() => {
                    processQueue();
                }, RETRY_DELAY);
                
                updateQueueUI();
                addRetryLogEntry(`Next retry scheduled for ${queueState.nextRetryTime.toLocaleTimeString()}`, 'info');
            }
            
            // Function to clear the retry timer
            function clearRetryTimer() {
                if (queueState.timer) {
                    clearTimeout(queueState.timer);
                    queueState.timer = null;
                    queueState.nextRetryTime = null;
                }
            }
            
            // Function to add a log entry
            function addRetryLogEntry(message, type = 'info') {
                const retryLogEl = document.getElementById('retry-log');
                if (!retryLogEl) {
                    console.error('Retry log element not found');
                    return;
                }
                
                const now = new Date();
                const timestamp = now.toLocaleTimeString();
                
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${type}`;
                logEntry.innerHTML = `
                    <span class="log-timestamp">[${timestamp}]</span>
                    <span>${message}</span>
                `;
                
                retryLogEl.appendChild(logEntry);
                retryLogEl.scrollTop = retryLogEl.scrollHeight;
                
                // Also log to console
                console.log(`[Retry] [${timestamp}] ${message}`);
            }
            
            // Function to update the queue UI
            function updateQueueUI() {
                const queueStateEl = document.getElementById('queue-state');
                const nextRetryEl = document.getElementById('next-retry');
                const queueCountEl = document.getElementById('queue-count');
                const startQueueBtn = document.getElementById('start-queue');
                const stopQueueBtn = document.getElementById('stop-queue');
                const retryNowBtn = document.getElementById('retry-now');
                const retryAllBtn = document.getElementById('retry-all');
                const clearQueueBtn = document.getElementById('clear-queue');
                
                if (!queueStateEl || !nextRetryEl || !queueCountEl || !startQueueBtn || 
                    !stopQueueBtn || !retryNowBtn || !retryAllBtn || !clearQueueBtn) {
                    console.error('Some queue UI elements not found');
                    return;
                }
                
                queueStateEl.textContent = queueState.active ? 'Active' : 'Inactive';
                queueStateEl.style.color = queueState.active ? '#28a745' : '#6c757d';
                
                nextRetryEl.textContent = queueState.nextRetryTime ? 
                    queueState.nextRetryTime.toLocaleTimeString() : 'None scheduled';
                    
                queueCountEl.textContent = queueState.projectsInQueue.length;
                
                // Update button states
                startQueueBtn.disabled = queueState.active;
                stopQueueBtn.disabled = !queueState.active;
                retryNowBtn.disabled = queueState.projectsInQueue.length === 0;
                retryAllBtn.disabled = queueState.projectsInQueue.length === 0;
                clearQueueBtn.disabled = queueState.projectsInQueue.length === 0;
                
                if (queueState.active && queueState.nextRetryTime) {
                    // Start a countdown timer
                    startCountdown();
                }
            }
            
            let countdownInterval = null;
            
            // Function to start countdown timer
            function startCountdown() {
                const nextRetryEl = document.getElementById('next-retry');
                if (!nextRetryEl) return;
                
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                }
                
                countdownInterval = setInterval(() => {
                    if (!queueState.nextRetryTime) {
                        clearInterval(countdownInterval);
                        return;
                    }
                    
                    const now = new Date();
                    const timeLeft = queueState.nextRetryTime - now;
                    
                    if (timeLeft <= 0) {
                        clearInterval(countdownInterval);
                        nextRetryEl.textContent = 'Processing...';
                        return;
                    }
                    
                    // Format as MM:SS
                    const minutes = Math.floor(timeLeft / 60000);
                    const seconds = Math.floor((timeLeft % 60000) / 1000);
                    nextRetryEl.textContent = `${queueState.nextRetryTime.toLocaleTimeString()} (${minutes}:${seconds.toString().padStart(2, '0')})`;
                }, 1000);
            }
        });
    </script>
</body>
</html> 