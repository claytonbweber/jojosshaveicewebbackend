<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Asana Sync Manager - JoJo's Shave Ice</title>
    <link rel="stylesheet" href="../assets/css/styles.css">
    <!-- Add Chart.js and Moment.js for graph visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
    <style>
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #FF4040;
            text-decoration: none;
            font-weight: bold;
        }
        .back-link:hover {
            text-decoration: underline;
        }
        .asana-container {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h2 {
            color: #444;
            margin-top: 0;
        }
        .info-box {
            background-color: #f8f9fa;
            border-left: 4px solid #87CEEB;
            padding: 15px;
            margin-bottom: 20px;
        }
        .connection-status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            margin-left: 10px;
        }
        .status-connected {
            background-color: #28a745;
            color: white;
        }
        .status-disconnected {
            background-color: #dc3545;
            color: white;
        }
        .btn {
            display: inline-block;
            background-color: #FF4040;
            color: white;
            text-decoration: none;
            padding: 8px 15px;
            border-radius: 4px;
            font-weight: bold;
            transition: background-color 0.3s ease;
            border: none;
            cursor: pointer;
        }
        .btn:hover {
            background-color: #d93333;
        }
        .btn-secondary {
            background-color: #6c757d;
        }
        .btn-secondary:hover {
            background-color: #5a6268;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="text"],
        input[type="password"],
        select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        /* Tab Navigation */
        .tab-nav {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }
        .tab-btn {
            padding: 10px 20px;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            font-weight: bold;
            color: #666;
        }
        .tab-btn.active {
            border-bottom: 2px solid #FF4040;
            color: #FF4040;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        
        /* Two-column layout */
        .row {
            display: flex;
            margin: 0 -10px;
        }
        .col {
            padding: 0 10px;
            flex: 1;
        }
        
        /* Project list */
        .project-list {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
        }
        .project-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
        }
        .project-item:last-child {
            border-bottom: none;
        }
        .project-checkbox {
            margin-right: 8px;
        }
        .project-stats {
            font-size: 0.8rem;
            color: #666;
            margin-top: 5px;
        }
        
        /* History log */
        .history-log {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        .log-entry {
            padding: 8px;
            border-bottom: 1px solid #eee;
            font-size: 0.9rem;
        }
        .log-entry:last-child {
            border-bottom: none;
        }
        .log-time {
            color: #888;
            font-size: 0.8rem;
        }
        .log-message {
            margin-top: 3px;
        }
        .log-success {
            color: #28a745;
        }
        .log-error {
            color: #dc3545;
        }
        .log-warning {
            color: #ffc107;
        }
        .log-info {
            color: #17a2b8;
        }
        
        /* Task viewer */
        .task-filters {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        .task-list {
            margin-top: 20px;
        }
        .task-item {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 10px;
            background-color: #f9f9f9;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .task-item:hover {
            background-color: #f0f0f0;
        }
        .task-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .task-details {
            color: #666;
            font-size: 0.9rem;
        }
        
        /* Task modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 1000;
            overflow: auto;
        }
        .modal-content {
            background-color: white;
            margin: 40px auto;
            padding: 20px;
            width: 80%;
            max-width: 800px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .modal-title {
            font-size: 1.4rem;
            font-weight: bold;
        }
        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
        }
        .modal-body {
            max-height: 70vh;
            overflow-y: auto;
        }
        .task-property {
            margin-bottom: 15px;
        }
        .property-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .load-more {
            text-align: center;
            margin-top: 15px;
        }
        .info-value {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
    </style>
</head>
<body>
    <header>
        <h1>JoJo's Shave Ice Management Hub</h1>
    </header>
    
    <div class="container">
        <a href="/" class="back-link">‚Üê Back to Dashboard</a>
        
        <div class="asana-container">
            <h2>Asana Sync Manager <span class="connection-status status-disconnected">Disconnected</span></h2>
            
            <div id="connection-notice" class="info-box">
                <p>This tool allows you to synchronize tasks between Asana and JoJo's Shave Ice internal systems. Connect your Asana account to get started.</p>
                </div>
            
            <!-- Always show tab navigation -->
            <div class="tab-nav">
                <button class="tab-btn active" data-tab="workspace-sync">Workspace Sync</button>
                <button class="tab-btn" data-tab="task-viewer">Task Viewer</button>
                <button class="tab-btn" data-tab="settings">Settings</button>
            </div>
            
            <!-- Workspace Sync Tab -->
            <div id="workspace-sync" class="tab-content active">
                <div id="not-connected-workspace" class="info-box" style="background-color: #fff3cd; border-left-color: #ffc107;">
                    <p>You need to configure your Asana connection first. Go to the Settings tab to enter your Asana Personal Access Token.</p>
        </div>
        
                <div id="connected-workspace" style="display: none;">
                    <div class="form-group">
                        <label for="workspace-select">Select Workspace</label>
                        <select id="workspace-select">
                            <option value="">-- Select a workspace --</option>
                            <!-- Workspaces will be loaded from Firestore -->
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <button id="force-sync-btn" class="btn">Force Sync Now</button>
                        <button id="view-sync-stats-btn" class="btn btn-secondary" style="margin-left: 10px;">View Sync Stats</button>
                        <span id="last-sync-time" style="margin-left: 15px; font-size: 0.9rem; color: #666;">Last sync: Loading...</span>
                        <span id="next-auto-sync" style="margin-left: 15px; font-size: 0.9rem; color: #666;">Next auto-sync: Calculating...</span>
                    </div>
                    
                    <!-- Add search and project management tools -->
                    <div class="project-tools" style="margin-bottom: 15px; padding: 12px; background-color: #f8f9fa; border-radius: 4px;">
                        <div class="row">
                            <div class="col">
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label for="project-search" style="display: inline-block; margin-right: 10px;">Search Projects:</label>
                                    <input type="text" id="project-search" placeholder="Type to filter projects..." style="display: inline-block; width: 250px;">
                                </div>
                            </div>
                            <div class="col" style="text-align: right;">
                                <button id="delete-projects-btn" class="btn btn-secondary" disabled>Delete Selected Projects</button>
                            </div>
                    </div>
                </div>
                
                    <div class="row">
                        <div class="col">
                            <h3>Projects</h3>
                            <div class="form-group">
                                <label class="project-select-all">
                                    <input type="checkbox" id="select-all-projects"> Select all projects
                                </label>
                    </div>
                            <div class="project-list" id="project-list">
                                <!-- Projects will be loaded from asana_projects collection -->
                                <div class="loading-indicator">Loading projects...</div>
                        </div>
                    </div>
                        <div class="col">
                            <h3>Sync History</h3>
                            <div class="history-log" id="history-log">
                                <!-- Sync logs will be loaded from asana_sync_logs collection -->
                                <div class="loading-indicator">Loading sync history...</div>
                </div>
                            <div class="load-more">
                                <button id="load-more-logs" class="btn btn-secondary">Load More</button>
            </div>
                    </div>
                        </div>
                    </div>
                </div>
            
            <!-- Task Viewer Tab -->
            <div id="task-viewer" class="tab-content">
                <div id="not-connected-tasks" class="info-box" style="background-color: #fff3cd; border-left-color: #ffc107;">
                    <p>You need to configure your Asana connection first. Go to the Settings tab to enter your Asana Personal Access Token.</p>
            </div>
            
                <div id="connected-tasks" style="display: none;">
                    <div class="task-filters">
                        <div class="row">
                            <div class="col">
                                <div class="form-group">
                                    <label for="filter-project">Project</label>
                                    <select id="filter-project">
                                        <option value="">All Projects</option>
                                        <!-- Projects will be loaded from Firestore -->
                                    </select>
                    </div>
                        </div>
                            <div class="col">
                                <div class="form-group">
                                    <label for="filter-status">Status</label>
                                    <select id="filter-status">
                                        <option value="">All Statuses</option>
                                        <option value="false">Not Started</option>
                                        <option value="true">Completed</option>
                                </select>
                            </div>
                            </div>
                            <div class="col">
                                <div class="form-group">
                                    <label for="filter-assignee">Assignee</label>
                                    <select id="filter-assignee">
                                        <option value="">All Assignees</option>
                                        <!-- Assignees will be loaded from Firestore -->
                                    </select>
                        </div>
                    </div>
                </div>
                        <div class="form-group">
                            <button id="apply-filters" class="btn">Apply Filters</button>
                            <button id="reset-filters" class="btn btn-secondary" style="margin-left: 10px;">Reset</button>
                    </div>
                </div>
                
                    <div class="task-list" id="task-list">
                        <!-- Tasks will be loaded from Firestore -->
                        <div class="loading-indicator">Loading tasks...</div>
                    </div>
                    <div class="load-more">
                        <button id="load-more-tasks" class="btn btn-secondary">Load More Tasks</button>
                        </div>
                    </div>
            </div>
            
            <!-- Settings Tab -->
            <div id="settings" class="tab-content">
                <div id="current-connection" class="asana-container" style="display: none;">
                    <h3>Current Connection</h3>
                    <div class="form-group">
                        <label>Personal Access Token:</label>
                        <div id="current-token" class="info-value">‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢</div>
                    </div>
                    <div class="form-group">
                        <label>Sync Frequency:</label>
                        <div id="current-frequency" class="info-value">Every hour</div>
                        </div>
                    <div class="form-group">
                        <label>Last Sync:</label>
                        <div id="current-last-sync" class="info-value">Never</div>
                    </div>
                    <div class="form-group">
                        <button id="edit-settings" class="btn">Edit Settings</button>
                        <button id="clear-settings" class="btn btn-secondary" style="margin-left: 10px;">Clear Settings</button>
                </div>
            </div>
            
                <div id="settings-form-container">
                    <div class="info-box">
                        <p>Configure your Asana integration settings here. Your Personal Access Token will be securely stored in Firestore.</p>
                    </div>
        
                    <form id="settings-form">
                        <div class="form-group">
                            <label for="asana-pat">Asana Personal Access Token (PAT)</label>
                            <input type="password" id="asana-pat" placeholder="Enter your Asana PAT">
                            <small style="display: block; margin-top: 5px; color: #666;">You can generate a PAT in your Asana account settings</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="sync-frequency">Sync Frequency</label>
                            <select id="sync-frequency">
                                <option value="15">Every 15 minutes</option>
                                <option value="30">Every 30 minutes</option>
                                <option value="60" selected>Every hour</option>
                                <option value="360">Every 6 hours</option>
                                <option value="720">Every 12 hours</option>
                                <option value="1440">Once a day</option>
                            </select>
                    </div>
                        
                        <div class="form-group">
                            <button type="submit" class="btn">Save Settings</button>
                            <button type="button" id="test-connection" class="btn btn-secondary" style="margin-left: 10px;">Test Connection</button>
                            <button type="button" id="cancel-edit" class="btn btn-secondary" style="margin-left: 10px; display: none;">Cancel</button>
                </div>
                    </form>
                    
                    <!-- Debug Section (for admin use) -->
                    <div style="margin-top: 30px; border-top: 1px dashed #ccc; padding-top: 20px;">
                        <h4>Admin Debug Tools</h4>
                        <p>Use these tools to troubleshoot connection issues.</p>
                        
                        <div class="form-group">
                            <button id="debug-show-data" class="btn btn-secondary">Show Database Data</button>
                            <button id="debug-create-settings" class="btn btn-secondary" style="margin-left: 10px;">Create Sample Settings</button>
                            <button id="debug-create-projects" class="btn btn-secondary" style="margin-left: 10px;">Create Sample Projects</button>
                            <button id="debug-clear-logs" class="btn btn-secondary" style="margin-left: 10px;">Clear Console</button>
    </div>

                        <div id="debug-output" style="margin-top: 15px; background-color: #f5f5f5; padding: 10px; border-radius: 4px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px;"></div>
                    </div>
                </div>
            </div>
        </div>
        
    <!-- Task Detail Modal -->
    <div id="task-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Task Details</h3>
                <button class="close-btn">&times;</button>
            </div>
            <div class="modal-body" id="task-modal-body">
                <!-- Task details will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <!-- Sync Statistics Modal -->
    <div id="sync-stats-modal" class="modal">
        <div class="modal-content" style="width: 90%; max-width: 1000px;">
            <div class="modal-header">
                <h3 class="modal-title">Sync Statistics</h3>
                <button class="close-btn">&times;</button>
            </div>
            <div class="modal-body" id="sync-stats-modal-body">
                <div class="stats-controls" style="margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #eee;">
                    <div class="row">
                        <div class="col">
                            <div class="form-group">
                                <label for="stats-date-range">Time Range:</label>
                                <select id="stats-date-range" class="form-control">
                                    <option value="7">Last 7 days</option>
                                    <option value="14">Last 14 days</option>
                                    <option value="30">Last 30 days</option>
                                </select>
                            </div>
                        </div>
                        <div class="col">
                            <div class="form-group">
                                <label for="stats-view-type">View Type:</label>
                                <select id="stats-view-type" class="form-control">
                                    <option value="success-rate">Success Rate</option>
                                    <option value="sync-count">Sync Count</option>
                                    <option value="errors">Errors</option>
                                </select>
                            </div>
                        </div>
                        <div class="col">
                            <div class="form-group">
                                <label for="stats-project-filter">Filter by Project:</label>
                                <div class="project-filter-container" style="position: relative;">
                                    <div class="selected-projects-display" style="padding: 8px; border: 1px solid #ced4da; border-radius: 4px; background-color: #fff; cursor: pointer; height: 38px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;">
                                        <span id="selected-projects-text">All Projects</span>
                                        <i class="dropdown-icon" style="float: right;">‚ñº</i>
                                    </div>
                                    <div id="project-filter-dropdown" style="display: none; position: absolute; top: 100%; left: 0; width: 100%; max-height: 250px; overflow-y: auto; background-color: #fff; border: 1px solid #ced4da; border-top: none; border-radius: 0 0 4px 4px; z-index: 1000; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
                                        <div style="padding: 8px; border-bottom: 1px solid #eee;">
                                            <label style="margin-bottom: 0; width: 100%;">
                                                <input type="checkbox" id="select-all-projects-filter" style="margin-right: 8px;">
                                                <strong>Select All</strong>
                                            </label>
                                        </div>
                                        <div id="project-filter-list" style="padding: 8px 0;">
                                            <!-- Projects will be populated dynamically as checkboxes -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="row" style="margin-top: 10px;">
                        <div class="col">
                            <button id="apply-stats-filters" class="btn btn-primary btn-sm">Apply Filters</button>
                            <button id="reset-stats-filters" class="btn btn-secondary btn-sm" style="margin-left: 5px;">Reset</button>
                            <button id="drill-up-btn" class="btn btn-info btn-sm" style="margin-left: 5px; display: none;">Back to Summary</button>
                        </div>
                    </div>
                </div>
                
                <!-- Graph container -->
                <canvas id="sync-stats-graph" style="width: 100%; height: 400px;"></canvas>
                
                <!-- Statistics summary -->
                <div id="sync-stats-summary" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee;">
                    <h4>Summary</h4>
                    <div class="row">
                        <div class="col">
                            <div class="stat-box" style="background-color: #f8f9fa; padding: 10px; border-radius: 4px;">
                                <div class="stat-title" style="font-weight: bold; margin-bottom: 5px;">Total Syncs</div>
                                <div id="stat-total-syncs" class="stat-value" style="font-size: 1.5rem; color: #333;">--</div>
                            </div>
                        </div>
                        <div class="col">
                            <div class="stat-box" style="background-color: #f8f9fa; padding: 10px; border-radius: 4px;">
                                <div class="stat-title" style="font-weight: bold; margin-bottom: 5px;">Average Success Rate</div>
                                <div id="stat-avg-success-rate" class="stat-value" style="font-size: 1.5rem; color: #28a745;">--</div>
                            </div>
                        </div>
                        <div class="col">
                            <div class="stat-box" style="background-color: #f8f9fa; padding: 10px; border-radius: 4px;">
                                <div class="stat-title" style="font-weight: bold; margin-bottom: 5px;">Most Common Error</div>
                                <div id="stat-common-error" class="stat-value" style="font-size: 1rem; color: #dc3545;">--</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer>
        JoJo's Shave Ice Management Hub &copy; 2024 | Version 1.0.0
    </footer>
    
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script>
        // Initialize Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyCgEDfRBjbqqnwWc0TeR97V3RvfrvjJu1U",
            authDomain: "jojo-s-app-back-end.firebaseapp.com",
            projectId: "jojo-s-app-back-end",
            storageBucket: "jojo-s-app-back-end.appspot.com",
            messagingSenderId: "344579778389",
            appId: "1:344579778389:web:6a17be1a1d13b82955f1dc",
            measurementId: "G-VBP44WBTCP"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        
        document.addEventListener('DOMContentLoaded', function() {
            // Debug function to explore Firestore collections
            function exploreFirestoreCollections() {
                console.log("Exploring Firestore collections...");

                // Map all collections we need to check
                const collections = [
                    'asana_projects',
                    'asana_tasks',
                    'asana_sync_logs',
                    'asana_change_logs',
                    'asana_workspaces',
                    'asana_config'
                ];

                collections.forEach(collectionName => {
                    db.collection(collectionName).limit(5).get()
                        .then(snapshot => {
                            console.log(`Collection '${collectionName}' exists: ${!snapshot.empty}`);
                            if (!snapshot.empty) {
                                console.log(`Sample document from '${collectionName}':`);
                                const sampleDoc = snapshot.docs[0].data();
                                console.log(sampleDoc);
                            }
                        })
                        .catch(error => {
                            console.log(`Error checking collection '${collectionName}':`, error);
                        });
                });
            }

            // Run the exploration function
            exploreFirestoreCollections();
            
            // Tab navigation setup
            const tabButtons = document.querySelectorAll('.tab-btn');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.getAttribute('data-tab');
                    
                    // Update active tab button
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    
                    // Show active tab content
                    tabContents.forEach(content => content.classList.remove('active'));
                    document.getElementById(tabId).classList.add('active');
                });
            });
            
            // Function to update the connection status in the UI
            function updateConnectionStatus(isConnected) {
                const connectionStatus = document.querySelector('.connection-status');
                const notConnectedWorkspace = document.getElementById('not-connected-workspace');
                const connectedWorkspace = document.getElementById('connected-workspace');
                const notConnectedTasks = document.getElementById('not-connected-tasks');
                const connectedTasks = document.getElementById('connected-tasks');
                const currentConnection = document.getElementById('current-connection');
                const settingsFormContainer = document.getElementById('settings-form-container');
                
                if (isConnected) {
                    // Update status indicator
                    connectionStatus.textContent = 'Connected';
                    connectionStatus.classList.remove('status-disconnected');
                    connectionStatus.classList.add('status-connected');
                    
                    // Update connection notice
                    document.getElementById('connection-notice').innerHTML = `
                        <p>Your Asana account is connected. You can manage synced projects in the Workspace Sync tab.</p>
                    `;
                    
                    // Show connected workspace view
                    if (notConnectedWorkspace) notConnectedWorkspace.style.display = 'none';
                    if (connectedWorkspace) connectedWorkspace.style.display = 'block';
                    
                    // Show connected tasks view
                    if (notConnectedTasks) notConnectedTasks.style.display = 'none';
                    if (connectedTasks) connectedTasks.style.display = 'block';
                    
                    // Show current connection settings and hide the form
                    currentConnection.style.display = 'block';
                    settingsFormContainer.style.display = 'none';
                    
                    // Load workspaces, projects, and logs
                    loadWorkspaces();
                    loadSyncLogs();
                    loadTaskViewerProjects();
                    loadTaskViewerAssignees();
                    loadTasks();
                    
                    // Don't load projects until a workspace is selected
                    const projectList = document.getElementById('project-list');
                    projectList.innerHTML = '<div class="info-box" style="text-align: center; padding: 20px; color: #666;">Please select a workspace to view its projects</div>';
                } else {
                    // Update status indicator
                    connectionStatus.textContent = 'Disconnected';
                    connectionStatus.classList.remove('status-connected');
                    connectionStatus.classList.add('status-disconnected');
                    
                    // Update connection notice
                    document.getElementById('connection-notice').innerHTML = `
                        <p>This tool allows you to synchronize tasks between Asana and JoJo's Shave Ice internal systems. Connect your Asana account to get started.</p>
                    `;
                    
                    // Show disconnected workspace view
                    if (notConnectedWorkspace) notConnectedWorkspace.style.display = 'block';
                    if (connectedWorkspace) connectedWorkspace.style.display = 'none';
                    
                    // Show disconnected tasks view
                    if (notConnectedTasks) notConnectedTasks.style.display = 'block';
                    if (connectedTasks) connectedTasks.style.display = 'none';
                    
                    // Hide current connection settings and show the form
                    currentConnection.style.display = 'none';
                    settingsFormContainer.style.display = 'block';
                }
            }
            
            // Select all projects checkbox
            const selectAllCheckbox = document.getElementById('select-all-projects');
            
            selectAllCheckbox.addEventListener('change', function() {
                const projectCheckboxes = document.querySelectorAll('.project-checkbox');
                projectCheckboxes.forEach(checkbox => {
                    checkbox.checked = selectAllCheckbox.checked;
                });
                
                // Update delete button state
                updateDeleteButtonState();
            });
            
            // Function to update the state of the delete button
            function updateDeleteButtonState() {
                const deleteButton = document.getElementById('delete-projects-btn');
                const selectedCheckboxes = document.querySelectorAll('.project-checkbox:checked');
                deleteButton.disabled = selectedCheckboxes.length === 0;
            }
            
            // Project search functionality
            const projectSearchInput = document.getElementById('project-search');
            projectSearchInput.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase().trim();
                const projectItems = document.querySelectorAll('.project-item');
                
                projectItems.forEach(item => {
                    const projectName = item.querySelector('label').textContent.toLowerCase();
                    if (searchTerm === '' || projectName.includes(searchTerm)) {
                        item.style.display = 'block';
                    } else {
                        item.style.display = 'none';
                    }
                });
            });
            
            // Delete projects button
            const deleteProjectsBtn = document.getElementById('delete-projects-btn');
            deleteProjectsBtn.addEventListener('click', function() {
                const selectedProjects = Array.from(document.querySelectorAll('.project-checkbox:checked'))
                    .map(checkbox => {
                        return {
                            id: checkbox.value,
                            name: checkbox.closest('label').textContent.trim()
                        };
                    });
                
                if (selectedProjects.length === 0) {
                    alert('Please select at least one project to delete');
                    return;
                }
                
                // Show confirmation dialog with list of projects
                const projectList = selectedProjects.map(p => `- ${p.name}`).join('\n');
                const confirmMsg = `Are you sure you want to delete these ${selectedProjects.length} projects?\n\n${projectList}\n\nThis action cannot be undone and will remove projects from your Asana account.`;
                
                if (confirm(confirmMsg)) {
                    // Show loading state
                    deleteProjectsBtn.disabled = true;
                    deleteProjectsBtn.textContent = 'Deleting...';
                    
                    // Track success/failure
                    let successCount = 0;
                    let errorCount = 0;
                    const errors = [];
                    
                    // Process each project deletion
                    const projectPromises = selectedProjects.map(project => {
                        // Remove project from database
                        return db.collection('asana_projects').doc(project.id).delete()
                            .then(() => {
                                console.log(`Project ${project.name} (${project.id}) deleted from database`);
                                successCount++;
                                
                                // Optional: Also delete related tasks
                                return db.collection('asana_tasks')
                                    .where('projectId', '==', project.id)
                                    .get()
                                    .then(snapshot => {
                                        const batch = db.batch();
                                        snapshot.forEach(doc => batch.delete(doc.ref));
                                        if (snapshot.size > 0) {
                                            return batch.commit();
                                        }
                                    });
                            })
                            .catch(error => {
                                console.error(`Error deleting project ${project.name}:`, error);
                                errorCount++;
                                errors.push(`${project.name}: ${error.message}`);
                            });
                    });
                    
                    // Wait for all projects to be processed
                    Promise.all(projectPromises)
                        .then(() => {
                            // Log the deletion
                            return db.collection('asana_sync_logs').add({
                                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                                projects: selectedProjects.map(p => p.id),
                                projectNames: selectedProjects.reduce((obj, p) => {
                                    obj[p.id] = p.name;
                                    return obj;
                                }, {}),
                                project_count: selectedProjects.length,
                                status: 'completed',
                                message: `Deleted ${successCount} projects (${errorCount} failed)`,
                                success_count: successCount,
                                error_count: errorCount,
                                errors: errors,
                                details: {
                                    action: 'delete',
                                    initiated_by: 'manual',
                                    initiated_at: firebase.firestore.FieldValue.serverTimestamp()
                                }
                            });
                        })
                        .then(() => {
                            // Reset button state
                            deleteProjectsBtn.disabled = true;
                            deleteProjectsBtn.textContent = 'Delete Selected Projects';
                            
                            // Show result message
                            if (errorCount > 0) {
                                alert(`Deleted ${successCount} projects with ${errorCount} errors. See console for details.`);
                } else {
                                alert(`Successfully deleted ${successCount} projects`);
                            }
                            
                            // Reload projects list
                            loadProjects();
                        })
                        .catch(error => {
                            console.error('Error during project deletion:', error);
                            deleteProjectsBtn.disabled = false;
                            deleteProjectsBtn.textContent = 'Delete Selected Projects';
                            alert(`Error during project deletion: ${error.message}`);
                        });
                }
            });
            
            // Add change event listeners to project checkboxes after they're loaded
            function addCheckboxEventListeners() {
                const projectCheckboxes = document.querySelectorAll('.project-checkbox');
                projectCheckboxes.forEach(checkbox => {
                    checkbox.addEventListener('change', updateDeleteButtonState);
                });
            }
            
            // Force sync button
            const forceSyncBtn = document.getElementById('force-sync-btn');
            forceSyncBtn.addEventListener('click', function() {
                const selectedProjects = Array.from(document.querySelectorAll('.project-checkbox:checked'))
                    .map(checkbox => checkbox.value);
                
                if (selectedProjects.length === 0) {
                    alert('Please select at least one project to sync');
                    return;
                }
                
                alert(`Starting sync for ${selectedProjects.length} projects...`);
                
                // Collect project names for better logging
                const projectNames = {};
                document.querySelectorAll('.project-checkbox:checked').forEach(checkbox => {
                    const projectName = checkbox.closest('label').textContent.trim();
                    projectNames[checkbox.value] = projectName;
                });
                
                // Create project stats object with initial status
                const projectStats = {};
                selectedProjects.forEach(projectId => {
                    projectStats[projectId] = {
                        status: 'started',
                        name: projectNames[projectId] || projectId,
                        start_time: firebase.firestore.FieldValue.serverTimestamp()
                    };
                });
                
                // Update last sync time in the UI
                const now = new Date();
                const formattedDate = now.toLocaleString();
                document.getElementById('last-sync-time').textContent = `Last sync: ${formattedDate}`;
                
                // Add a new log entry to the UI
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                logEntry.innerHTML = `
                    <div class="log-time">${formattedDate}</div>
                    <div class="log-message log-info">
                        <strong>Started:</strong> Started manual sync for ${selectedProjects.length} projects
                        <button class="toggle-details" style="background: none; border: none; padding: 0; font-size: 0.8rem; text-decoration: underline; cursor: pointer; color: #666;">Show details</button>
                    </div>
                    <div class="log-details" style="display: none; margin-top: 5px; font-size: 0.85rem; background-color: #f5f5f5; padding: 8px; border-radius: 4px;">
                        <h4 style="margin: 0 0 5px 0; font-size: 0.9rem;">Projects:</h4>
                        <ul style="margin: 0; padding-left: 20px;">
                            ${selectedProjects.map(projectId => `<li>${projectNames[projectId] || projectId}</li>`).join('')}
                        </ul>
                    </div>
                `;
                
                const historyLog = document.getElementById('history-log');
                historyLog.insertBefore(logEntry, historyLog.firstChild);
                
                // Add event listener to toggle details
                const toggleButton = logEntry.querySelector('.toggle-details');
                const detailsSection = logEntry.querySelector('.log-details');
                
                toggleButton.addEventListener('click', function() {
                    if (detailsSection.style.display === 'none') {
                        detailsSection.style.display = 'block';
                        toggleButton.textContent = 'Hide details';
                    } else {
                        detailsSection.style.display = 'none';
                        toggleButton.textContent = 'Show details';
                    }
                });
                
                // Update the lastSync time in Firestore
                db.collection('asana_config').doc('settings').update({
                    last_sync: firebase.firestore.FieldValue.serverTimestamp(),
                    sync_count: firebase.firestore.FieldValue.increment(1)
                })
                .then(() => {
                    console.log('Sync time updated in asana_config');
                })
                .catch((error) => {
                    console.error('Error updating sync time:', error);
                });
            
                // Add a detailed log entry to Firestore
                db.collection('asana_sync_logs').add({
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    projects: selectedProjects,
                    projectNames: projectNames,
                    project_count: selectedProjects.length,
                    status: 'started',
                    message: `Started manual sync for ${selectedProjects.length} projects`,
                    projectStats: projectStats,
                    details: {
                        initiated_by: 'manual',
                        initiated_at: firebase.firestore.FieldValue.serverTimestamp()
                    }
                })
                .then((docRef) => {
                    console.log('Sync log added to asana_sync_logs with ID:', docRef.id);
                    
                    // Simulate updating project statuses with success/error for demonstration
                    setTimeout(() => {
                        // Create updated project stats with random success/errors
                        const updatedProjectStats = {};
                        let successCount = 0;
                        let taskCount = 0;
                        
                        selectedProjects.forEach(projectId => {
                            // 80% chance of success, 20% chance of error
                            const isSuccess = Math.random() < 0.8;
                            const tasks = Math.floor(Math.random() * 20) + 1; // 1-20 tasks
                            
                            if (isSuccess) {
                                successCount++;
                                taskCount += tasks;
                                updatedProjectStats[projectId] = {
                                    status: 'success',
                                    name: projectNames[projectId] || projectId,
                                    tasks_synced: tasks,
                                    completion_time: firebase.firestore.FieldValue.serverTimestamp()
                                };
                            } else {
                                const errors = [
                                    'API rate limit exceeded',
                                    'Task not found',
                                    'Permission denied',
                                    'Network error',
                                    'Invalid resource reference'
                                ];
                                const randomError = errors[Math.floor(Math.random() * errors.length)];
                                
                                updatedProjectStats[projectId] = {
                                    status: 'error',
                                    name: projectNames[projectId] || projectId,
                                    error: randomError,
                                    completion_time: firebase.firestore.FieldValue.serverTimestamp()
                                };
                            }
                        });
                        
                        // Update the sync log with completion details
                        db.collection('asana_sync_logs').doc(docRef.id).update({
                            status: 'completed',
                            message: `Completed sync of ${selectedProjects.length} projects with ${successCount} successful`,
                            projectStats: updatedProjectStats,
                            success_count: successCount,
                            task_count: taskCount,
                            completion_time: firebase.firestore.FieldValue.serverTimestamp()
                        })
                        .then(() => {
                            console.log('Updated sync log with completion details');
                            // Reload sync logs to show the updated status
                            loadSyncLogs();
                        })
                        .catch(error => {
                            console.error('Error updating sync log:', error);
                        });
                    }, 3000); // Simulate 3 second sync process
                })
                .catch((error) => {
                    console.error('Error adding sync log:', error);
                });
            });
            
            // Function to load workspaces from Firestore
            function loadWorkspaces() {
                const workspaceSelect = document.getElementById('workspace-select');
                
                console.log('Loading workspaces from asana_workspaces collection...');
                    
                // Get workspaces directly from the asana_workspaces collection
                db.collection('asana_workspaces').get()
                    .then(snapshot => {
                        console.log(`Found ${snapshot.size} workspaces in asana_workspaces collection`);
                        
                        if (!snapshot.empty) {
                            workspaceSelect.innerHTML = '<option value="">-- Select a workspace --</option>';
                            snapshot.forEach(doc => {
                                const workspace = doc.data();
                                console.log('Workspace data:', workspace);
                                
                                // Use gid as the primary ID for workspaces
                                const gid = workspace.gid || doc.id;
                                const name = workspace.name || 'Unnamed Workspace';
                                
                                const option = document.createElement('option');
                                option.value = gid;
                                option.textContent = name;
                                workspaceSelect.appendChild(option);
                            });
                            console.log('Loaded workspaces successfully');
                        } else {
                            console.log('No workspaces found in asana_workspaces collection');
                            
                            // If no workspaces in the collection, check if we have workspace info in asana_config
                            db.collection('asana_config').doc('settings').get()
                                .then(doc => {
                                    if (doc.exists) {
                                        const data = doc.data();
                                        console.log('Checking asana_config for workspace info:', data);
                                        
                                        // Check various possible field names for workspace info
                                        const workspaceId = data.defaultWorkspaceGid || data.defaultWorkspaceId || 
                                                        data.default_workspace_gid || data.default_workspace_id;
                                        const workspaceName = data.defaultWorkspaceName || data.default_workspace_name || 'Default Workspace';
                                        
                                        if (workspaceId) {
                                            console.log(`Found workspace in asana_config: ${workspaceId} (${workspaceName})`);
                                            
                                            workspaceSelect.innerHTML = '<option value="">-- Select a workspace --</option>';
                                            const option = document.createElement('option');
                                            option.value = workspaceId;
                                            option.textContent = workspaceName;
                                            workspaceSelect.appendChild(option);
                                        } else {
                                            workspaceSelect.innerHTML = '<option value="">No workspaces available</option>';
                                        }
                                    } else {
                                        workspaceSelect.innerHTML = '<option value="">No workspaces available</option>';
                                    }
                                })
                                .catch(error => {
                                    console.error('Error checking asana_config for workspace info:', error);
                                    workspaceSelect.innerHTML = '<option value="">No workspaces available</option>';
                                });
                        }
                    })
                    .catch(error => {
                        console.error('Error loading workspaces:', error);
                        workspaceSelect.innerHTML = '<option value="">Error loading workspaces</option>';
                    });
            }
            
            // Function to load projects from Firestore
            function loadProjects() {
                const projectList = document.getElementById('project-list');
                projectList.innerHTML = '<div class="loading-indicator">Loading projects...</div>';
                
                console.log('Loading projects from asana_projects collection...');
                
                db.collection('asana_projects').get()
                    .then(snapshot => {
                        console.log(`Found ${snapshot.size} projects in asana_projects collection`);
                        
                        if (!snapshot.empty) {
                            projectList.innerHTML = '';
                            
                            snapshot.forEach(doc => {
                                const project = doc.data();
                                console.log('Project data:', project);
                                
                                // Normalize project data to handle different naming conventions
                                const normalizedProject = {
                                    id: doc.id,
                                    name: project.name,
                                    archived: project.archived || project.isArchived || false,
                                    workspace: project.workspace || project.workspaceData || {},
                                    updated_at: project.updated_at || project.updatedAt,
                                    created_at: project.created_at || project.createdAt
                                };
                                
                                // Skip archived projects
                                if (normalizedProject.archived) {
                                    return;
                                }
                                
                                const projectItem = document.createElement('div');
                                projectItem.className = 'project-item';
                                
                                // Format the last update date
                                let lastUpdate = 'Never';
                                if (normalizedProject.updated_at) {
                                    const updateDate = normalizedProject.updated_at.toDate ? 
                                        normalizedProject.updated_at.toDate() : 
                                        new Date(normalizedProject.updated_at);
                                    lastUpdate = updateDate.toLocaleDateString();
                                }
                                
                                // Add project to the list without waiting for task count
                                projectItem.innerHTML = `
                                    <label>
                                        <input type="checkbox" class="project-checkbox" value="${normalizedProject.id}">
                                        ${normalizedProject.name || 'Unnamed Project'}
                                    </label>
                                    <div class="project-stats">
                                        Last update: ${lastUpdate}
                        </div>
                    `;
                                projectList.appendChild(projectItem);
                                
                                // Get task count in the background and update later
                                db.collection('asana_tasks')
                                    .where('projectId', '==', doc.id)
                                    .get()
                                    .then(taskSnapshot => {
                                        const totalTasks = taskSnapshot.size;
                                        const completedTasks = taskSnapshot.docs.filter(d => {
                                            const taskData = d.data();
                                            return taskData.completed || taskData.isCompleted;
                                        }).length;
                                        
                                        // Update the project stats with task count
                                        const statsDiv = projectItem.querySelector('.project-stats');
                                        statsDiv.innerHTML = `
                                            Tasks: ${completedTasks}/${totalTasks} completed | Last update: ${lastUpdate}
                                        `;
                                    })
                                    .catch(error => {
                                        console.error('Error counting tasks for project ' + doc.id + ':', error);
                                    });
                            });
                            
                            console.log('Loaded projects successfully');
                            
                            // Add event listeners to project checkboxes
                            updateProjectList();
                } else {
                            projectList.innerHTML = '<div class="empty-state">No projects found. Check your Asana connection or add projects.</div>';
                        }
                    })
                    .catch(error => {
                        console.error('Error loading projects:', error);
                        projectList.innerHTML = '<div class="error-state">Error loading projects: ' + error.message + '</div>';
                    });
            }
            
            // Function to load sync logs from Firestore
            function loadSyncLogs() {
                const historyLog = document.getElementById('history-log');
                historyLog.innerHTML = '<div class="loading-indicator">Loading sync history...</div>';
                
                db.collection('asana_sync_logs')
                    .orderBy('timestamp', 'desc')
                    .limit(10)
                    .get()
                    .then(snapshot => {
                        if (!snapshot.empty) {
                            historyLog.innerHTML = '';
                            
                            snapshot.forEach(doc => {
                                const syncLog = doc.data();
                                const logEntry = document.createElement('div');
                                logEntry.className = 'log-entry';
                                
                                // Format the timestamp
                                let timeString = 'Unknown';
                                if (syncLog.timestamp) {
                                    const logDate = syncLog.timestamp.toDate ? syncLog.timestamp.toDate() : new Date(syncLog.timestamp);
                                    timeString = logDate.toLocaleString();
                                }
                                
                                // Determine status class
                                let statusClass = 'log-success';
                                let overallStatus = 'Success';
                                if (syncLog.errors && syncLog.errors.length > 0) {
                                    statusClass = 'log-error';
                                    overallStatus = 'Error';
                                } else if (syncLog.warnings && syncLog.warnings.length > 0) {
                                    statusClass = 'log-warning';
                                    overallStatus = 'Warning';
                                } else if (syncLog.status === 'error') {
                                    statusClass = 'log-error';
                                    overallStatus = 'Error';
                                } else if (syncLog.status === 'warning') {
                                    statusClass = 'log-warning';
                                    overallStatus = 'Warning';
                                } else if (syncLog.status === 'started') {
                                    statusClass = 'log-info';
                                    overallStatus = 'Started';
                                }
                                
                                // Calculate success rate if available
                                let successRate = '';
                                if (syncLog.projectStats) {
                                    const totalProjects = Object.keys(syncLog.projectStats).length;
                                    const successfulProjects = Object.values(syncLog.projectStats).filter(stat => stat.status === 'success').length;
                                    successRate = ` (${successfulProjects}/${totalProjects} projects successful, ${Math.round((successfulProjects/totalProjects)*100)}% success rate)`;
                                } else if (syncLog.success_count && syncLog.project_count) {
                                    successRate = ` (${syncLog.success_count}/${syncLog.project_count} projects successful, ${Math.round((syncLog.success_count/syncLog.project_count)*100)}% success rate)`;
                                }
                                
                                // Create message based on available data
                                let message = syncLog.message || 'Sync completed';
                                if (!syncLog.message) {
                                    if (syncLog.project_count || syncLog.projects) {
                                        const count = syncLog.project_count || (syncLog.projects ? syncLog.projects.length : 0);
                                        message = `Synced ${count} projects`;
                                    }
                                    if (syncLog.task_count) {
                                        message += `, ${syncLog.task_count} tasks`;
                                    }
                                }
                                
                                // Build the log entry header
                                let logContent = `
                                    <div class="log-time">${timeString}</div>
                                    <div class="log-message ${statusClass}">
                                        <strong>${overallStatus}:</strong> ${message}${successRate}
                                        <button class="toggle-details" style="background: none; border: none; padding: 0; font-size: 0.8rem; text-decoration: underline; cursor: pointer; color: #666;">Show details</button>
                        </div>
                                    <div class="log-details" style="display: none; margin-top: 5px; font-size: 0.85rem; background-color: #f5f5f5; padding: 8px; border-radius: 4px;">
                                `;
                                
                                // Add detailed project information if available
                                if (syncLog.projectStats) {
                                    logContent += '<h4 style="margin: 0 0 5px 0; font-size: 0.9rem;">Project Details:</h4><ul style="margin: 0; padding-left: 20px;">';
                                    
                                    Object.entries(syncLog.projectStats).forEach(([projectId, stats]) => {
                                        const projectStatus = stats.status || 'unknown';
                                        const projectStatusClass = projectStatus === 'success' ? 'log-success' : 
                                                                  projectStatus === 'error' ? 'log-error' : 'log-warning';
                                        
                                        logContent += `<li style="margin-bottom: 3px;"><span class="${projectStatusClass}" style="font-weight: bold;">${projectStatus.toUpperCase()}</span>: ${stats.name || projectId}`;
                                        
                                        if (stats.tasks_synced !== undefined) {
                                            logContent += ` (${stats.tasks_synced} tasks synced)`;
                                        }
                                        
                                        if (stats.error) {
                                            logContent += ` - Error: ${stats.error}`;
                                        }
                                        
                                        logContent += '</li>';
                                    });
                                    
                                    logContent += '</ul>';
                                } else if (syncLog.projects) {
                                    // If we only have project IDs without status
                                    logContent += '<h4 style="margin: 0 0 5px 0; font-size: 0.9rem;">Projects:</h4><ul style="margin: 0; padding-left: 20px;">';
                                    
                                    syncLog.projects.forEach(projectId => {
                                        // Try to get project name from a reference map
                                        const projectName = syncLog.projectNames && syncLog.projectNames[projectId] ? 
                                                         syncLog.projectNames[projectId] : projectId;
                                        
                                        logContent += `<li>${projectName}</li>`;
                                    });
                                    
                                    logContent += '</ul>';
                                }
                                
                                // Add errors if available
                                if (syncLog.errors && syncLog.errors.length > 0) {
                                    logContent += '<h4 style="margin: 5px 0; font-size: 0.9rem;">Errors:</h4><ul style="margin: 0; padding-left: 20px;">';
                                    
                                    syncLog.errors.forEach(error => {
                                        logContent += `<li class="log-error">${error}</li>`;
                                    });
                                    
                                    logContent += '</ul>';
                                }
                                
                                // Add warnings if available
                                if (syncLog.warnings && syncLog.warnings.length > 0) {
                                    logContent += '<h4 style="margin: 5px 0; font-size: 0.9rem;">Warnings:</h4><ul style="margin: 0; padding-left: 20px;">';
                                    
                                    syncLog.warnings.forEach(warning => {
                                        logContent += `<li class="log-warning">${warning}</li>`;
                                    });
                                    
                                    logContent += '</ul>';
                                }
                                
                                // Close the log details div
                                logContent += '</div>';
                                
                                logEntry.innerHTML = logContent;
                                historyLog.appendChild(logEntry);
                                
                                // Add event listener to toggle details
                                const toggleButton = logEntry.querySelector('.toggle-details');
                                const detailsSection = logEntry.querySelector('.log-details');
                                
                                toggleButton.addEventListener('click', function() {
                                    if (detailsSection.style.display === 'none') {
                                        detailsSection.style.display = 'block';
                                        toggleButton.textContent = 'Hide details';
                                    } else {
                                        detailsSection.style.display = 'none';
                                        toggleButton.textContent = 'Show details';
                                    }
                                });
                            });
                            
                            console.log('Loaded sync logs');
                            
                            // Update last sync time from asana_config
                            db.collection('asana_config').doc('settings').get()
                                .then(doc => {
                                    if (doc.exists && doc.data().last_sync) {
                                        const lastSync = doc.data().last_sync;
                                        const lastSyncDate = lastSync.toDate ? lastSync.toDate() : new Date(lastSync);
                                        document.getElementById('last-sync-time').textContent = `Last sync: ${lastSyncDate.toLocaleString()}`;
                                    }
                                })
                                .catch(error => {
                                    console.error('Error loading last sync time:', error);
                                });
                        } else {
                            historyLog.innerHTML = '<div class="empty-state">No sync history found</div>';
                        }
                    })
                    .catch(error => {
                        console.error('Error loading sync logs:', error);
                        historyLog.innerHTML = '<div class="error-state">Error loading sync history</div>';
                    });
            }
            
            // Check if connection is established from Firestore
            function checkConnectionStatus() {
                console.log("Checking connection status...");
                
                // First, check if the asana_config collection exists
                db.collection('asana_config').get()
                    .then(snapshot => {
                        console.log(`asana_config collection exists: ${!snapshot.empty}`);
                        console.log(`Found ${snapshot.size} documents in asana_config`);
                        
                        if (!snapshot.empty) {
                            snapshot.forEach(doc => {
                                console.log(`Document ID: ${doc.id}, data:`, doc.data());
                            });
                        }
                        
                        // Now check for the settings document specifically
                        return db.collection('asana_config').doc('settings').get();
                    })
                    .then((doc) => {
                        console.log(`Settings document exists: ${doc.exists}`);
                        if (doc.exists && (doc.data().personal_access_token || doc.data().personalAccessToken)) {
                            const data = doc.data();
                            
                            // Create a normalized data object that works with both naming conventions
                            const normalizedData = {
                                personal_access_token: data.personal_access_token || data.personalAccessToken,
                                sync_frequency: data.sync_frequency || data.syncFrequency || (data.syncFrequency === '5min' ? 5 : 60),
                                last_sync: data.last_sync || data.lastSync || data.lastFullSyncTimestamp,
                                updated_at: data.updated_at || data.updatedAt,
                                active: data.active || data.syncEnabled || true
                            };
                            
                            // Log the normalized data for debugging
                            console.log('Normalized settings data:', normalizedData);
                            
                            // Update the current connection display
                            updateConnectionDisplay(normalizedData);
                            
                            // Load saved settings into form fields (for editing)
                            document.getElementById('asana-pat').value = normalizedData.personal_access_token;
                            
                            // Set the frequency dropdown to the saved value
                            if (normalizedData.sync_frequency) {
                                const syncFrequencySelect = document.getElementById('sync-frequency');
                                const options = syncFrequencySelect.options;
                                for (let i = 0; i < options.length; i++) {
                                    if (parseInt(options[i].value) === normalizedData.sync_frequency) {
                                        syncFrequencySelect.selectedIndex = i;
                                        break;
                                    }
                                }
                            }
                            
                            console.log('Loaded existing settings from asana_config');
                            updateConnectionStatus(true);
                            
                            // Initialize auto-sync
                            afterConnectionEstablished();
                        } else if (doc.exists) {
                            // Check if token exists under different field names
                            const data = doc.data();
                            console.log('Checking for alternative token field names in:', data);
                            
                            if (data.pat || data.token || data.asanaToken || data.asana_token) {
                                // Found token with different field name, update to standard format
                                const token = data.pat || data.token || data.asanaToken || data.asana_token;
                                console.log(`Found token with alternative field name: ${token.substring(0, 4)}...`);
                                
                                // Update to standard format
                                const newData = {
                                    personal_access_token: token,
                                    sync_frequency: data.sync_frequency || data.syncFrequency || 60,
                                    updated_at: firebase.firestore.FieldValue.serverTimestamp(),
                                    active: true
                                };
                                
                                db.collection('asana_config').doc('settings').set(newData, { merge: true })
                                    .then(() => {
                                        console.log('Updated token field name to standard format');
                                        // Reload with new settings
                                        checkConnectionStatus();
                                    })
                                    .catch(error => {
                                        console.error('Error updating token field name:', error);
                                        updateConnectionStatus(false);
                                    });
                } else {
                                console.log('No valid settings found with any token field names');
                                
                                // Check if there's an "asana_config" document at the root level for legacy data
                                db.collection('asana_config').doc('asana_config').get()
                                    .then(legacyDoc => {
                                        if (legacyDoc.exists && legacyDoc.data().settings && legacyDoc.data().settings.pat) {
                                            console.log('Found legacy settings structure:', legacyDoc.data());
                                            
                                            // Migrate legacy data to new format
                                            const legacyData = legacyDoc.data();
                                            const newData = {
                                                personal_access_token: legacyData.settings.pat,
                                                sync_frequency: legacyData.settings.sync_frequency || 60,
                                                updated_at: firebase.firestore.FieldValue.serverTimestamp(),
                                                active: true
                                            };
                                            
                                            // Update to new format
                                            db.collection('asana_config').doc('settings').set(newData)
                                                .then(() => {
                                                    console.log('Migrated legacy settings to new format');
                                                    // Reload to use the new settings
                                                    checkConnectionStatus();
                                                })
                                                .catch(error => {
                                                    console.error('Error migrating settings:', error);
                                                    updateConnectionStatus(false);
                                                });
                                        } else {
                                            updateConnectionStatus(false);
                                        }
                                    })
                                    .catch(error => {
                                        console.error('Error checking legacy asana_config:', error);
                                        updateConnectionStatus(false);
                                    });
                            }
                        }
                    })
                    .catch((error) => {
                        console.error('Error checking connection status:', error);
                        updateConnectionStatus(false);
                    });
            }

            // Function to update the current connection display
            function updateConnectionDisplay(data) {
                // Display partial token (first 4 chars + last 4 chars, rest are hidden)
                const token = data.personal_access_token;
                let tokenDisplay = '';
                if (token && token.length > 8) {
                    tokenDisplay = token.substring(0, 4) + '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' + token.substring(token.length - 4);
                } else if (token) {
                    tokenDisplay = token.substring(0, 2) + '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                }
                document.getElementById('current-token').textContent = tokenDisplay;
                
                // Display sync frequency in human-readable format
                let frequencyDisplay = 'Every hour';
                if (data.sync_frequency) {
                    let freq = data.sync_frequency;
                    
                    // Handle string values like '5min'
                    if (typeof freq === 'string') {
                        if (freq === '5min') freq = 5;
                        else if (freq === '15min') freq = 15;
                        else if (freq === '30min') freq = 30;
                        else if (freq === '1hour') freq = 60;
                        else if (freq === '6hours') freq = 360;
                        else if (freq === '12hours') freq = 720;
                        else if (freq === '1day') freq = 1440;
                        else freq = parseInt(freq) || 60;
                    }
                    
                    // Convert to number to ensure correct comparison
                    freq = parseInt(freq);
                    
                    if (freq === 5) frequencyDisplay = 'Every 5 minutes';
                    else if (freq === 15) frequencyDisplay = 'Every 15 minutes';
                    else if (freq === 30) frequencyDisplay = 'Every 30 minutes';
                    else if (freq === 60) frequencyDisplay = 'Every hour';
                    else if (freq === 360) frequencyDisplay = 'Every 6 hours';
                    else if (freq === 720) frequencyDisplay = 'Every 12 hours';
                    else if (freq === 1440) frequencyDisplay = 'Once a day';
                    else frequencyDisplay = `Every ${freq} minutes`;
                }
                document.getElementById('current-frequency').textContent = frequencyDisplay;
                
                // Display last sync time
                let lastSyncDisplay = 'Never';
                if (data.last_sync) {
                    const lastSync = data.last_sync.toDate ? data.last_sync.toDate() : new Date(data.last_sync);
                    lastSyncDisplay = lastSync.toLocaleString();
                }
                document.getElementById('current-last-sync').textContent = lastSyncDisplay;
            }
            
            // Called when DOM is loaded - add all event listeners and initialization
            checkConnectionStatus();
            
            // Edit settings button
            document.getElementById('edit-settings').addEventListener('click', function() {
                document.getElementById('current-connection').style.display = 'none';
                document.getElementById('settings-form-container').style.display = 'block';
                document.getElementById('cancel-edit').style.display = 'inline-block';
            });
            
            // Clear settings button
            document.getElementById('clear-settings').addEventListener('click', function() {
                if (confirm('Are you sure you want to clear all connection settings? This will disconnect your Asana integration.')) {
                    document.getElementById('asana-pat').value = '';
                    document.getElementById('sync-frequency').value = '60';
                    document.getElementById('current-connection').style.display = 'none';
                    document.getElementById('settings-form-container').style.display = 'block';
                    
                    // Clear settings in Firestore
                    db.collection('asana_config').doc('settings').update({
                        personal_access_token: firebase.firestore.FieldValue.delete(),
                        active: false,
                        updated_at: firebase.firestore.FieldValue.serverTimestamp()
                    })
                    .then(() => {
                        console.log('Connection settings cleared');
                        alert('Connection settings cleared successfully');
                        updateConnectionStatus(false);
                    })
                    .catch((error) => {
                        console.error('Error clearing settings:', error);
                        alert(`Error clearing settings: ${error.message}`);
                    });
                }
            });
            
            // Cancel edit button
            document.getElementById('cancel-edit').addEventListener('click', function() {
                document.getElementById('current-connection').style.display = 'block';
                document.getElementById('settings-form-container').style.display = 'none';
                document.getElementById('cancel-edit').style.display = 'none';
                
                // Reset form to current values
                checkConnectionStatus();
            });
            
            // Add event listener for workspace selection
            document.getElementById('workspace-select').addEventListener('change', function() {
                const workspaceId = this.value;
                const workspaceName = this.options[this.selectedIndex].text;
                
                console.log(`Selected workspace: ${workspaceName} (${workspaceId})`);
                
                const projectList = document.getElementById('project-list');
                
                if (workspaceId) {
                    // If a workspace is selected, filter projects by this workspace
                    loadProjectsByWorkspace(workspaceId);
                } else {
                    // If no workspace is selected, show message prompting to select a workspace
                    projectList.innerHTML = '<div class="info-box" style="text-align: center; padding: 20px; color: #666;">Please select a workspace to view its projects</div>';
                    
                    // Reset delete button and search
                    document.getElementById('delete-projects-btn').disabled = true;
                    document.getElementById('project-search').value = '';
                }
            });
            
            // Function to load projects filtered by workspace
            function loadProjectsByWorkspace(workspaceId) {
                const projectList = document.getElementById('project-list');
                projectList.innerHTML = '<div class="loading-indicator">Loading projects for workspace...</div>';
                
                console.log(`Loading projects for workspace GID ${workspaceId}...`);
                
                // Direct query using the correct field name workspaceGid
                db.collection('asana_projects')
                    .where('workspaceGid', '==', workspaceId)
                    .get()
                    .then(snapshot => {
                        console.log(`Direct query found ${snapshot.size} projects for workspace ${workspaceId} using workspaceGid field`);
                        
                        if (!snapshot.empty) {
                            projectList.innerHTML = '';
                            
                            snapshot.forEach(doc => {
                                const project = doc.data();
                                console.log('Project data:', project);
                                
                                // Skip archived projects if needed
                                if (project.archived === true) {
                    return;
                }
                
                                const projectItem = document.createElement('div');
                                projectItem.className = 'project-item';
                                
                                // Format the last update date
                                let lastUpdate = 'Never';
                                if (project.updated_at) {
                                    const updateDate = project.updated_at.toDate ? 
                                        project.updated_at.toDate() : 
                                        new Date(project.updated_at);
                                    lastUpdate = updateDate.toLocaleDateString();
                                }
                                
                                // Add project to the list without waiting for task count
                                projectItem.innerHTML = `
                                    <label>
                                        <input type="checkbox" class="project-checkbox" value="${doc.id}">
                                        ${project.name || 'Unnamed Project'}
                                    </label>
                                    <div class="project-stats">
                                        Last update: ${lastUpdate}
                    </div>
                `;
                                projectList.appendChild(projectItem);
                                
                                // Get task count in the background and update later
                                db.collection('asana_tasks')
                                    .where('projectId', '==', doc.id)
                                    .get()
                                    .then(taskSnapshot => {
                                        const totalTasks = taskSnapshot.size;
                                        const completedTasks = taskSnapshot.docs.filter(d => {
                                            const taskData = d.data();
                                            return taskData.completed === true;
                                        }).length;
                                        
                                        // Update the project stats with task count
                                        const statsDiv = projectItem.querySelector('.project-stats');
                                        statsDiv.innerHTML = `
                                            Tasks: ${completedTasks}/${totalTasks} completed | Last update: ${lastUpdate}
                                        `;
                                    })
                                    .catch(error => {
                                        console.error('Error counting tasks for project ' + doc.id + ':', error);
                                    });
                            });
                            
                            // Call updateProjectList after projects are loaded
                            updateProjectList();
                        } else {
                            console.log("No projects found with workspaceGid, showing example of first few projects:");
                            
                            // Show examples of the actual data structure
                            db.collection('asana_projects').limit(3).get()
                                .then(sampleSnapshot => {
                                    if (!sampleSnapshot.empty) {
                                        console.log("Sample project data structure:");
                                        sampleSnapshot.forEach(doc => {
                                            console.log("Project:", doc.data());
                                        });
                                    }
                                    
                                    projectList.innerHTML = '<div class="empty-state">No projects found for this workspace.</div>';
                                })
                                .catch(error => {
                                    projectList.innerHTML = '<div class="empty-state">No projects found for this workspace.</div>';
                                });
                        }
                    })
                    .catch(error => {
                        console.error('Error loading projects by workspace:', error);
                        projectList.innerHTML = '<div class="error-state">Error loading projects: ' + error.message + '</div>';
                    });
            }
            
            // Load more log entries
            document.getElementById('load-more-logs').addEventListener('click', function() {
                const historyLog = document.getElementById('history-log');
                const logEntries = historyLog.querySelectorAll('.log-entry');
                const lastEntry = logEntries[logEntries.length - 1];
                
                if (lastEntry) {
                    // Get the timestamp of the last entry
                    const timeString = lastEntry.querySelector('.log-time').textContent;
                    const lastTime = new Date(timeString);
                    
                    // Load more logs older than this timestamp
                    db.collection('asana_sync_logs')
                    .orderBy('timestamp', 'desc')
                        .startAfter(firebase.firestore.Timestamp.fromDate(lastTime))
                    .limit(10)
                        .get()
                        .then(snapshot => {
                            if (!snapshot.empty) {
                                snapshot.forEach(doc => {
                                    const syncLog = doc.data();
                                    const logEntry = document.createElement('div');
                                    logEntry.className = 'log-entry';
                                    
                                    // Format the timestamp
                                    let timeString = 'Unknown';
                                    if (syncLog.timestamp) {
                                        const logDate = syncLog.timestamp.toDate ? syncLog.timestamp.toDate() : new Date(syncLog.timestamp);
                                        timeString = logDate.toLocaleString();
                                    }
                                    
                                    // Determine status class
                                    let statusClass = 'log-success';
                                    let overallStatus = 'Success';
                                    if (syncLog.errors && syncLog.errors.length > 0) {
                                        statusClass = 'log-error';
                                        overallStatus = 'Error';
                                    } else if (syncLog.warnings && syncLog.warnings.length > 0) {
                                        statusClass = 'log-warning';
                                        overallStatus = 'Warning';
                                    } else if (syncLog.status === 'error') {
                                        statusClass = 'log-error';
                                        overallStatus = 'Error';
                                    } else if (syncLog.status === 'warning') {
                                        statusClass = 'log-warning';
                                        overallStatus = 'Warning';
                                    } else if (syncLog.status === 'started') {
                                        statusClass = 'log-info';
                                        overallStatus = 'Started';
                                    }
                                    
                                    // Calculate success rate if available
                                    let successRate = '';
                                    if (syncLog.projectStats) {
                                        const totalProjects = Object.keys(syncLog.projectStats).length;
                                        const successfulProjects = Object.values(syncLog.projectStats).filter(stat => stat.status === 'success').length;
                                        successRate = ` (${successfulProjects}/${totalProjects} projects successful, ${Math.round((successfulProjects/totalProjects)*100)}% success rate)`;
                                    } else if (syncLog.success_count && syncLog.project_count) {
                                        successRate = ` (${syncLog.success_count}/${syncLog.project_count} projects successful, ${Math.round((syncLog.success_count/syncLog.project_count)*100)}% success rate)`;
                                    }
                                    
                                    // Create message based on available data
                                    let message = syncLog.message || 'Sync completed';
                                    if (!syncLog.message) {
                                        if (syncLog.project_count || syncLog.projects) {
                                            const count = syncLog.project_count || (syncLog.projects ? syncLog.projects.length : 0);
                                            message = `Synced ${count} projects`;
                                        }
                                        if (syncLog.task_count) {
                                            message += `, ${syncLog.task_count} tasks`;
                                        }
                                    }
                                    
                                    // Build the log entry header
                                    let logContent = `
                                        <div class="log-time">${timeString}</div>
                                        <div class="log-message ${statusClass}">
                                            <strong>${overallStatus}:</strong> ${message}${successRate}
                                            <button class="toggle-details" style="background: none; border: none; padding: 0; font-size: 0.8rem; text-decoration: underline; cursor: pointer; color: #666;">Show details</button>
                        </div>
                                        <div class="log-details" style="display: none; margin-top: 5px; font-size: 0.85rem; background-color: #f5f5f5; padding: 8px; border-radius: 4px;">
                                    `;
                                    
                                    // Add detailed project information if available
                                    if (syncLog.projectStats) {
                                        logContent += '<h4 style="margin: 0 0 5px 0; font-size: 0.9rem;">Project Details:</h4><ul style="margin: 0; padding-left: 20px;">';
                                        
                                        Object.entries(syncLog.projectStats).forEach(([projectId, stats]) => {
                                            const projectStatus = stats.status || 'unknown';
                                            const projectStatusClass = projectStatus === 'success' ? 'log-success' : 
                                                                      projectStatus === 'error' ? 'log-error' : 'log-warning';
                                            
                                            logContent += `<li style="margin-bottom: 3px;"><span class="${projectStatusClass}" style="font-weight: bold;">${projectStatus.toUpperCase()}</span>: ${stats.name || projectId}`;
                                            
                                            if (stats.tasks_synced !== undefined) {
                                                logContent += ` (${stats.tasks_synced} tasks synced)`;
                                            }
                                            
                                            if (stats.error) {
                                                logContent += ` - Error: ${stats.error}`;
                                            }
                                            
                                            logContent += '</li>';
                                        });
                                        
                                        logContent += '</ul>';
                                    } else if (syncLog.projects) {
                                        // If we only have project IDs without status
                                        logContent += '<h4 style="margin: 0 0 5px 0; font-size: 0.9rem;">Projects:</h4><ul style="margin: 0; padding-left: 20px;">';
                                        
                                        syncLog.projects.forEach(projectId => {
                                            // Try to get project name from a reference map
                                            const projectName = syncLog.projectNames && syncLog.projectNames[projectId] ? 
                                                             syncLog.projectNames[projectId] : projectId;
                                            
                                            logContent += `<li>${projectName}</li>`;
                                        });
                                        
                                        logContent += '</ul>';
                                    }
                                    
                                    // Add errors if available
                                    if (syncLog.errors && syncLog.errors.length > 0) {
                                        logContent += '<h4 style="margin: 5px 0; font-size: 0.9rem;">Errors:</h4><ul style="margin: 0; padding-left: 20px;">';
                                        
                                        syncLog.errors.forEach(error => {
                                            logContent += `<li class="log-error">${error}</li>`;
                                        });
                                        
                                        logContent += '</ul>';
                                    }
                                    
                                    // Add warnings if available
                                    if (syncLog.warnings && syncLog.warnings.length > 0) {
                                        logContent += '<h4 style="margin: 5px 0; font-size: 0.9rem;">Warnings:</h4><ul style="margin: 0; padding-left: 20px;">';
                                        
                                        syncLog.warnings.forEach(warning => {
                                            logContent += `<li class="log-warning">${warning}</li>`;
                                        });
                                        
                                        logContent += '</ul>';
                                    }
                                    
                                    // Close the log details div
                                    logContent += '</div>';
                                    
                                    logEntry.innerHTML = logContent;
                                    historyLog.appendChild(logEntry);
                                    
                                    // Add event listener to toggle details
                                    const toggleButton = logEntry.querySelector('.toggle-details');
                                    const detailsSection = logEntry.querySelector('.log-details');
                                    
                                    toggleButton.addEventListener('click', function() {
                                        if (detailsSection.style.display === 'none') {
                                            detailsSection.style.display = 'block';
                                            toggleButton.textContent = 'Hide details';
                                        } else {
                                            detailsSection.style.display = 'none';
                                            toggleButton.textContent = 'Show details';
                                        }
                                    });
                                });
                                
                                console.log('Loaded more sync logs');
                } else {
                                alert('No more sync logs to load');
                            }
                        })
                        .catch(error => {
                            console.error('Error loading more sync logs:', error);
                            alert('Error loading more logs');
                        });
                } else {
                    loadSyncLogs(); // If there are no entries, just reload
                }
            });
            
            // Function to load projects for the task viewer filter
            function loadTaskViewerProjects() {
                const projectFilter = document.getElementById('filter-project');
                
                // Clear existing options except the first one
                while (projectFilter.options.length > 1) {
                    projectFilter.remove(1);
                }
                
                db.collection('asana_projects')
                    .where('archived', '==', false)
                    .orderBy('name')
                    .get()
                    .then(snapshot => {
                        if (!snapshot.empty) {
                            snapshot.forEach(doc => {
                                const project = doc.data();
                                const option = document.createElement('option');
                                option.value = doc.id;
                                option.textContent = project.name || 'Unnamed Project';
                                projectFilter.appendChild(option);
                            });
                            
                            console.log('Loaded task viewer projects');
                        } else {
                            console.log('No projects found for task viewer filter');
                        }
                    })
                    .catch(error => {
                        console.error('Error loading task viewer projects:', error);
                    });
            }
            
            // Function to load assignees for the task viewer filter
            function loadTaskViewerAssignees() {
                const assigneeFilter = document.getElementById('filter-assignee');
                
                // Clear existing options except the first one
                while (assigneeFilter.options.length > 1) {
                    assigneeFilter.remove(1);
                }
                
                // Get unique assignees from tasks
                const assignees = new Set();
                
                db.collection('asana_tasks')
                    .limit(500) // Limit to prevent loading too many tasks
                    .get()
                    .then(snapshot => {
                        if (!snapshot.empty) {
                            snapshot.forEach(doc => {
                                const task = doc.data();
                                if (task.assignee && task.assignee_name) {
                                    assignees.add(JSON.stringify({
                                        id: task.assignee.id || task.assignee.gid || task.assignee,
                                        name: task.assignee_name
                                    }));
                                }
                            });
                            
                            // Convert assignees to array and sort by name
                            const assigneeArray = Array.from(assignees)
                                .map(json => JSON.parse(json))
                                .sort((a, b) => a.name.localeCompare(b.name));
                            
                            // Add assignee options
                            assigneeArray.forEach(assignee => {
                                const option = document.createElement('option');
                                option.value = assignee.id;
                                option.textContent = assignee.name;
                                assigneeFilter.appendChild(option);
                            });
                            
                            console.log('Loaded task viewer assignees');
                        } else {
                            console.log('No tasks found for assignee filter');
                        }
                    })
                    .catch(error => {
                        console.error('Error loading task viewer assignees:', error);
                    });
            }
            
            // Function to load tasks with applied filters
            function loadTasks(startAfter = null) {
                const taskList = document.getElementById('task-list');
                
                // Show loading indicator if this is the first page
                if (!startAfter) {
                    taskList.innerHTML = '<div class="loading-indicator">Loading tasks...</div>';
                }
                
                // Get filter values
                const projectId = document.getElementById('filter-project').value;
                const statusValue = document.getElementById('filter-status').value;
                const assigneeId = document.getElementById('filter-assignee').value;
                
                // Start building the query
                let query = db.collection('asana_tasks');
                
                // Apply filters if they are set
                if (projectId) {
                    query = query.where('projectId', '==', projectId);
                }
                
                if (statusValue === 'true' || statusValue === 'false') {
                    query = query.where('completed', '==', statusValue === 'true');
                }
                
                if (assigneeId) {
                    query = query.where('assignee.id', '==', assigneeId);
                }
                
                // Order by name to ensure consistent order
                query = query.orderBy('name');
                
                // Apply pagination if startAfter is provided
                if (startAfter) {
                    query = query.startAfter(startAfter);
                }
                
                // Limit the number of tasks
                query = query.limit(20);
                
                // Execute the query
                query.get()
                    .then(snapshot => {
                        // Remove loading indicator if this is the first page
                        if (!startAfter) {
                            taskList.innerHTML = '';
                        }
                        
                        if (!snapshot.empty) {
                            // Store the last document for pagination
                            window.lastVisibleTask = snapshot.docs[snapshot.docs.length - 1];
                            
                            snapshot.forEach(doc => {
                                const task = doc.data();
                                const taskItem = document.createElement('div');
                                taskItem.className = 'task-item';
                                taskItem.setAttribute('data-task-id', doc.id);
                                
                                // Format due date if available
                                let dueDate = 'No due date';
                                if (task.due_on) {
                                    dueDate = new Date(task.due_on).toLocaleDateString();
                                }
                                
                                taskItem.innerHTML = `
                                    <div class="task-title">${task.name || 'Untitled Task'}</div>
                                    <div class="task-details">
                                        <p>Project: ${task.project_name || 'Unknown'} | Assigned to: ${task.assignee_name || 'Unassigned'} | Due: ${dueDate}</p>
                                        <p>Status: ${task.completed ? 'Completed' : 'Not Started'}</p>
                    </div>
                `;
                
                                taskList.appendChild(taskItem);
                                
                                // Add click event to view task details
                                taskItem.addEventListener('click', function() {
                                    const taskId = this.getAttribute('data-task-id');
                                    openTaskModal(taskId);
                                });
                            });
                            
                            console.log('Loaded tasks');
                        } else if (!startAfter) {
                            // Only show "no tasks" message if this is the first page
                            taskList.innerHTML = '<div class="empty-state">No tasks found matching the selected filters</div>';
                } else {
                            alert('No more tasks to load');
                        }
                    })
                    .catch(error => {
                        console.error('Error loading tasks:', error);
                        
                        if (!startAfter) {
                            // Only show error message if this is the first page
                            taskList.innerHTML = '<div class="error-state">Error loading tasks</div>';
                        } else {
                            alert('Error loading more tasks');
                        }
                    });
            }
            
            // Add event listener for apply filters button
            document.getElementById('apply-filters').addEventListener('click', function() {
                // Reset pagination
                window.lastVisibleTask = null;
                
                // Load tasks with new filters
                loadTasks();
            });
            
            // Add event listener for reset filters button
            document.getElementById('reset-filters').addEventListener('click', function() {
                document.getElementById('filter-project').value = '';
                document.getElementById('filter-status').value = '';
                document.getElementById('filter-assignee').value = '';
                
                // Reset pagination
                window.lastVisibleTask = null;
                
                // Load tasks with new filters
                loadTasks();
            });
            
            // Update load more tasks button
            document.getElementById('load-more-tasks').addEventListener('click', function() {
                if (window.lastVisibleTask) {
                    loadTasks(window.lastVisibleTask);
                } else {
                    loadTasks();
                }
            });
            
            // Settings form submission
            document.getElementById('settings-form').addEventListener('submit', function(e) {
            e.preventDefault();
            
                const pat = document.getElementById('asana-pat').value;
                const syncFrequency = document.getElementById('sync-frequency').value;
                
                if (!pat) {
                    alert('Please enter your Asana Personal Access Token');
                    return;
                }
                
                // First, check if a settings document already exists to determine the naming convention
                db.collection('asana_config').doc('settings').get()
                    .then(doc => {
                        const data = doc.exists ? doc.data() : {};
                        const usesCamelCase = doc.exists && (data.personalAccessToken !== undefined || data.syncFrequency !== undefined);
                        
                        // Create settings object using the appropriate naming convention
                        let settingsData = {};
                        
                        if (usesCamelCase) {
                            console.log('Using camelCase naming convention');
                            settingsData = {
                                personalAccessToken: pat,
                                syncFrequency: parseInt(syncFrequency),
                                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                                syncEnabled: true
                            };
                        } else {
                            console.log('Using snake_case naming convention');
                            settingsData = {
                                personal_access_token: pat,
                                sync_frequency: parseInt(syncFrequency),
                                updated_at: firebase.firestore.FieldValue.serverTimestamp(),
                                active: true
                            };
                        }
                        
                        // Save settings to Firestore using the correct collection and document structure
                        return db.collection('asana_config').doc('settings').set(settingsData, { merge: true });
                    })
                    .then(() => {
                        console.log('Settings saved successfully to asana_config!');
                        alert('Settings saved successfully!');
                        
                        // Hide the cancel button after successful save
                        document.getElementById('cancel-edit').style.display = 'none';
                        
                        // Reload connection status to refresh the UI with new settings
                        setTimeout(() => {
                            checkConnectionStatus();
                        }, 500);
                    })
                    .catch((error) => {
                        console.error('Error saving settings:', error);
                        alert(`Error saving settings: ${error.message}. Please try again.`);
                    });
            });
            
            // Test connection button
            document.getElementById('test-connection').addEventListener('click', function() {
                const pat = document.getElementById('asana-pat').value;
                
                if (!pat) {
                    alert('Please enter your Asana Personal Access Token');
                return;
            }
            
                alert('Testing connection to Asana...');
                console.log("Testing connection with PAT: " + pat.substring(0, 4) + "...");
                
                // For demo purposes, simulate a successful connection
                setTimeout(() => {
                    // Test connection success
                    db.collection('asana_sync_logs').add({
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        type: 'connection_test',
                        status: 'success',
                        message: 'Connection test successful'
                    })
                    .then(() => {
                        console.log('Connection test logged successfully');
                        alert('Connection successful!');
                        updateConnectionStatus(true);
                    })
                    .catch((error) => {
                        console.error('Error logging connection test:', error);
                        alert(`Error during connection test: ${error.message}. Please try again.`);
                    });
                }, 1000);
            });
            
            // Open task detail modal when clicking on a task
            const taskItems = document.querySelectorAll('.task-item');
            const taskModal = document.getElementById('task-modal');
            const closeBtn = document.querySelector('.close-btn');
            
            taskItems.forEach(task => {
                task.addEventListener('click', function() {
                    const taskId = this.getAttribute('data-task-id');
                    openTaskModal(taskId);
                });
            });
            
            closeBtn.addEventListener('click', function() {
                taskModal.style.display = 'none';
            });
            
            window.addEventListener('click', function(e) {
                if (e.target === taskModal) {
                    taskModal.style.display = 'none';
                }
            });
            
            // Open task detail modal
            function openTaskModal(taskId) {
                const taskModal = document.getElementById('task-modal');
                const taskModalBody = document.getElementById('task-modal-body');
                
                // Try to load task from Firestore first
                db.collection('asana_tasks').doc(taskId).get()
                    .then(doc => {
                        if (doc.exists) {
                            const taskData = doc.data();
                            console.log('Task data:', taskData);
                            
                            // If we have a projectId, try to get the project name
                            if (taskData.projectId || taskData.projectGid) {
                                const projectId = taskData.projectGid || taskData.projectId;
                                
                                // Try to get project details
                                db.collection('asana_projects').doc(projectId).get()
                                    .then(projectDoc => {
                                        if (projectDoc.exists) {
                                            const projectData = projectDoc.data();
                                            taskData.project_name = projectData.name || 'Unknown Project';
                                        } else {
                                            console.log(`Project not found for ID: ${projectId}`);
                                            taskData.project_name = `Project ID: ${projectId}`;
                                        }
                                        displayTaskDetails(taskData);
                                    })
                                    .catch(error => {
                                        console.error('Error loading project:', error);
                                        taskData.project_name = `Project ID: ${projectId}`;
                                        displayTaskDetails(taskData);
                                    });
                            } else {
                                taskData.project_name = 'Unknown Project';
                                displayTaskDetails(taskData);
                            }
                        } else {
                            // Fallback to static data if not found
                            const taskData = {
                                name: 'Task details not found',
                                notes: 'No additional information available for this task.',
                                assignee_name: 'Unknown',
                                due_on: 'Unknown',
                                completed: false,
                                project_name: 'Unknown Project',
                                created_at: 'Unknown',
                                priority: 'Unknown',
                                sections: [],
                                tags: []
                            };
                            displayTaskDetails(taskData);
                        }
                    })
                    .catch(error => {
                        console.error('Error loading task:', error);
                        // Fallback to basic display
                        const taskData = {
                            name: 'Error loading task',
                            notes: 'There was an error loading the task details.',
                            assignee_name: 'Unknown',
                            due_on: 'Unknown',
                            completed: false,
                            project_name: 'Unknown Project',
                            created_at: 'Unknown',
                            priority: 'Unknown',
                            sections: [],
                            tags: []
                        };
                        displayTaskDetails(taskData);
                    });
                    
                function displayTaskDetails(taskData) {
                    // Generate HTML for task details based on available data
                    let taskDetailsHTML = `
                        <div class="task-property">
                            <div class="property-name">Title</div>
                            <div>${taskData.name || taskData.title || 'Untitled'}</div>
                                </div>
                        <div class="task-property">
                            <div class="property-name">Description</div>
                            <div>${taskData.notes || taskData.description || 'No description'}</div>
                            </div>
                        <div class="task-property">
                            <div class="property-name">Project</div>
                            <div>${taskData.project_name || 'Unknown Project'}</div>
                        </div>
                        <div class="task-property">
                            <div class="property-name">Assignee</div>
                            <div>${taskData.assignee_name || taskData.assignee || 'Unassigned'}</div>
                                </div>
                        <div class="task-property">
                            <div class="property-name">Due Date</div>
                            <div>${taskData.due_on || taskData.dueDate || 'No due date'}</div>
                            </div>
                        <div class="task-property">
                            <div class="property-name">Status</div>
                            <div>${taskData.completed ? 'Completed' : 'Not Started'}</div>
                        </div>
                    `;
                    
                    if (taskData.priority) {
                        taskDetailsHTML += `
                            <div class="task-property">
                                <div class="property-name">Priority</div>
                                <div>${taskData.priority}</div>
                                </div>
                        `;
                    }
                    
                    if (taskData.created_at || taskData.createdAt) {
                        taskDetailsHTML += `
                            <div class="task-property">
                                <div class="property-name">Created</div>
                                <div>${taskData.created_at || taskData.createdAt}</div>
                            </div>
                        `;
                    }
                    
                    if (taskData.sections && taskData.sections.length > 0) {
                        taskDetailsHTML += `
                            <div class="task-property">
                                <div class="property-name">Sections</div>
                                <div>${taskData.sections.join(', ')}</div>
                    </div>
                `;
                    }
                    
                    if (taskData.tags && taskData.tags.length > 0) {
                        taskDetailsHTML += `
                            <div class="task-property">
                                <div class="property-name">Tags</div>
                                <div>${taskData.tags.join(', ')}</div>
                    </div>
                `;
                    }
                    
                    // Set modal title and content
                    document.querySelector('.modal-title').textContent = taskData.name || taskData.title || 'Task Details';
                    taskModalBody.innerHTML = taskDetailsHTML;
                    
                    // Show the modal
                    taskModal.style.display = 'block';
                }
            }
            
            // Debug functionality
            document.getElementById('debug-show-data').addEventListener('click', function() {
                const debugOutput = document.getElementById('debug-output');
                debugOutput.innerHTML = 'Loading database data...';
                
                // Check all relevant collections
                const collections = ['asana_config', 'asana_workspaces', 'asana_projects'];
                let output = '';
                
                Promise.all(collections.map(collection => 
                    db.collection(collection).get()
                        .then(snapshot => {
                            output += `<strong>${collection}</strong> (${snapshot.size} docs):<br>`;
                            
                            if (snapshot.empty) {
                                output += '- No documents found<br>';
                } else {
                                snapshot.forEach(doc => {
                                    const data = doc.data();
                                    output += `- ${doc.id}: ${JSON.stringify(data).substring(0, 150)}...<br>`;
                                });
                            }
                            
                            output += '<br>';
                        })
                        .catch(error => {
                            output += `Error getting ${collection}: ${error}<br>`;
                        })
                ))
                .then(() => {
                    debugOutput.innerHTML = output;
                    console.log('Debug data loaded');
                })
                .catch(error => {
                    debugOutput.innerHTML += `<br>Error: ${error}`;
                    console.error('Debug error:', error);
                });
            });
            
            document.getElementById('debug-create-settings').addEventListener('click', function() {
                const debugOutput = document.getElementById('debug-output');
                debugOutput.innerHTML = 'Creating sample settings...';
                
                // Create sample settings document
                const sampleSettings = {
                    personal_access_token: '1/1234567890abcdefghijklmn',
                    sync_frequency: 60,
                    updated_at: firebase.firestore.FieldValue.serverTimestamp(),
                    active: true,
                    last_sync: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                db.collection('asana_config').doc('settings').set(sampleSettings)
                    .then(() => {
                        debugOutput.innerHTML += '<br>Sample settings created successfully!';
                        console.log('Sample settings created');
                        
                        // Reload connection status to see the changes
                        setTimeout(() => {
                            checkConnectionStatus();
                        }, 500);
                    })
                    .catch(error => {
                        debugOutput.innerHTML += `<br>Error creating sample settings: ${error}`;
                        console.error('Error creating sample settings:', error);
                    });
            });
            
            document.getElementById('debug-create-projects').addEventListener('click', function() {
                const debugOutput = document.getElementById('debug-output');
                debugOutput.innerHTML = 'Creating sample projects...';
                
                // First, check if we need a workspace
                db.collection('asana_workspaces').get()
                    .then(snapshot => {
                        let workspaceGid = '1197204311639010'; // Default workspace GID
                        let workspaceName = 'JoJo\'s Shave Ice';
                        
                        if (!snapshot.empty) {
                            // Use the first workspace if available
                            const workspaceDoc = snapshot.docs[0];
                            const workspace = workspaceDoc.data();
                            workspaceGid = workspace.gid || workspaceDoc.id;
                            workspaceName = workspace.name || 'Workspace';
                            debugOutput.innerHTML += `<br>Using existing workspace: ${workspaceName} (GID: ${workspaceGid})`;
                        } else {
                            // Create a sample workspace
                            debugOutput.innerHTML += `<br>Creating sample workspace: ${workspaceName} (GID: ${workspaceGid})`;
                            db.collection('asana_workspaces').doc(workspaceGid).set({
                                name: workspaceName,
                                gid: workspaceGid,
                                created_at: firebase.firestore.FieldValue.serverTimestamp()
                            });
                        }
                        
                        // Create some sample projects
                        const sampleProjects = [
                            {
                                name: 'Inventory Management',
                                gid: '1201234567890123',
                                workspaceGid: workspaceGid,
                                workspaceName: workspaceName,
                                archived: false,
                                created_at: firebase.firestore.FieldValue.serverTimestamp(),
                                updated_at: firebase.firestore.FieldValue.serverTimestamp()
                            },
                            {
                                name: 'Weekly Tasks',
                                gid: '1201234567890124',
                                workspaceGid: workspaceGid,
                                workspaceName: workspaceName,
                                archived: false,
                                created_at: firebase.firestore.FieldValue.serverTimestamp(),
                                updated_at: firebase.firestore.FieldValue.serverTimestamp()
                            },
                            {
                                name: 'Marketing Campaigns',
                                gid: '1201234567890125',
                                workspaceGid: workspaceGid,
                                workspaceName: workspaceName,
                                archived: false,
                                created_at: firebase.firestore.FieldValue.serverTimestamp(),
                                updated_at: firebase.firestore.FieldValue.serverTimestamp()
                            }
                        ];
                        
                        // Create each project
                        const projectPromises = sampleProjects.map(project => 
                            db.collection('asana_projects').doc(project.gid).set(project)
                        );
                        
                        return Promise.all(projectPromises);
                    })
                    .then(() => {
                        debugOutput.innerHTML += '<br>Sample projects created successfully!';
                        console.log('Sample projects created');
                        
                        // Reload projects to see the changes
                        setTimeout(() => {
                            loadWorkspaces();
                            loadProjects();
                        }, 500);
                    })
                    .catch(error => {
                        debugOutput.innerHTML += `<br>Error creating sample projects: ${error}`;
                        console.error('Error creating sample projects:', error);
                    });
            });
            
            document.getElementById('debug-clear-logs').addEventListener('click', function() {
                console.clear();
                document.getElementById('debug-output').innerHTML = 'Console cleared';
            });
            
            // Call addCheckboxEventListeners when the project list is first loaded
            function updateProjectList() {
                // Reset delete button
                document.getElementById('delete-projects-btn').disabled = true;
                
                // Clear search input
                document.getElementById('project-search').value = '';
                
                // Add event listeners to checkboxes
                addCheckboxEventListeners();
            }
            
            // Sync Statistics Modal functionality
            const syncStatsModal = document.getElementById('sync-stats-modal');
            const closeStatsBtns = syncStatsModal.querySelectorAll('.close-btn');
            let syncStatsChart = null;
            let selectedProjects = []; // Store selected project IDs
            let drillDownState = null; // Track drill-down state
            
            // Open the sync statistics modal
            document.getElementById('view-sync-stats-btn').addEventListener('click', function() {
                // Make sure we have a canvas element to draw on
                const modalBody = document.getElementById('sync-stats-modal-body');
                const graphContainer = document.getElementById('sync-stats-graph');
                
                // If the graph container isn't a canvas (might have been replaced with a div), recreate it
                if (graphContainer && graphContainer.tagName !== 'CANVAS') {
                    // Remove the existing element
                    modalBody.removeChild(graphContainer);
                    
                    // Create a new canvas
                    const canvas = document.createElement('canvas');
                    canvas.id = 'sync-stats-graph';
                    canvas.style.width = '100%';
                    canvas.style.height = '400px';
                    
                    // Insert the canvas in the right location (before the summary div)
                    const summaryDiv = document.getElementById('sync-stats-summary');
                    modalBody.insertBefore(canvas, summaryDiv);
                }
                
                // Reset drill-down state
                drillDownState = null;
                document.getElementById('drill-up-btn').style.display = 'none';
                
                // Show the modal
                syncStatsModal.style.display = 'block';
                
                // Load the statistics
                loadSyncStatistics();
            });
            
            // Close the modal when clicking the close button or outside the modal
            closeStatsBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    syncStatsModal.style.display = 'none';
                });
            });
            
            window.addEventListener('click', function(e) {
                if (e.target === syncStatsModal) {
                    syncStatsModal.style.display = 'none';
                }
            });
            
            // Project multi-select filter functionality
            const projectFilterContainer = document.querySelector('.selected-projects-display');
            const projectFilterDropdown = document.getElementById('project-filter-dropdown');
            
            // Toggle dropdown when clicking on the display box
            projectFilterContainer.addEventListener('click', function() {
                projectFilterDropdown.style.display = projectFilterDropdown.style.display === 'none' ? 'block' : 'none';
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!projectFilterContainer.contains(e.target) && !projectFilterDropdown.contains(e.target)) {
                    projectFilterDropdown.style.display = 'none';
                }
            });
            
            // Handle select all checkbox
            document.getElementById('select-all-projects-filter').addEventListener('change', function() {
                const projectCheckboxes = document.querySelectorAll('.project-filter-checkbox');
                projectCheckboxes.forEach(checkbox => {
                    checkbox.checked = this.checked;
                });
                
                // Update selected projects text
                updateSelectedProjectsText();
            });
            
            // Apply filter button
            document.getElementById('apply-stats-filters').addEventListener('click', function() {
                // Gather selected projects
                selectedProjects = Array.from(document.querySelectorAll('.project-filter-checkbox:checked'))
                    .map(checkbox => checkbox.value);
                
                // Close the dropdown
                projectFilterDropdown.style.display = 'none';
                
                // Update selected projects text
                updateSelectedProjectsText();
                
                // Reset drill-down state
                drillDownState = null;
                document.getElementById('drill-up-btn').style.display = 'none';
                
                // Reload statistics with new filters
                loadSyncStatistics();
            });
            
            // Reset filter button
            document.getElementById('reset-stats-filters').addEventListener('click', function() {
                // Uncheck all project checkboxes
                document.querySelectorAll('.project-filter-checkbox').forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                // Reset selected projects
                selectedProjects = [];
                
                // Update text
                updateSelectedProjectsText();
                
                // Reset drill-down state
                drillDownState = null;
                document.getElementById('drill-up-btn').style.display = 'none';
                
                // Close the dropdown
                projectFilterDropdown.style.display = 'none';
                
                // Reload statistics
                loadSyncStatistics();
            });
            
            // Drill up button
            document.getElementById('drill-up-btn').addEventListener('click', function() {
                drillDownState = null;
                this.style.display = 'none';
                loadSyncStatistics();
            });
            
            // Update selected projects text display
            function updateSelectedProjectsText() {
                const selectedCount = selectedProjects.length;
                const textElement = document.getElementById('selected-projects-text');
                
                if (selectedCount === 0) {
                    textElement.textContent = 'All Projects';
                } else {
                    textElement.textContent = `${selectedCount} project${selectedCount > 1 ? 's' : ''} selected`;
                }
            }
            
            // Populate project filter with all projects from database
            function populateProjectFilter() {
                console.log('Populating project filter from asana_projects collection');
                
                // Query all projects
                db.collection('asana_projects')
                    .orderBy('name')
                    .get()
                    .then(snapshot => {
                        if (snapshot.empty) {
                            console.log('No projects found in asana_projects collection');
                            return;
                        }
                        
                        const projectFilterList = document.getElementById('project-filter-list');
                        projectFilterList.innerHTML = ''; // Clear existing options
                        
                        // Add options from direct query
                        const projects = [];
                        snapshot.forEach(doc => {
                            const project = doc.data();
                            const projectName = project.name || `Project ${doc.id}`;
                            
                            projects.push({
                                id: doc.id,
                                name: projectName
                            });
                        });
                        
                        // Sort by name
                        projects.sort((a, b) => a.name.localeCompare(b.name));
                        
                        // Add to filter list
                        projects.forEach(project => {
                            const checkboxContainer = document.createElement('div');
                            checkboxContainer.style.padding = '4px 8px';
                            checkboxContainer.style.marginBottom = '2px';
                            checkboxContainer.style.cursor = 'pointer';
                            checkboxContainer.style.transition = 'background-color 0.2s';
                            
                            const label = document.createElement('label');
                            label.style.margin = '0';
                            label.style.width = '100%';
                            label.style.cursor = 'pointer';
                            
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.className = 'project-filter-checkbox';
                            checkbox.value = project.id;
                            checkbox.style.marginRight = '8px';
                            checkbox.checked = selectedProjects.includes(project.id);
                            
                            // Add event listener to update the text display on individual checkbox change
                            checkbox.addEventListener('change', function() {
                                updateSelectedProjectsText();
                            });
                            
                            label.appendChild(checkbox);
                            label.appendChild(document.createTextNode(project.name));
                            
                            checkboxContainer.appendChild(label);
                            projectFilterList.appendChild(checkboxContainer);
                            
                            // Add hover effect
                            checkboxContainer.addEventListener('mouseover', function() {
                                this.style.backgroundColor = '#f0f0f0';
                            });
                            
                            checkboxContainer.addEventListener('mouseout', function() {
                                this.style.backgroundColor = 'transparent';
                            });
                        });
                        
                        console.log(`Added ${projects.length} projects to filter list`);
                    })
                    .catch(error => {
                        console.error('Error querying projects:', error);
                    });
            }
            
            // Load and display sync statistics
            function loadSyncStatistics() {
                const days = parseInt(document.getElementById('stats-date-range').value) || 7;
                const viewType = document.getElementById('stats-view-type').value || 'success-rate';
                
                // Calculate date range
                const endDate = new Date();
                const startDate = new Date();
                startDate.setDate(startDate.getDate() - days);
                
                console.log(`Loading sync statistics for the last ${days} days (${startDate.toISOString()} to ${endDate.toISOString()})`);
                console.log(`Using project filters: ${selectedProjects.length > 0 ? selectedProjects.join(', ') : 'All Projects'}`);
                
                // If we're in a drill-down view, handle that specially
                if (drillDownState) {
                    if (drillDownState.type === 'day') {
                        loadDayDetails(drillDownState.date, selectedProjects);
                        return;
                    } else if (drillDownState.type === 'project') {
                        loadProjectDetails(drillDownState.projectId, days);
                        return;
                    } else if (drillDownState.type === 'error') {
                        loadErrorDetails(drillDownState.errorType, days, selectedProjects);
                        return;
                    }
                }
                
                // Always make sure project filter is populated with all projects
                populateProjectFilter();
                
                // Query the sync logs within the date range
                let query = db.collection('asana_sync_logs')
                    .where('timestamp', '>=', firebase.firestore.Timestamp.fromDate(startDate))
                    .where('timestamp', '<=', firebase.firestore.Timestamp.fromDate(endDate))
                    .orderBy('timestamp', 'asc');
                
                query.get()
                    .then(snapshot => {
                        if (snapshot.empty) {
                            console.log('No sync logs found for the selected period');
                            displayNoDataMessage();
                            return;
                        }
                        
                        // Process the sync logs
                        const logs = [];
                        snapshot.forEach(doc => {
                            const log = doc.data();
                            if (log.timestamp) {
                                logs.push({
                                    id: doc.id,
                                    ...log,
                                    date: log.timestamp.toDate()
                                });
                            }
                        });
                        
                        console.log(`Found ${logs.length} sync logs`);
                        
                        // Filter logs by selected projects if needed
                        let filteredLogs = logs;
                        if (selectedProjects.length > 0) {
                            filteredLogs = logs.filter(log => {
                                // Check if any selected projects are included in this log
                                for (const projectId of selectedProjects) {
                                    // Check in projects array (GID should be the ID)
                                    if (log.projects && log.projects.includes(projectId)) {
                                        return true;
                                    }
                                    
                                    // Check in projectStats object (GID is the key)
                                    if (log.projectStats && log.projectStats[projectId]) {
                                        return true;
                                    }
                                }
                                return false;
                            });
                            console.log(`Filtered to ${filteredLogs.length} logs for selected projects`);
                        }
                        
                        if (filteredLogs.length === 0) {
                            displayNoDataMessage();
                            return;
                        }
                        
                        // Group logs by day
                        const logsByDay = {};
                        const labels = [];
                        const currentDate = new Date(startDate);
                        
                        // Initialize all days in the range
                        while (currentDate <= endDate) {
                            const dateKey = currentDate.toISOString().split('T')[0];
                            labels.push(moment(dateKey).format('MMM D'));
                            logsByDay[dateKey] = {
                                date: new Date(currentDate),
                                logs: [],
                                successCount: 0,
                                totalCount: 0,
                                errorCount: 0,
                                projectSuccessCount: 0,
                                projectTotalCount: 0,
                                dateKey: dateKey
                            };
                            currentDate.setDate(currentDate.getDate() + 1);
                        }
                        
                        // Populate with actual logs
                        filteredLogs.forEach(log => {
                            const dateKey = log.date.toISOString().split('T')[0];
                            if (logsByDay[dateKey]) {
                                logsByDay[dateKey].logs.push(log);
                                
                                // For multi-select projects, we need to count only the selected projects
                                if (selectedProjects.length > 0) {
                                    // Count only selected projects' stats
                                    let daySuccessCount = 0;
                                    let dayTotalCount = 0;
                                    let dayErrorCount = 0;
                                    
                                    selectedProjects.forEach(projectId => {
                                        if (log.projectStats && log.projectStats[projectId]) {
                                            const stat = log.projectStats[projectId];
                                            dayTotalCount++;
                                            if (stat.status === 'success') {
                                                daySuccessCount++;
                                            } else if (stat.error) {
                                                dayErrorCount++;
                                            }
                                        }
                                    });
                                    
                                    logsByDay[dateKey].successCount += daySuccessCount;
                                    logsByDay[dateKey].totalCount += dayTotalCount;
                                    logsByDay[dateKey].errorCount += dayErrorCount;
                                } else {
                                    // Count all projects
                                    if (log.success_count !== undefined && log.project_count !== undefined) {
                                        logsByDay[dateKey].successCount += log.success_count;
                                        logsByDay[dateKey].totalCount += log.project_count;
                                    }
                                    
                                    // Count errors
                                    try {
                                        if (log.errors && Array.isArray(log.errors)) {
                                            logsByDay[dateKey].errorCount += log.errors.length;
                                        }
                                        
                                        // Also count project-specific errors
                                        if (log.projectStats) {
                                            Object.values(log.projectStats).forEach(stat => {
                                                if (stat.error) {
                                                    logsByDay[dateKey].errorCount++;
                                                }
                                            });
                                        }
                                    } catch (e) {
                                        console.error('Error counting errors:', e);
                                    }
                                }
                            }
                        });
                        
                        // Prepare data for chart based on view type
                        let chartData;
                        let chartTitle;
                        let chartColor;
                        
                        switch (viewType) {
                            case 'success-rate':
                                chartTitle = 'Sync Success Rate (%)';
                                chartColor = 'rgba(40, 167, 69, 0.7)';
                                chartData = Object.values(logsByDay).map(day => {
                                    return day.totalCount === 0 ? 0 : 
                                        Math.round((day.successCount / day.totalCount) * 100);
                                });
                                break;
                                
                            case 'sync-count':
                                chartTitle = 'Number of Syncs';
                                chartColor = 'rgba(23, 162, 184, 0.7)';
                                chartData = Object.values(logsByDay).map(day => {
                                    return day.logs.length;
                                });
                                break;
                                
                            case 'errors':
                                chartTitle = 'Number of Errors';
                                chartColor = 'rgba(220, 53, 69, 0.7)';
                                chartData = Object.values(logsByDay).map(day => {
                                    return day.errorCount;
                                });
                                break;
                        }
                        
                        // Create or update chart
                        createDrillableChart(labels, chartData, chartTitle, chartColor, Object.values(logsByDay));
                        
                        // Update summary statistics
                        updateSummaryStats(logs, filteredLogs);
                    })
                    .catch(error => {
                        console.error('Error loading sync statistics:', error);
                        displayErrorMessage(error);
                    });
            }
            
            // Create or update the chart
            function createDrillableChart(labels, data, title, color, dataSets) {
                const ctx = document.getElementById('sync-stats-graph').getContext('2d');
                
                // Destroy previous chart if it exists
                if (syncStatsChart) {
                    syncStatsChart.destroy();
                }
                
                // Create new chart
                syncStatsChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: dataSets.map(set => ({
                            label: set.name,
                            data: data.map(d => d[set.id]),
                            backgroundColor: color,
                            borderColor: color.replace('0.7', '1'),
                            borderWidth: 1
                        }))
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: title
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Date'
                                }
                            }
                        }
                    }
                });
            }
            
            // Display a message when no data is available
            function displayNoDataMessage() {
                const graphContainer = document.getElementById('sync-stats-graph');
                if (syncStatsChart) {
                    syncStatsChart.destroy();
                    syncStatsChart = null;
                }
                
                // Since we're using a canvas now, we need to replace it with a div to show the message
                const parentElement = graphContainer.parentElement;
                parentElement.removeChild(graphContainer);
                
                const messageDiv = document.createElement('div');
                messageDiv.id = 'sync-stats-graph';
                messageDiv.style.width = '100%';
                messageDiv.style.height = '400px';
                messageDiv.style.display = 'flex';
                messageDiv.style.alignItems = 'center';
                messageDiv.style.justifyContent = 'center';
                messageDiv.style.color = '#666';
                messageDiv.textContent = 'No sync data available for the selected criteria';
                
                parentElement.insertBefore(messageDiv, parentElement.firstChild);
                
                // Reset summary stats
                document.getElementById('stat-total-syncs').textContent = '0';
                document.getElementById('stat-avg-success-rate').textContent = '0%';
                document.getElementById('stat-common-error').textContent = 'None';
            }
            
            // Display an error message
            function displayErrorMessage(error) {
                const graphContainer = document.getElementById('sync-stats-graph');
                if (syncStatsChart) {
                    syncStatsChart.destroy();
                    syncStatsChart = null;
                }
                
                // Since we're using a canvas now, we need to replace it with a div to show the message
                const parentElement = graphContainer.parentElement;
                parentElement.removeChild(graphContainer);
                
                const messageDiv = document.createElement('div');
                messageDiv.id = 'sync-stats-graph';
                messageDiv.style.width = '100%';
                messageDiv.style.height = '400px';
                messageDiv.style.display = 'flex';
                messageDiv.style.alignItems = 'center';
                messageDiv.style.justifyContent = 'center';
                messageDiv.style.color = '#dc3545';
                messageDiv.textContent = `Error loading sync data: ${error.message}`;
                
                parentElement.insertBefore(messageDiv, parentElement.firstChild);
            }
            
            // Update the summary statistics
            function updateSummaryStats(allLogs, filteredLogs) {
                // Total syncs
                document.getElementById('stat-total-syncs').textContent = filteredLogs.length;
                
                // Average success rate
                let totalSuccess = 0;
                let totalProjects = 0;
                
                filteredLogs.forEach(log => {
                    if (log.success_count !== undefined && log.project_count !== undefined) {
                        totalSuccess += log.success_count;
                        totalProjects += log.project_count;
                    }
                });
                
                const avgSuccessRate = totalProjects === 0 ? 0 : Math.round((totalSuccess / totalProjects) * 100);
                document.getElementById('stat-avg-success-rate').textContent = `${avgSuccessRate}%`;
                
                // Most common error
                const errorCounts = {};
                
                filteredLogs.forEach(log => {
                    try {
                        // Handle array of errors
                        if (log.errors && Array.isArray(log.errors)) {
                            log.errors.forEach(error => {
                                // Make sure error is a string
                                const errorStr = String(error);
                                const errorType = errorStr.includes(':') ? 
                                    errorStr.split(':')[0].trim() : errorStr.trim();
                                errorCounts[errorType] = (errorCounts[errorType] || 0) + 1;
                            });
                        }
                        
                        // Also check projectStats for errors
                        if (log.projectStats) {
                            Object.values(log.projectStats).forEach(stat => {
                                if (stat.error) {
                                    // Make sure error is a string
                                    const errorStr = String(stat.error);
                                    const errorType = errorStr.includes(':') ? 
                                        errorStr.split(':')[0].trim() : errorStr.trim();
                                    errorCounts[errorType] = (errorCounts[errorType] || 0) + 1;
                                }
                            });
                        }
                    } catch (e) {
                        console.error('Error processing error counts:', e);
                    }
                });
                
                if (Object.keys(errorCounts).length === 0) {
                    document.getElementById('stat-common-error').textContent = 'None';
                } else {
                    const mostCommonError = Object.entries(errorCounts)
                        .sort((a, b) => b[1] - a[1])[0];
                    document.getElementById('stat-common-error').textContent = `${mostCommonError[0]} (${mostCommonError[1]} occurrences)`;
                }
            }
            
            // Update project filter options from logs
            function updateProjectFilterOptions(logs) {
                // Process logs to collect projects used in them
                const projects = new Set();
                
                console.log('Updating project filter options from logs:', logs.length);
                
                // Collect all project IDs and names from logs
                logs.forEach(log => {
                    try {
                        console.log('Processing log for projects:', log.id);
                        
                        // Add project IDs from the projects array
                        if (log.projects && Array.isArray(log.projects)) {
                            console.log(`Found ${log.projects.length} projects in log ${log.id}`);
                            log.projects.forEach(projectId => {
                                if (projectId) {
                                    projects.add(projectId);
                                    console.log(`Added project ID: ${projectId}`);
                                }
                            });
                        }
                        
                        // Add project IDs from projectStats
                        if (log.projectStats) {
                            const projectIds = Object.keys(log.projectStats);
                            console.log(`Found ${projectIds.length} projects in projectStats for log ${log.id}`);
                            projectIds.forEach(projectId => {
                                if (projectId) {
                                    projects.add(projectId);
                                    console.log(`Added project ID from stats: ${projectId}`);
                                }
                            });
                        }
                    } catch (e) {
                        console.error('Error processing log for projects:', e);
                    }
                });
                
                // Add any log-related projects to the dropdown
                if (projects.size > 0) {
                    const projectArray = Array.from(projects);
                    console.log(`Found ${projectArray.length} unique projects in logs`);
                    
                    // Get names for these specific projects
                    addProjectsToFilter(projectArray);
                }
            }
            
            // Add specific projects to the filter dropdown
            function addProjectsToFilter(projectIds) {
                if (!projectIds || projectIds.length === 0) {
                    return;
                }
                
                console.log(`Adding ${projectIds.length} specific projects to filter`);
                
                const projectFilter = document.getElementById('stats-project-filter');
                const existingOptions = Array.from(projectFilter.options).map(opt => opt.value);
                
                // Get project names from asana_projects collection
                const projectPromises = projectIds.map(projectId => {
                    // Skip if already in dropdown
                    if (existingOptions.includes(projectId)) {
                        return null;
                    }
                    
                    return db.collection('asana_projects').doc(projectId).get()
                        .then(doc => {
                            if (doc.exists) {
                                const data = doc.data();
                                console.log(`Found project name for ${projectId}: ${data.name}`);
                                return {
                                    id: projectId,
                                    name: data.name || 'Unnamed Project'
                                };
                            } else {
                                console.log(`Project document not found for ${projectId}`);
                                return {
                                    id: projectId,
                                    name: `Project ${projectId}`
                                };
                            }
                        })
                        .catch((error) => {
                            console.error(`Error getting project ${projectId}:`, error);
                            return {
                                id: projectId,
                                name: `Project ${projectId}`
                            };
                        });
                });
                
                // Filter out null values (already in dropdown)
                Promise.all(projectPromises.filter(Boolean))
                    .then(projectsWithNames => {
                        if (projectsWithNames.length === 0) {
                            console.log('No new projects to add to dropdown');
                            return;
                        }
                        
                        // Sort by name
                        projectsWithNames.sort((a, b) => a.name.localeCompare(b.name));
                        
                        console.log(`Adding ${projectsWithNames.length} new projects to dropdown`);
                        
                        // Add options
                        projectsWithNames.forEach(project => {
                            const option = document.createElement('option');
                            option.value = project.id;
                            option.textContent = project.name;
                            projectFilter.appendChild(option);
                            console.log(`Added project to dropdown: ${project.name} (${project.id})`);
                        });
                    })
                    .catch(error => {
                        console.error('Error fetching project names:', error);
                    });
            }
            
            // Add event listeners for filter changes
            document.getElementById('stats-date-range').addEventListener('change', loadSyncStatistics);
            document.getElementById('stats-view-type').addEventListener('change', loadSyncStatistics);
            // Remove the old project filter event listener since we're using a different approach now
            
            // Auto-sync functionality
            let autoSyncTimer = null;
            
            // Schedule the next auto-sync
            function scheduleAutoSync() {
                // Clear existing timer
                if (autoSyncTimer) {
                    clearTimeout(autoSyncTimer);
                }
                
                // Get sync frequency from settings
                db.collection('asana_config').doc('settings').get()
                    .then(doc => {
                        if (doc.exists) {
                            const data = doc.data();
                            let syncFrequencyMinutes = 60; // Default to hourly
                            
                            // Get frequency from various possible field names
                            if (data.sync_frequency) {
                                syncFrequencyMinutes = parseInt(data.sync_frequency);
                            } else if (data.syncFrequency) {
                                syncFrequencyMinutes = parseInt(data.syncFrequency);
                            } else if (data.syncFrequency === '5min') {
                                syncFrequencyMinutes = 5;
                            }
                            
                            // Ensure frequency is at least 5 minutes
                            syncFrequencyMinutes = Math.max(5, syncFrequencyMinutes);
                            
                            // Schedule next sync
                            console.log(`Scheduling next auto-sync in ${syncFrequencyMinutes} minutes`);
                            
                            // Calculate next sync time
                            const nextSyncTime = new Date();
                            nextSyncTime.setMinutes(nextSyncTime.getMinutes() + syncFrequencyMinutes);
                            
                            // Update UI
                            document.getElementById('next-auto-sync').textContent = `Next auto-sync: ${nextSyncTime.toLocaleTimeString()}`;
                            
                            // Set timer
                            autoSyncTimer = setTimeout(performAutoSync, syncFrequencyMinutes * 60 * 1000);
                        } else {
                            console.log('No settings found, defaulting to hourly auto-sync');
                            document.getElementById('next-auto-sync').textContent = 'Auto-sync: Not configured';
                        }
                    })
                    .catch(error => {
                        console.error('Error scheduling auto-sync:', error);
                        document.getElementById('next-auto-sync').textContent = 'Auto-sync: Error';
                    });
            }
            
            // Perform the auto-sync
            function performAutoSync() {
                console.log('Starting auto-sync...');
                
                // First, get the list of all active projects
                db.collection('asana_projects')
                    .where('archived', '!=', true) // Include all non-archived projects
                    .get()
                    .then(snapshot => {
                        if (snapshot.empty) {
                            console.log('No projects found for auto-sync');
                            scheduleAutoSync(); // Reschedule for next time
                            return;
                        }
                        
                        const projects = [];
                        const projectNames = {};
                        
                        snapshot.forEach(doc => {
                            projects.push(doc.id);
                            projectNames[doc.id] = doc.data().name || 'Unnamed Project';
                        });
                        
                        console.log(`Found ${projects.length} projects for auto-sync`);
                        
                        // Create project stats
                        const projectStats = {};
                        projects.forEach(projectId => {
                            projectStats[projectId] = {
                                status: 'started',
                                name: projectNames[projectId] || projectId,
                                start_time: firebase.firestore.FieldValue.serverTimestamp()
                            };
                        });
                        
                        // Create sync log entry
                        db.collection('asana_sync_logs').add({
                            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                            projects: projects,
                            projectNames: projectNames,
                            project_count: projects.length,
                            status: 'started',
                            message: `Started auto-sync for ${projects.length} projects`,
                            projectStats: projectStats,
                            details: {
                                initiated_by: 'auto',
                                initiated_at: firebase.firestore.FieldValue.serverTimestamp()
                            }
                        })
                        .then(docRef => {
                            console.log('Created auto-sync log with ID:', docRef.id);
                            
                            // Update the lastSync time in Firestore
                            db.collection('asana_config').doc('settings').update({
                                last_sync: firebase.firestore.FieldValue.serverTimestamp(),
                                sync_count: firebase.firestore.FieldValue.increment(1)
                            })
                            .then(() => {
                                console.log('Updated last_sync time in settings');
                                
                                // Simulate sync process
                setTimeout(() => {
                                    simulateAutoSyncCompletion(docRef.id, projects, projectNames);
                }, 3000);
                            })
                            .catch(error => {
                                console.error('Error updating last_sync time:', error);
                                scheduleAutoSync();
                            });
                        })
                        .catch(error => {
                            console.error('Error creating auto-sync log:', error);
                            scheduleAutoSync();
                        });
                    })
                    .catch(error => {
                        console.error('Error getting projects for auto-sync:', error);
                        scheduleAutoSync();
                    });
            }
            
            // Simulate auto-sync completion (for demonstration)
            function simulateAutoSyncCompletion(logId, projects, projectNames) {
                console.log('Simulating auto-sync completion...');
                
                // Create simulated results
                const updatedProjectStats = {};
                let successCount = 0;
                let taskCount = 0;
                
                projects.forEach(projectId => {
                    // 85% chance of success for auto-sync
                    const isSuccess = Math.random() < 0.85;
                    const tasks = Math.floor(Math.random() * 15) + 1; // 1-15 tasks
                    
                    if (isSuccess) {
                        successCount++;
                        taskCount += tasks;
                        updatedProjectStats[projectId] = {
                            status: 'success',
                            name: projectNames[projectId] || projectId,
                            tasks_synced: tasks,
                            completion_time: firebase.firestore.FieldValue.serverTimestamp()
                        };
                    } else {
                        const errors = [
                            'API rate limit exceeded',
                            'Task not found',
                            'Permission denied',
                            'Network error',
                            'Invalid resource reference'
                        ];
                        const randomError = errors[Math.floor(Math.random() * errors.length)];
                        
                        updatedProjectStats[projectId] = {
                            status: 'error',
                            name: projectNames[projectId] || projectId,
                            error: randomError,
                            completion_time: firebase.firestore.FieldValue.serverTimestamp()
                        };
                    }
                });
                
                // Update the sync log with completion details
                db.collection('asana_sync_logs').doc(logId).update({
                    status: 'completed',
                    message: `Completed auto-sync of ${projects.length} projects with ${successCount} successful`,
                    projectStats: updatedProjectStats,
                    success_count: successCount,
                    task_count: taskCount,
                    completion_time: firebase.firestore.FieldValue.serverTimestamp()
                })
                .then(() => {
                    console.log('Auto-sync completed successfully');
                    
                    // Reload sync logs to show the updated status
                    loadSyncLogs();
                    
                    // Calculate next sync time
                    const now = new Date();
                    document.getElementById('last-sync-time').textContent = `Last sync: ${now.toLocaleString()}`;
                    
                    // Schedule next auto-sync
                    scheduleAutoSync();
                })
                .catch(error => {
                    console.error('Error completing auto-sync:', error);
                    scheduleAutoSync();
                });
            }
            
            // Start auto-sync scheduler when page loads
            function initializeAutoSync() {
                console.log('Initializing auto-sync...');
                scheduleAutoSync();
            }
            
            // Call this function after connection is established
            function afterConnectionEstablished() {
                // Initialize auto-sync
                initializeAutoSync();
            }
        });
    </script>
</body>
</html> 