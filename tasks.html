<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JoJo's Shave Ice - Task Lists</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/dragula/3.7.3/dragula.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        .header h1 {
            color: #EF6C00;
            margin: 0;
            font-size: 24px;
        }
        .location-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }
        .location-section .logged-in-text {
            font-weight: bold;
        }
        .navbar {
            background-color: #424242;
            padding: 10px 0;
            position: sticky;
            top: 0;
            z-index: 1000;
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        .navbar a {
            color: #FFD60A;
            text-decoration: none;
            font-weight: bold;
            padding: 10px 20px;
            border-radius: 5px;
        }
        .navbar a:hover {
            background-color: #EF6C00;
            color: #FFFFFF;
        }
        .section {
            margin-bottom: 40px;
        }
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #424242;
            color: #FFD60A;
            padding: 10px;
            border-radius: 5px;
        }
        .section-header h2 {
            margin: 0;
        }
        .add-task-container {
            margin-top: 10px;
            display: flex;
            align-items: center;
        }
        .add-task-container label {
            margin-right: 10px;
            font-weight: bold;
        }
        .add-task-container select {
            padding: 5px;
            border: 1px solid #E0E0E0;
            border-radius: 5px;
            margin-right: 10px;
        }
        .add-button {
            background-color: #1E88E5;
            color: #FFFFFF;
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .add-button:hover {
            background-color: #1565C0;
        }
        .list-container {
            background-color: #EDEDED;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }
        .item {
            background-color: #FFFFFF;
            padding: 10px;
            margin-bottom: 5px;
            border: 1px solid #1E88E5;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .item.dragging {
            opacity: 0.5;
        }
        .item-text {
            flex: 1;
        }
        .item-actions {
            display: flex;
            gap: 5px;
        }
        .edit-button, .delete-button {
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .edit-button {
            background-color: #4CAF50;
            color: #FFFFFF;
        }
        .edit-button:hover {
            background-color: #388E3C;
        }
        .delete-button {
            background-color: #FF5252;
            color: #FFFFFF;
        }
        .delete-button:hover {
            background-color: #D32F2F;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #FFFFFF;
            padding: 20px;
            border-radius: 5px;
            width: 80%;
            max-width: 500px;
        }
        .modal-content h3 {
            margin-top: 0;
        }
        .modal-content input, .modal-content textarea, .modal-content select {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #E0E0E0;
            border-radius: 5px;
        }
        .modal-content textarea {
            height: 100px;
        }
        .modal-buttons {
            display: flex;
            justify-content: space-between;
        }
        .modal-button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .save-button {
            background-color: #1E88E5;
            color: #FFFFFF;
        }
        .save-button:hover {
            background-color: #1565C0;
        }
        .cancel-button {
            background-color: #B0BEC5;
            color: #FFFFFF;
        }
        .cancel-button:hover {
            background-color: #90A4AE;
        }
        .read-only {
            background-color: #f0f0f0;
            border: 1px solid #ccc;
        }
        .dynamic-field {
            display: none;
        }
        .loading {
            text-align: center;
            color: #888;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>JoJo's Shave Ice Management App</h1>
        <div class="location-section">
            <span class="logged-in-text" id="logged-in-location">Location: Loading...</span>
        </div>
    </div>

    <!-- Navigation Bar -->
    <div class="navbar">
        <a href="tasks.html">Task Lists</a>
        <a href="prep-list.html">Prep List</a>
        <a href="playlists.html">Playlists</a>
        <a href="employees.html">Employees</a>
        <a href="locations.html">Locations</a>
    </div>

    <!-- Tasks Section -->
    <div id="tasks-section" class="section">
        <div class="loading" id="loading-message">Loading tasks...</div>
        <div class="section increasing">
            <div class="section-header">
                <h2>Tasks</h2>
            </div>
            <div class="add-task-container">
                <label for="task-category-select">Select List:</label>
                <select id="task-category-select">
                    <option value="Opening">Opening</option>
                    <option value="Mid">Mid</option>
                    <option value="Closing">Closing</option>
                </select>
                <button class="add-button" onclick="openTaskModal('location')">Add Task</button>
            </div>
        </div>
        <div class="section">
            <div class="section-header">
                <h2>Opening Tasks</h2>
            </div>
            <div id="opening-task-list" class="list-container"></div>
        </div>
        <div class="section">
            <div class="section-header">
                <h2>Mid Tasks</h2>
            </div>
            <div id="mid-task-list" class="list-container"></div>
        </div>
        <div class="section">
            <div class="section-header">
                <h2>Closing Tasks</h2>
            </div>
            <div id="closing-task-list" class="list-container"></div>
        </div>
    </div>

    <!-- Task Modal -->
    <div id="task-modal" class="modal">
        <div class="modal-content">
            <h3 id="task-modal-title">Add Task</h3>
            <input type="text" id="task-name" placeholder="Task Name">
            <select id="task-type" onchange="updateTaskModalFields()">
                <option value="CheckDone">Check Done or Not</option>
                <option value="ShortText">Short Text</option>
                <option value="LongText">Long Text</option>
                <option value="VolumeRecording">Volume Recording (Numerical)</option>
                <option value="MultipleChoice">Multiple Choice</option>
                <option value="DateTimePicker">Date/Time Picker</option>
                <option value="DropdownList">Dropdown List</option>
                <option value="YesNo">Yes/No</option>
                <option value="RatingScale">Rating Scale</option>
            </select>
            <textarea id="task-description" placeholder="Description"></textarea>
            <input type="text" id="task-category" placeholder="Category (e.g., Opening)" readonly>
            <input type="text" id="task-section" placeholder="Section (e.g., Setup & Prep)">
            <div id="options-field" class="dynamic-field">
                <label for="task-options">Options (comma-separated, e.g., Morning,Afternoon,Evening):</label>
                <input type="text" id="task-options" placeholder="Enter options">
            </div>
            <div id="constraints-field" class="dynamic-field">
                <label for="task-constraints-min">Min Value (for Volume Recording, Rating Scale):</label>
                <input type="number" id="task-constraints-min" placeholder="Min">
                <label for="task-constraints-max">Max Value:</label>
                <input type="number" id="task-constraints-max" placeholder="Max">
            </div>
            <div class="modal-buttons">
                <button class="modal-button save-button" onclick="saveTask()">Save</button>
                <button class="modal-button cancel-button" onclick="closeModal('task-modal')">Cancel</button>
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore-compat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dragula/3.7.3/dragula.min.js"></script>
    <script src="fractionalIndex.js"></script>
    <script src="offlineSync.js"></script>
    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBpkq5DgX3elAU1aBLAYbyUZJ6gF8_pcvE",
            authDomain: "jojo-s-management-app.firebaseapp.com",
            projectId: "jojo-s-management-app",
            storageBucket: "jojo-s-management-app.firebasestorage.app",
            messagingSenderId: "1057424025658",
            appId: "1:1057424025658:web:954b5ad6109119b4136d03"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        let locationCode = localStorage.getItem('locationCode') || null;
        let editingTaskId = null;
        let editingTaskType = 'location'; // 'base' or 'location'
        let allTasksByCategory = { Opening: [], Mid: [], Closing: [] };
        let currentLocationDocId = null;

        // Check if logged in and fetch the document ID for the locationCode
        if (!locationCode) {
            window.location.href = 'login.html';
        } else {
            initApp();
        }

        // Initialize the app with offline sync
        async function initApp() {
            try {
                console.log('Starting initApp...');
                await fetchLocationDocId(locationCode);
                console.log('Location fetched, currentLocationDocId:', currentLocationDocId);

                const data = await OfflineSync.initOfflineSync(db, currentLocationDocId);
                console.log('Offline sync completed, data:', data);

                allTasksByCategory = groupTasksByCategory(data.baseTasks, data.overrides, data.locationTasks);
                console.log('Tasks grouped by category:', allTasksByCategory);

                // Hide loading message and render tasks
                document.getElementById('loading-message').style.display = 'none';
                renderTasks();
            } catch (error) {
                console.error('Error initializing app:', error);
                document.getElementById('loading-message').textContent = 'Error loading tasks. Please try again.';
            }
        }

        async function fetchLocationDocId(locCode) {
            try {
                console.log('Fetching location for code:', locCode);
                let allLocations = [];
                if (navigator.onLine) {
                    const locationsRef = db.collection('locations');
                    const querySnapshot = await locationsRef.where('code', '==', locCode).get();
                    console.log('Location query snapshot:', querySnapshot.size);

                    if (querySnapshot.empty) {
                        if (locCode === 'BASE001') {
                            currentLocationDocId = 'base-model';
                        } else {
                            window.location.href = 'login.html';
                            return;
                        }
                    } else {
                        querySnapshot.forEach(doc => {
                            currentLocationDocId = doc.id;
                        });
                    }

                    // Store location data in local storage
                    const snapshot = await db.collection('locations').get();
                    console.log('Total locations fetched:', snapshot.size);
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const locCode = data.code || doc.id;
                        const name = data.name || doc.id;
                        allLocations.push({ id: doc.id, code: locCode, name });
                    });
                    localStorage.setItem('locations', JSON.stringify(allLocations));
                } else {
                    // Assume locationDocId is stored locally or default to base-model for BASE001
                    currentLocationDocId = locCode === 'BASE001' ? 'base-model' : localStorage.getItem('currentLocationDocId') || null;
                    if (!currentLocationDocId) {
                        window.location.href = 'login.html';
                        return;
                    }
                    allLocations = JSON.parse(localStorage.getItem('locations') || '[]');
                }

                // Set the logged-in location text
                const loggedInLocation = allLocations.find(loc => loc.code === locationCode);
                const loggedInText = loggedInLocation 
                    ? `Location: ${loggedInLocation.name} (${loggedInLocation.code})`
                    : `Location: Unknown (${locationCode})`;
                document.getElementById('logged-in-location').textContent = loggedInText;
                console.log('Logged-in location text set:', loggedInText);
            } catch (error) {
                console.error('Error fetching location document ID:', error);
                throw error;
            }
        }

        // Group tasks by category
        function groupTasksByCategory(baseTasks, overrides, locationTasks) {
            console.log('Grouping tasks...');
            console.log('Base tasks:', baseTasks.length);
            console.log('Overrides:', overrides.length);
            console.log('Location tasks:', locationTasks.length);

            const overrideMap = {};
            overrides.forEach(override => {
                overrideMap[override.id] = override;
            });

            const customizedBaseTasks = baseTasks.map(task => {
                const override = overrideMap[task.id] || {};
                return {
                    ...task,
                    description: override.customDescription || task.defaultDescription,
                    order: override.customOrder || task.defaultOrder,
                    response: override.response || {}
                };
            });

            const allTasks = [...customizedBaseTasks, ...locationTasks];
            const tasksByCategory = { Opening: [], Mid: [], Closing: [] };
            allTasks.forEach(task => {
                if (tasksByCategory[task.category]) {
                    tasksByCategory[task.category].push(task);
                }
            });

            console.log('Tasks grouped by category:', tasksByCategory);
            return tasksByCategory;
        }

        // Render all tasks
        function renderTasks() {
            console.log('Rendering tasks...');
            renderTaskList('Opening', document.getElementById('opening-task-list'));
            renderTaskList('Mid', document.getElementById('mid-task-list'));
            renderTaskList('Closing', document.getElementById('closing-task-list'));
            console.log('Tasks rendered.');
        }

        // Load Tasks
        async function loadTasks() {
            console.log('Loading tasks...');
            if (!currentLocationDocId) {
                document.getElementById('opening-task-list').innerHTML = '<p>Please set a location code.</p>';
                document.getElementById('mid-task-list').innerHTML = '<p>Please set a location code.</p>';
                document.getElementById('closing-task-list').innerHTML = '<p>Please set a location code.</p>';
                return;
            }

            try {
                let data;
                if (navigator.onLine) {
                    console.log('Fetching data online...');
                    data = await OfflineSync.initOfflineSync(db, currentLocationDocId);
                } else {
                    console.log('Fetching data offline...');
                    data = await OfflineSync.loadLocalData();
                }

                allTasksByCategory = groupTasksByCategory(data.baseTasks, data.overrides, data.locationTasks);
                document.getElementById('loading-message').style.display = 'none';
                renderTasks();
            } catch (error) {
                console.error('Error loading tasks:', error);
                document.getElementById('loading-message').textContent = 'Error loading tasks. Please try again.';
            }
        }

        // Render Task List for a Category
        function renderTaskList(category, taskListElement) {
            console.log(`Rendering ${category} tasks...`);
            taskListElement.innerHTML = '';
            const tasks = allTasksByCategory[category];
            if (!tasks || tasks.length === 0) {
                taskListElement.innerHTML = '<p>No tasks found for this category.</p>';
                return;
            }

            // Sort tasks by order (fractional indexing)
            const sortedTasks = tasks.sort((a, b) => (a.order || a.defaultOrder || '').localeCompare(b.order || b.defaultOrder || ''));
            console.log(`Sorted ${category} tasks:`, sortedTasks);

            sortedTasks.forEach(task => {
                const taskDiv = document.createElement('div');
                taskDiv.className = `item ${task.isBase ? 'read-only' : ''}`;
                taskDiv.id = `task-${task.id}`;
                taskDiv.innerHTML = `
                    <span class="item-text">${task.name} (${task.section}) [${task.type}]</span>
                    <div class="item-actions">
                        ${task.isBase ? '' : `<button class="edit-button" onclick="editTask('${task.id}', ${task.isBase})">Edit</button>`}
                        ${task.isBase ? '' : `<button class="delete-button" onclick="deleteTask('${task.id}')">Delete</button>`}
                    </div>
                `;
                taskListElement.appendChild(taskDiv);
            });

            // Enable drag-and-drop for non-base tasks
            dragula([taskListElement], {
                moves: (el, container, handle) => !el.classList.contains('read-only') && !handle.classList.contains('item-actions') && !handle.classList.contains('edit-button') && !handle.classList.contains('delete-button')
            }).on('drop', async (el, target, source, sibling) => {
                const taskId = el.id.replace('task-', '');
                const tasks = Array.from(taskListElement.children).map(item => item.id.replace('task-', ''));
                const taskIndex = tasks.indexOf(taskId);

                // Find the previous and next tasks' order values
                const prevTaskId = taskIndex > 0 ? tasks[taskIndex - 1] : null;
                const nextTaskId = taskIndex < tasks.length - 1 ? tasks[taskIndex + 1] : null;

                const prevTask = prevTaskId ? sortedTasks.find(task => task.id === prevTaskId) : null;
                const nextTask = nextTaskId ? sortedTasks.find(task => task.id === nextTaskId) : null;

                const prevOrder = prevTask ? (prevTask.isBase ? prevTask.order || prevTask.defaultOrder : prevTask.order) : null;
                const nextOrder = nextTask ? (nextTask.isBase ? nextTask.order || nextTask.defaultOrder : nextTask.order) : null;

                // Generate a new fractional index for the moved task
                const newOrder = FractionalIndex.generateMidpoint(prevOrder, nextOrder);

                // Update the moved task's order
                const tasksRef = db.collection('locations').doc(currentLocationDocId).collection('tasks');
                if (navigator.onLine) {
                    await tasksRef.doc(taskId).update({
                        order: newOrder
                    });
                } else {
                    // Queue the operation for offline sync
                    await OfflineSync.queueOperation({
                        action: 'updateTask',
                        taskId: taskId,
                        data: { order: newOrder }
                    });
                    // Update local data
                    const localTasks = await OfflineSync.loadLocalData();
                    const updatedTasks = localTasks.locationTasks.map(task => {
                        if (task.id === taskId) {
                            return { ...task, order: newOrder };
                        }
                        return task;
                    });
                    await OfflineSync.storeData('tasks', updatedTasks);
                }

                // Reload tasks
                await loadTasks();
            });
        }

        // Update Task Modal Fields Based on Task Type
        function updateTaskModalFields() {
            const taskType = document.getElementById('task-type').value;
            const optionsField = document.getElementById('options-field');
            const constraintsField = document.getElementById('constraints-field');

            // Reset visibility
            optionsField.style.display = 'none';
            constraintsField.style.display = 'none';

            // Show fields based on task type
            if (['MultipleChoice', 'DropdownList'].includes(taskType)) {
                optionsField.style.display = 'block';
            }
            if (taskType === 'VolumeRecording' || taskType === 'RatingScale') {
                constraintsField.style.display = 'block';
            }
        }

        // Open Task Modal
        function openTaskModal(taskType, taskId = null) {
            editingTaskType = taskType;
            editingTaskId = taskId;
            const modal = document.getElementById('task-modal');
            const title = document.getElementById('task-modal-title');
            const nameInput = document.getElementById('task-name');
            const typeSelect = document.getElementById('task-type');
            const descriptionInput = document.getElementById('task-description');
            const categoryInput = document.getElementById('task-category');
            const sectionInput = document.getElementById('task-section');
            const optionsInput = document.getElementById('task-options');
            const constraintsMinInput = document.getElementById('task-constraints-min');
            const constraintsMaxInput = document.getElementById('task-constraints-max');

            const selectedCategory = document.getElementById('task-category-select').value;

            if (taskId) {
                title.textContent = 'Edit Task';
                const tasksRef = db.collection('locations').doc(currentLocationDocId).collection('tasks');
                tasksRef.doc(taskId).get().then(doc => {
                    const task = doc.data();
                    nameInput.value = task.name;
                    typeSelect.value = task.type;
                    descriptionInput.value = task.description;
                    categoryInput.value = task.category;
                    sectionInput.value = task.section;
                    optionsInput.value = task.options ? task.options.join(',') : '';
                    if (task.constraints) {
                        constraintsMinInput.value = task.constraints.min || '';
                        constraintsMaxInput.value = task.constraints.max || '';
                    } else {
                        constraintsMinInput.value = '';
                        constraintsMaxInput.value = '';
                    }
                    updateTaskModalFields();
                });
            } else {
                title.textContent = 'Add Task';
                editingTaskId = null;
                nameInput.value = '';
                typeSelect.value = 'CheckDone';
                descriptionInput.value = '';
                categoryInput.value = selectedCategory;
                sectionInput.value = '';
                optionsInput.value = '';
                constraintsMinInput.value = '';
                constraintsMaxInput.value = '';
                updateTaskModalFields();
            }

            modal.style.display = 'flex';
        }

        // Close Modal
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // Save Task
        async function saveTask() {
            const name = document.getElementById('task-name').value.trim();
            const type = document.getElementById('task-type').value;
            const description = document.getElementById('task-description').value.trim();
            const category = document.getElementById('task-category').value.trim();
            const section = document.getElementById('task-section').value.trim();
            const optionsInput = document.getElementById('task-options').value.trim();
            const constraintsMin = document.getElementById('task-constraints-min').value.trim();
            const constraintsMax = document.getElementById('task-constraints-max').value.trim();

            if (!name || !type || !category || !section) {
                alert('Please fill in all required fields.');
                return;
            }

            const taskData = {
                name,
                type,
                description,
                category,
                section,
                order: 'a', // Initial order, will be adjusted on first load
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                response: {},
                locationId: currentLocationDocId
            };

            // Add options if applicable
            if (['MultipleChoice', 'DropdownList'].includes(type) && optionsInput) {
                taskData.options = optionsInput.split(',').map(item => item.trim());
            }

            // Add constraints if applicable
            if (type === 'VolumeRecording' || type === 'RatingScale') {
                taskData.constraints = {};
                if (constraintsMin) taskData.constraints.min = parseFloat(constraintsMin);
                if (constraintsMax) taskData.constraints.max = parseFloat(constraintsMax);
            }

            const tasksRef = db.collection('locations').doc(currentLocationDocId).collection('tasks');
            try {
                if (navigator.onLine) {
                    if (editingTaskId) {
                        await tasksRef.doc(editingTaskId).update(taskData);
                    } else {
                        await tasksRef.add(taskData);
                    }
                } else {
                    if (editingTaskId) {
                        await OfflineSync.queueOperation({
                            action: 'updateTask',
                            taskId: editingTaskId,
                            data: taskData
                        });
                        // Update local data
                        const localTasks = await OfflineSync.loadLocalData();
                        const updatedTasks = localTasks.locationTasks.map(task => {
                            if (task.id === editingTaskId) {
                                return { ...task, ...taskData };
                            }
                            return task;
                        });
                        await OfflineSync.storeData('tasks', updatedTasks);
                    } else {
                        const newTaskId = Date.now().toString();
                        taskData.id = newTaskId;
                        await OfflineSync.queueOperation({
                            action: 'createTask',
                            task: taskData
                        });
                        // Add to local data
                        const localTasks = await OfflineSync.loadLocalData();
                        localTasks.locationTasks.push(taskData);
                        await OfflineSync.storeData('tasks', localTasks.locationTasks);
                    }
                }

                closeModal('task-modal');
                await loadTasks();
            } catch (error) {
                console.error('Error saving task:', error);
                alert('Error saving task. Please try again.');
            }
        }

        // Edit Task
        function editTask(taskId, isBase) {
            if (isBase) {
                alert('Base tasks cannot be edited here. Use the Base Model Portal.');
                return;
            }
            openTaskModal('location', taskId);
        }

        // Delete Task
        async function deleteTask(taskId) {
            if (confirm('Are you sure you want to delete this task?')) {
                const tasksRef = db.collection('locations').doc(currentLocationDocId).collection('tasks');
                try {
                    if (navigator.onLine) {
                        await tasksRef.doc(taskId).delete();
                    } else {
                        await OfflineSync.queueOperation({
                            action: 'deleteTask',
                            taskId: taskId
                        });
                        // Remove from local data
                        const localTasks = await OfflineSync.loadLocalData();
                        const updatedTasks = localTasks.locationTasks.filter(task => task.id !== taskId);
                        await OfflineSync.storeData('tasks', updatedTasks);
                    }
                    await loadTasks();
                } catch (error) {
                    console.error('Error deleting task:', error);
                    alert('Error deleting task. Please try again.');
                }
            }
        }
    </script>
</body>
</html>